Expressoの目的は、プログラミング初学者および中級者にプログラミングの基礎を学んでもらうこと。
そのため、極端に複雑すぎる機能は極力廃し、プログラミングの基礎として重要と考えられる要素をいれこむこととする。

-概要
"What the compiler doesn't allow you to do is just what you can't"と"Just do as the compiler says"の
言語哲学通り、コンパイラの言うとおりにしていれば、「正しい」プログラムを書ける言語を目指す。
これは、実行時エラーを極力廃し、「コンパイルエラーにあらずんば、エラーにあらず」的な意味も含む。
###################################
そのために、エラーメッセージは的確かつ簡潔にしつつ、追加の情報をすぐに得られる形が望ましい。
エラー出力は、Rustを参考に。
TODO:具体案
###################################
-メモリの扱い
ローカルスコープはスタックアロケートにする。一方でヒープ領域も用意し、new演算子の使用がヒープ領域へのメモリ確保宣言を
意味することと定義する。return文によりローカル変数が戻り値となる場合は、暗黙的にヒープ領域へのコピーを行う。
ただし、オブジェクトがコピー不可能だった場合は、コンパイルエラーにする。（ここでのコピー不可能には、ICloneable実装による
明示的コピーのみのサポートも含む。この場合は、プログラマーが明示的にコピーを宣言すること。暗黙的コピーによるバグ発生の防止）
***********************************
ここについては、コンパイラの最適化が必要不可欠と思われる。もっとも、最初からヒープ領域に確保してくれれば
何もする必要はないのだけど・・・
スタックとヒープの区別は廃止。.NETランタイムを使用しているので、classとstructで値型と参照型を使い分け、
スタックとヒープアロケートを区別できる可能性はあるが、教育用言語でそこまでのチューニングは必要ないと判断した。
structも導入するかは未定。
***********************************

上記のコピー可否も含めて、オブジェクトに対する基本操作の可否をどう表現するか。
Rust的にtraitの実装にするか、あるいはインターフェースの継承を含む
オペレータのオーバーロードに類するシステムにするか
(SwiftやHaskellにあるユーザ定義演算子は、あると便利そうだが、実装が煩雑になりそうなのでひとまず見送る。
それにExpressoの趣旨に合わない気もする・・・)

チュートリアルにスタックとヒープと表記しても、ちんぷんかんぷんだろうから、関数内部に閉じた貯蔵庫と
外の世界という表現を用いる。変数は、何か物が入る箱であり、この箱をやりとりすることで関数は処理を行う。
***********************************
ヒープ領域のメモリ管理は、ガベージコレクタ(GC)に一任する。GC自体の実装方法は問わないが、言語仕様としてGCの使用を義務付ける。
-変数の扱い
変数の生存期間を意識してもらうために、ブロックスコープに変数スコープを対応付ける。その他、各種文に対しても、
変数スコープを与えることとする。
参照渡しとしてC++やRust形式の&演算子を使用する。アンセーフコードの実行、及びそれに関連してポインタのサポートをどうするかは要検討。
***********************************
変数の初期化を義務付ける関係上、C#のout演算子に当たるものは実装せずとも、必然的にそのような使い方しかできなくなる。
***********************************
また、let-bindingとvar-riable-declaration構文を用意。let-bindingのタグ付けと、var-riable-declarationの
箱を用意する2つの構文の意義と違いを意識してもらいたい。
-クラスの扱い
コンストラクタとデストラクタ専用の構文は特に用意しない。いずれも、宣言時と全く同じ書き方により、privateフィールドも含めて
明示的に初期化を義務付けるものとする。一部のフィールドに対して明示的初期化を省略したい場合は、RustやSwiftに倣って
staticなファクトリメソッドを定義してもらうこと。
-参照の扱い
参照の場合、有効なオブジェクトを指さない参照は妥当ではないので、nullリテラルはいらなそう。
nullリテラルは、.NETとの相互運用に限ってのみ導入、使用可能。それ以外の場面で値の存在不在を表したいなら、
標準ライブラリのOption型を使うものとする。
参照があるので、当然pass by referenceとpass by valueの違いも意識してもらいたいが、
それと同じぐらいオブジェクトのコピーについても注意を払ってもらいたい。特にPOD(Plain Old Data)とそうでないものについて。