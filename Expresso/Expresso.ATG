using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Numerics;
using System.Text;

using Expresso.Ast;
using Expresso.Ast.Analysis;
using Expresso.TypeSystem;

using ICSharpCode.NRefactory;


using ExpressoModifiers = Expresso.Ast.Modifiers;


COMPILER Expresso
    internal SymbolTable Symbols{get; set;}
    bool seen_let;
    public string ParsingFileName{get; set;}
	public ExpressoAst TopmostAst{get; private set;}	//the top-level AST the parser is parsing
    public TextLocation CurrentLocation{
        get{
            return new TextLocation(t.line, t.col);
        }
    }

	///<summary>
	/// Parser Implementation details:
	/// 	During parsing we'll construct the symbol table.
	/// 	And in post-parse process, do type validity check and flow analysis, including local name bindings
    ///     and type inference.
	///		Note that the identifiers are just placeholders until after doing name binding. 
	/// 	(Thus referencing them causes runtime exceptions)
	///</summary>
    ///<remarks>
    /// The Parser class itself is responsible for constructing the AST AND the symbol table.
    ///</remarks>
	Parser()
	{
		//Add built-in functions
		/*FunctionDefinition[] native_funcs = {
			new NativeLambdaUnary("abs", ImplementationHelpers.MakeArg(new Identifier("val", new TypeAnnotation(ObjectTypes.Var), null, 0)), ExpressoFunctions.Abs),
			new NativeLambdaUnary("sqrt", ImplementationHelpers.MakeArg(new Identifier("val", new TypeAnnotation(ObjectTypes.Var), null, 0)), ExpressoFunctions.Sqrt),
			new NativeLambdaUnary("toInt", ImplementationHelpers.MakeArg(new Identifier("val", new TypeAnnotation(ObjectTypes.Var), null, 0)), ExpressoFunctions.ToInt)
		};
		foreach(var tmp in native_funcs)
			cur_scope.AddFunction(tmp);*/
        Symbols = new SymbolTable();
	}
	
	LiteralExpression CreateDefaultValue(KnownTypeCode type)
	{
		LiteralExpression result = null;
		var loc = CurrentLocation;
        var type_name = type.ToString().ToLower();

		switch(type){
		case KnownTypeCode.Int:
        case KnownTypeCode.UInt:
        case KnownTypeCode.Byte:
			result = Expression.MakeConstant(type_name, 0, loc);
			break;
			
		case KnownTypeCode.Bool:
			result = Expression.MakeConstant(type_name, false, loc);
			break;
			
		case KnownTypeCode.Float:
			result = Expression.MakeConstant(type_name, 0.0, loc);
			break;
			
		case KnownTypeCode.String:
			result = Expression.MakeConstant(type_name, "", loc);
			break;

        case KnownTypeCode.Char:
            result = Expression.MakeConstant(type_name, '\0', loc);
			break;

		default:
			SemErr("Unknown object type");
			break;
		}
		
		return result;
	}

    PrimitiveType CreateType(string keyword, TextLocation loc)
    {
        return new PrimitiveType(keyword, loc);
    }

    /// <summary>
    /// Creates a new <see ref="ICSharpCode.NRefactory.TextLocation">
    /// that points to the location n characters before the current.
    /// </summary>
    /// <remarks>
    /// It doesn't take line breaks into account.
    /// </remarks>
    TextLocation CreateLocationBefore(int n)
    {
        return new TextLocation(t.line, t.col - n);
    }

    void GoDownScope()
    {
        Symbols = Symbols.Child;
    }

    void GoUpScope()
    {
        Symbols = Symbols.Parent;
    }
	
	bool IsDefiningLValue()
	{
        return la.kind == _keyword_let || la.kind == _keyword_var;
	}
	
	bool IsSequenceInitializer()
	{
		Token x = la;
		if(x.kind != _comma)
            return true;
		
		while(x.kind != 0 && x.kind != _comma && x.kind != _keyword_for)
            x = scanner.Peek();
		
        scanner.ResetPeek();
        return x.kind != _keyword_for;
	}

    /*bool IsObjectCreation()
    {
        scanner.StartPeek();
        Token x = la;
        if(x.kind == 
    }

    bool IsIntegerSequenceExpression()
    {
        scanner.StartPeek();
        var x = la;
        while(x.kind != Tokens.)
    }*/

    bool NotFinalComma()
    {
        return la.kind != _rparen || la.kind != _triple_dots;
    }
	
	public void SemanticError(string format, params object[] args)
	{
		//Convenient method for printing a semantic error with a format string
		SemErr(string.Format(format, args));
	}
	
/*--------------------------------------------------------------------------*/
CHARACTERS
  letter = 'A'..'Z' + 'a'..'z'.
  digit = '0'..'9'.
  hex_letter = digit + 'a'..'f' + 'A'..'F'.
  cr  = '\r'.
  lf  = '\n'.
  tab = '\t'.
  quotedLetter = ANY - '"'.
  dot = '.'.

TOKENS
  double_dots = "..".
  triple_dots = "...".
  rbracket = ']'.
  colon = ':'.
  semicolon = ';'.
  lcurly = '{'.
  lparen = '('.
  lbracket = '['.
  rparen = ')'.
  rcurly = '}'.
  comma = ','.
  dot = '.'.
  ident  = (letter | '_') {'_' | letter | digit}.
  integer = digit {digit}
  			| digit {digit} CONTEXT("..")
            | digit {digit} CONTEXT("...").
  float = digit {digit} dot {digit} [('e' | 'E') ['+' | '-'] digit {digit}]
  		  | [digit {digit}] dot digit {digit} [('e' | 'E') ['+' | '-'] digit {digit}].
  hex_digit = '0' ('x' | 'X') hex_letter {hex_letter}.
  string_literal = '"' {quotedLetter} '"'.
  keyword_in = "in".
  keyword_for = "for".
  keyword_let = "let".
  keyword_var = "var".

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO lf

IGNORE cr + lf + tab



PRODUCTIONS
/*------------------------------------------------------------------------*/
Expresso                    		(. ExpressoAst module_decl = null; .)
= 
  ModuleBody<out module_decl>		(.
                                        Debug.Assert(Symbols.Parent == null);
                                        try{
                                            ExpressoNameBinder.BindAst(module_decl, this); //Here's the start of post-parse processing
                                        }
                                        catch(ParserException pe){
                                            SemanticError(pe.Message, pe.Objects);
                                        }
  										this.TopmostAst = module_decl;	//Currently there is not so much code out there, though...
  									.).
/*------------------------------------------------------------------------*/
ModuleBody<out ExpressoAst ast>	    (.  var decls = new List<EntityDeclaration>();
                                        string module_name; Modifiers modifiers = ExpressoModifiers.None;
										List<ImportDeclaration> prog_defs = null; EntityDeclaration decl = null;
									.)
=
  ModuleNameDefinition<out module_name>
  [ ProgramDefinition<out prog_defs>
  ]
  								
  [ "export"						(. modifiers = ExpressoModifiers.Export; .)
  ]
  ( FuncDecl<out decl, modifiers>
  | ClassDecl<out decl, modifiers>
  )									(.  decls.Add(decl);
										modifiers = ExpressoModifiers.None;
									.)
  {
    [ "export"						(. modifiers = ExpressoModifiers.Export; .)
    ]
    ( FuncDecl<out decl, modifiers>
    | ClassDecl<out decl, modifiers>
    )								(.  decls.Add(decl);
    									modifiers = ExpressoModifiers.None;
    								.)
  }									(.  ast = AstNode.MakeModuleDef(module_name, decls, prog_defs); .) .
/*------------------------------------------------------------------------*/
ModuleNameDefinition<out string moduleName>
=
  "module"
  ident                         (. moduleName = t.val; .)
  SYNC ';'.
/*------------------------------------------------------------------------*/
ProgramDefinition<. out List<ImportDeclaration> imports .>	(. imports = new List<ImportDeclaration>();
                                                               ImportDeclaration tmp;
                                                            .)
=
  ImportDecl<out tmp>			(. imports.Add(tmp); .)
  { ImportDecl<out tmp>		    (. imports.Add(tmp); .)
  }.
/*------------------------------------------------------------------------*/
ImportDecl<out ImportDeclaration decl>
            (.  string module_name, alias = null; var module_names = new List<string>();
				var aliases = new List<string>();
			.)
=
  SYNC
  "import"
  ModuleName<out module_name>
  [ "as"
    ident						(. alias = t.val; .)
  ]								(.  module_names.Add(module_name);
  									aliases.Add(alias);
  								.)
  { ','
    ModuleName<out module_name>
    [ "as"
      ident						(. alias = t.val; .)
    ]							(.  module_names.Add(module_name);
  									aliases.Add(alias);
  								.)
  }
  SYNC ';' 						(. decl = AstNode.MakeImportDecl(module_names, aliases); .).
/*------------------------------------------------------------------------*/
ModuleName<out string name>		(. var sb = new StringBuilder(); .)
=
  ident							(. sb.Append(t.val); .)
  { '.'							(. sb.Append('.'); .)
    ident						(. sb.Append(t.val); .)
  }								(. name = sb.ToString(); .).
/*------------------------------------------------------------------------*/
ClassDecl<out EntityDeclaration decl, Modifiers modifiers>   
  (.  EntityDeclaration entity = null; var decls = new List<EntityDeclaration>();
      string name; var base_names = new List<Identifier>(); Modifiers cur_flag;
  .)
=
  SYNC
  "class"                               (. Symbols.AddScope(); .)
  ident				    				(. name = t.val; Symbols.AddTypeSymbol(name); .)
  [ ':'
    ident		    					(. base_names.Add(AstNode.MakeIdentifier(t.val)); .)
    { ','
      ident							    (. base_names.Add(AstNode.MakeIdentifier(t.val)); .)
    }
  ]
  '{'                                   (. GoDownScope(); .)
  {
    Modifiers<out cur_flag>
    ( MethodDecl<out entity, cur_flag>  (. decls.Add(entity); .)
    | FieldDecl<out entity, cur_flag>
      ';'								(. decls.Add(entity); .)
    | ClassDecl<out entity, cur_flag>   (. decls.Add(entity); .)
    )
  }
  SYNC '}'							    (. //decl = AstNode.MakeClassDecl(name, base_names, decls, modifiers);
                                           GoUpScope();
                                        .) .
/*------------------------------------------------------------------------*/
Modifiers<out Modifiers modifiers>  (. modifiers = ExpressoModifiers.Private; .)
=
  { "public"                (. modifiers |= ExpressoModifiers.Public; .)
  | "protected"             (. modifiers |= ExpressoModifiers.Protected; .)
  | "private"               (. modifiers |= ExpressoModifiers.Private; .)
  | "static"                (. modifiers |= ExpressoModifiers.Static; .)
  }.
/*------------------------------------------------------------------------*/
MethodDecl<out EntityDeclaration decl, Modifiers modifiers>
                                (.
									string name; AstType type = null; BlockStatement block;
									var @params = new List<ParameterDeclaration>();
                                    var start_loc = CurrentLocation;
								.)
=
  SYNC
  "def"                         (. Symbols.AddScope(); .)
  ident							(. name = t.val; Symbols.AddSymbol(name); .)
  '('
  [ParamList<out @params>]
  ')'
  [ "->"
    Type<out type>
  ]                             (. if(type == null)
                                       type = new PlaceholderType(CurrentLocation);
                                .)
  Block<out block> 				(. decl = EntityDeclaration.MakeFunc(name, @params, block, type, modifiers, start_loc); .).
/*------------------------------------------------------------------------*/
FieldDecl<. out EntityDeclaration field, Modifiers modifiers .>
  (. string name; AstType type; Expression rhs; Identifier ident;
     var idents = new List<Identifier>(); var exprs = new List<Expression>();
     var start_loc = CurrentLocation;
  .)
= 
  ( "let"
  | "var"
  )
  VarDef<out name, out type, out rhs> (.  ident = AstNode.MakeIdentifier(name, type);
                                          idents.Add(ident);
                                          exprs.Add(rhs);
                                          Symbols.AddSymbol(name, type);
                                      .)  
  { ','					 		
    VarDef<out name, out type, out rhs> (. ident = AstNode.MakeIdentifier(name, type);
                                           idents.Add(ident);
                                           exprs.Add(rhs);
                                           Symbols.AddSymbol(name, type);
                                        .)
  }								       (. field = EntityDeclaration.MakeField(idents, exprs, modifiers, start_loc, CurrentLocation); .).
/*------------------------------------------------------------------------*/
Type<out AstType type>              (. var start_loc = CurrentLocation; type = AstType.Null;.)
=
 ( "int"                			(. type = CreateType(t.val, start_loc); .)
 | "uint"                           (. type = CreateType(t.val, start_loc); .)
 | "bool"               			(. type = CreateType(t.val, start_loc); .)
 | "float"							(. type = CreateType(t.val, start_loc); .)
 | "double"                         (. type = CreateType(t.val, start_loc); .)
 | "bigint"							(. type = CreateType(t.val, start_loc); .)
 | "string"							(. type = CreateType(t.val, start_loc); .)
 | "byte"						    (. type = CreateType(t.val, start_loc); .)
 | "char"                           (. type = CreateType(t.val, start_loc); .)
 | TupleTypeSignature<out type>
 | "vector"							(. type = CreateType(t.val, start_loc); .)
 | "dictionary"						(. type = CreateType(t.val, start_loc); .)
 | "function"						(. type = CreateType(t.val, start_loc); .)
 | "intseq"							(. type = CreateType(t.val, start_loc); .)
 | "void"							(. type = CreateType(t.val, start_loc); .)
 | ident							(. type = CreateType(t.val, start_loc); .)
 )                                  (. start_loc = CurrentLocation; .)
 { "[]"                             (. if(type.IsNull)
                                           SemErr("Array of unknown type is specified. Unknown type is just unknown!");
                
                                       type = new SimpleType("array", new []{type}, start_loc, CurrentLocation);
                                    .)
 }.
/*------------------------------------------------------------------------*/
TupleTypeSignature<out AstType type> (. var inners = new List<AstType>(); var start_loc = CurrentLocation; .)
=
  '('
  { Type<out type>                  (. inners.Add(type); .)
  }
  ')'                               (. type = new SimpleType("tuple", inners, start_loc, CurrentLocation); .).
/*------------------------------------------------------------------------*/
Stmt<out Statement stmt>			(. stmt = null; .)
=
  SimpleStmt<out stmt>
  | CompoundStmt<out stmt> .
/*------------------------------------------------------------------------*/
SimpleStmt<out Statement stmt>		(. stmt = null; BlockStatement block = null; .)
=	IF(la.kind == _lcurly)	/* For DictMaker and Block conflict. Since DictMaker should not be a statement, we always choose the first(Block).*/
    Block<out block>                (. stmt = block; .)
  | ExprStmt<out stmt>
  | ReturnStmt<out stmt>
  | BreakStmt<out stmt>
  | ContinueStmt<out stmt>
  | YieldStmt<out stmt>
  | EmptyStmt<out stmt>.
/*------------------------------------------------------------------------*/
ReturnStmt<out Statement stmt>		(. SequenceExpression items = null; .)
=
  "return"
  [RValueList<out items>]
  SYNC ';'							(. stmt = Statement.MakeReturnStmt(items); .).
/*------------------------------------------------------------------------*/
BreakStmt<out Statement stmt>		(. int count = 1; var start_loc = CurrentLocation; .)
=
  "break"
  [ "upto"
    integer							(. count = Convert.ToInt32(t.val); .)
  ]
  SYNC ';' 							(. stmt = Statement.MakeBreakStmt(
                                            Expression.MakeConstant("int", count, start_loc), start_loc, CurrentLocation
                                       );
                                    .).
/*------------------------------------------------------------------------*/
ContinueStmt<out Statement stmt>	(. int count = 1; var start_loc = CurrentLocation; .)
= 
  "continue"
  [ "upto"
    integer							(. count = Convert.ToInt32(t.val); .)
  ]
  SYNC ';' 							(. stmt = Statement.MakeContinueStmt(
                                            Expression.MakeConstant("int", count, start_loc), start_loc, CurrentLocation
                                       );
                                    .).
/*------------------------------------------------------------------------*/
YieldStmt<out Statement stmt>		(. Expression expr; var start_loc = CurrentLocation; .)
=
  "yield"
  CondExpr<out expr>
  SYNC ';'							(. stmt = Statement.MakeYieldStmt(expr, start_loc, CurrentLocation); .).
/*------------------------------------------------------------------------*/
EmptyStmt<out Statement stmt>       (. var start_loc = CurrentLocation; .)
=
  SYNC ';'							(. stmt = Statement.MakeEmptyStmt(start_loc); .).
/*------------------------------------------------------------------------*/
AugAssignOpe<ref OperatorType type>
=
  ( "+="							(. type = OperatorType.Plus; .)
  | "-="							(. type = OperatorType.Minus; .)
  | "*="							(. type = OperatorType.Times; .)
  | "/="							(. type = OperatorType.Divide; .)
  | "**="							(. type = OperatorType.Power; .)
  | "%="							(. type = OperatorType.Modulus; .)
  | "&="							(. type = OperatorType.BitwiseAnd; .)
  | "|="							(. type = OperatorType.BitwiseOr; .)
  | "<<="							(. type = OperatorType.BitwiseShiftLeft; .)
  | ">>="							(. type = OperatorType.BitwiseShiftRight; .)
  ).
/*------------------------------------------------------------------------*/
ExprStmt<out Statement stmt>			(.  SequenceExpression lhs = null, seq = null;
											var start_loc = CurrentLocation; stmt = null;
											OperatorType op_type = OperatorType.None;
										.)
=
  ( VarDeclStmt<out stmt>
  | LValueList<out lhs>
  { ( AugAssignOpe<ref op_type>
    | '='
    )
    RValueList<out seq>
  }										(.
  											if(lhs.Count != seq.Count)      //See if both sides have the same number of items
                                                SemErr("An augumented assignment must have both sides balanced.");
  													
  											if(op_type != OperatorType.None)
  												stmt = Statement.MakeAugumentedAssignment(lhs, seq, op_type, start_loc, CurrentLocation);
  											else
  												stmt = Statement.MakeAssignment(lhs, seq, start_loc, CurrentLocation);
  										.)
  )
  SYNC ';' 								(.  if(stmt == null)
  												stmt = Statement.MakeExprStmt(lhs, start_loc, CurrentLocation);
  										.).
/*------------------------------------------------------------------------*/
LValueList<out SequenceExpression lhs>   (. var lvalues = new List<Expression>(); Expression tmp; .)
=
  Primary<out tmp>                              (. lvalues.Add(tmp); .)
  { Primary<out tmp>                            (. lvalues.Add(tmp); .)
  }                                             (. lhs = Expression.MakeSequence(lvalues); .).
/*------------------------------------------------------------------------*/
Block<out BlockStatement block>  (. List<Statement> stmts = new List<Statement>(); Statement stmt;
                                    var start_loc = CurrentLocation;
                                 .)
=
  '{'                       (. GoDownScope(); .)
  Stmt<out stmt>			(. stmts.Add(stmt); .)
  { Stmt<out stmt>			(. stmts.Add(stmt); .)
  }
  '}' 						(. block = Statement.MakeBlock(stmts, start_loc, CurrentLocation);
                               GoUpScope();
                            .).
/*------------------------------------------------------------------------*/
CompoundStmt<out Statement stmt>	(. stmt = null; .)
=
  SYNC
    IfStmt<out stmt>					
  | WhileStmt<out stmt>
  | ForStmt<out stmt>
  | MatchStmt<out stmt>
  /*| FuncDecl<out stmt>*/.
/*------------------------------------------------------------------------*/
IfStmt<out Statement stmt>			(. Expression tmp; BlockStatement true_block, false_block = null;
                                       var start_loc = CurrentLocation;
                                    .)
=
  "if" 
  CondExpr<out tmp>
  Block<out true_block>
  [ "else"
    Block<out false_block>
  ]                      			(. stmt = Statement.MakeIfStmt(tmp, true_block, false_block, start_loc); .).
/*------------------------------------------------------------------------*/
WhileStmt<out Statement stmt>		(. Expression cond; BlockStatement body; var start_loc = CurrentLocation; .)
=
  "while"
  CondExpr<out cond>
  Block<out body>                   (. stmt = Statement.MakeWhileStmt(cond, body, start_loc); .).
/*------------------------------------------------------------------------*/
ForStmt<out Statement stmt>			(.  PatternConstruct left; Expression rvalue; BlockStatement body;
                                        var start_loc = CurrentLocation;
									.)
=
  "for"
  LhsPattern<out left>
  "in"
  CondExpr<out rvalue>
  Block<out body>					(. stmt = Statement.MakeForStmt(left, rvalue, body, start_loc); .).
/*------------------------------------------------------------------------*/
MatchStmt<out Statement stmt>		(. Expression target; List<MatchPatternClause> matches;
                                       var start_loc = CurrentLocation;
                                    .)
=
  "match"
  CondExpr<out target>
  '{'
  MatchPatternList<out matches>
  '}'								(. stmt = Statement.MakeMatchStmt(target, matches, start_loc, CurrentLocation); .).
/*------------------------------------------------------------------------*/
MatchPatternList<. out List<MatchPatternClause> clauses .>
                                    (. clauses = new List<MatchPatternClause>(); List<PatternConstruct> pattern_list; Statement inner; .)
=
  PatternList<out pattern_list>
  Stmt<out inner>					(. clauses.Add(Statement.MakeMatchClause(pattern_list, inner)); .)
  { PatternList<out pattern_list>
    Stmt<out inner>					(. clauses.Add(Statement.MakeMatchClause(pattern_list, inner)); .)
  }.
/*------------------------------------------------------------------------*/
PatternList<. out List<PatternConstruct> patterns .>    (. patterns = new List<PatternConstruct>(); PatternConstruct tmp; .)
=
  Pattern<out tmp>								        (. patterns.Add(tmp); .)
  { SYNC '|'
    Pattern<out tmp>								    (. patterns.Add(tmp); .)
  }
  "=>" .
/*------------------------------------------------------------------------*/
VarDeclStmt<out Statement stmt>         (.  string name; AstType type; Expression rhs = null;
								        	Identifier ident;
								          	var idents = new List<Identifier>(); var exprs = new List<Expression>();
                                            bool is_const = false; var start_loc = CurrentLocation;
								        .)
= 
  ( "let"                               (. is_const = true; .)
  | "var"
  )
  VarDef<out name, out type, out rhs>	(.  ident = AstNode.MakeIdentifier(name, type);
                                            idents.Add(ident);
  						 			        exprs.Add(rhs);
  						 			        rhs = null;
                                            Symbols.AddSymbol(name, type);
  						 		        .)
  { WEAK ','
    VarDef<out name, out type, out rhs>(. ident = AstNode.MakeIdentifier(name, type);
                                          idents.Add(ident);
  									      exprs.Add(rhs);
  									      rhs = null;
                                          Symbols.AddSymbol(name, type);
  								       .)
  }								       (. var modifiers = is_const ? ExpressoModifiers.Immutable : ExpressoModifiers.None;
                                          stmt = Statement.MakeVarDecl(idents, exprs, modifiers, start_loc, CurrentLocation);
                                       .).
/*------------------------------------------------------------------------*/
VarDef<out string name, out AstType type, out Expression option> (. type = null; option = null; .)
=
  ident                        (. name = t.val; .)
  [ "(-"
    Type<out type>
  ]                            (. if(type == null)
                                      type = new PlaceholderType(CurrentLocation);
                               .)
  [ '='
    CondExpr<out option>
  ]                            (. if(type == null && option == null)
                                      SemanticError("Give me some context or I can't infer the type of {0}", name);
                               .).
/*------------------------------------------------------------------------*/
FuncDecl<out EntityDeclaration func, Modifiers modifiers>
                                (.  string name; AstType type = null; BlockStatement block = null;
									var @params = new List<ParameterDeclaration>();
                                    var start_loc = CurrentLocation;
								.)
=
  SYNC
  "def"                         (. Symbols.AddScope(); .)
  ident							(. name = t.val; Symbols.AddSymbol(name); .)
  '('
  [ParamList<out @params>]
  ')'
  [ "->"
    Type<out type>
  ]                             (. if(type == null)
                                       type = new PlaceholderType(CurrentLocation);

                                   Symbols.AddSymbol(name, AstType.Null);
                                .)
  Block<out block> 				(. func = EntityDeclaration.MakeFunc(name, @params, block, type, modifiers, start_loc); .).
/*------------------------------------------------------------------------*/
ParamList<. out List<ParameterDeclaration> @params .>	(. @params = new List<ParameterDeclaration>(); ParameterDeclaration expr; .)
=
  Parameter<out expr>							        (. @params.Add(expr); .)
  { WEAK ','
    Parameter<out expr>							        (. @params.Add(expr); .)
  }.
/*------------------------------------------------------------------------*/
Parameter<out ParameterDeclaration param>   (. string name; Expression option = null; AstType type; .)
=
  ident							            (. name = t.val; .)
  "(-"
  Type<out type>                            (. Symbols.Child.AddSymbol(name, type); .)
  [ '='
    Literal<out option>
  ]								            (. param = EntityDeclaration.MakeParameter(name, type, option); .).
/*------------------------------------------------------------------------*/
RValueList<out SequenceExpression seq>		(. Expression tmp; var exprs = new List<Expression>(); .)
=
  CondExpr<out tmp>							(. exprs.Add(tmp); .)
  { WEAK ','
    CondExpr<out tmp>						(. exprs.Add(tmp);	.)
  }											(. seq = Expression.MakeSequence(exprs); .).
/*------------------------------------------------------------------------*/
Pattern<out PatternConstruct pattern>
=
  IF(IsDefiningLValue())
  LhsPattern<out pattern>
  | ExpressionPattern<out pattern>.
/*------------------------------------------------------------------------*/
ExpressionPattern<out PatternConstruct expr_pattern>    (. Expression expr; .)
=
  CondExpr<out expr>                                    (. expr_pattern = PatternConstruct.MakeExpressionPattern(expr); .).
/*------------------------------------------------------------------------*/
LhsPattern<out PatternConstruct pattern>    (. pattern = PatternConstruct.Null; .)
=
  WildcardPattern<out pattern>
  | IdentifierPattern<out pattern>
  | ValueBindingPattern<out pattern>.
/*------------------------------------------------------------------------*/
WildcardPattern<out PatternConstruct pattern>
=
  '_'                               (. pattern = PatternConstruct.MakeWildcardPattern(); .).
/*------------------------------------------------------------------------*/
IdentifierPattern<out PatternConstruct pattern> (. AstType type; .)
=
  ident
  [ "(-"
    Type<out type>
  ]                                 (. pattern = PatternConstruct.MakeIdentifierPattern(t.val, type); .).
/*------------------------------------------------------------------------*/
ValueBindingPattern<out PatternConstruct pattern>   (. PatternConstruct inner; .)
=
  ( "let"
  | "var"
  )
  Pattern<out inner>                (. pattern = PatternConstruct.MakeValueBindingPattern(inner); .).
/*------------------------------------------------------------------------*/
CondExpr<out Expression expr>		(. Expression true_expr, false_expr; .)
=
  OrTest<out expr>
  [ '?'
    OrTest<out true_expr>
    ':'
    CondExpr<out false_expr>		(. expr = Expression.MakeCondExpr(expr, true_expr, false_expr); .)
  ].
/*------------------------------------------------------------------------*/
OrTest<out Expression expr>			(. Expression rhs; .)
=
  AndTest<out expr>
  [ "||"
    AndTest<out rhs>                (. expr = Expression.MakeBinaryExpr(OperatorType.ConditionalOr, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
AndTest<out Expression expr>		(. Expression rhs; .)
=
  Comparison<out expr>
  [ "&&"
    Comparison<out rhs>				(. expr = Expression.MakeBinaryExpr(OperatorType.ConditionalAnd, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
Comparison<out Expression expr>	    (. Expression rhs; OperatorType type; .)
=
  IntSeqExpr<out expr>				(. type = OperatorType.Equality; .)
  [ ComparisonOperator<out type>
    IntSeqExpr<out rhs>			    (. expr = Expression.MakeBinaryExpr(type, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
ComparisonOperator<out OperatorType opType> (. opType = OperatorType.None; .)
=
  ( "=="                    (. opType = OperatorType.Equality; .)
  | "!="                    (. opType = OperatorType.InEquality; .)
  | '<'                     (. opType = OperatorType.LessThan; .)
  | '>'                     (. opType = OperatorType.GreaterThan; .)
  | "<="                    (. opType = OperatorType.LessThanOrEqual; .)
  | ">="                    (. opType = OperatorType.GreaterThanOrEqual; .)
  ).
/*------------------------------------------------------------------------*/
IntSeqExpr<out Expression expr>     (. Expression start = null, end = null, step = null;
                                       bool upper_inclusive = true;
                                    .)
=
  BitOr<out start>
  [ RangeOperator<out upper_inclusive>
    BitOr<out end>
    [ ':'
      BitOr<out step>
    ]
  ]                                 (. if(step == null) step = Expression.MakeConstant("int", 1);
                                       expr = Expression.MakeIntSeq(start, end, step, upper_inclusive);
                                    .).
/*------------------------------------------------------------------------*/
RangeOperator<out bool upper_inclusive> (. upper_inclusive = false; .)
=
  ( ".."
  | "..."                               (. upper_inclusive = true; .)
  ).
/*------------------------------------------------------------------------*/
BitOr<out Expression expr>			(. Expression rhs; .)
=
  BitXor<out expr>
  [ '|'
    BitXor<out rhs>					(. expr = Expression.MakeBinaryExpr(OperatorType.BitwiseOr, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
BitXor<out Expression expr>			(. Expression rhs; .)
=
  BitAnd<out expr>
  [ '^'
    BitAnd<out rhs>					(. expr = Expression.MakeBinaryExpr(OperatorType.ExclusiveOr, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
BitAnd<out Expression expr>			(. Expression rhs; .)
=
  ShiftOp<out expr>
  [ '&'
    ShiftOp<out rhs>			    (. expr = Expression.MakeBinaryExpr(OperatorType.BitwiseAnd, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
ShiftOp<out Expression expr>		(. Expression rhs; OperatorType type; .)
=
  AddOp<out expr>
  [ ShiftOperator<out type>
    AddOp<out rhs>				    (. expr = Expression.MakeBinaryExpr(type, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
ShiftOperator<out OperatorType opType>  (. opType = OperatorType.None; .)
=
  ( "<<"                            (. opType = OperatorType.BitwiseShiftLeft; .)
  | ">>"                            (. opType = OperatorType.BitwiseShiftRight; .)
  ).
/*------------------------------------------------------------------------*/
AddOp<out Expression expr>    		(. Expression rhs; OperatorType type; .)
= 
  Term<out expr>
  [ AdditiveOperator<out type>
    Term<out rhs>					(. expr = Expression.MakeBinaryExpr(type, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
AdditiveOperator<out OperatorType opType>   (. opType = OperatorType.None; .)
=
  ( '+'                             (. opType = OperatorType.Plus; .)
  | '-'                             (. opType = OperatorType.Minus; .)
  ).
/*------------------------------------------------------------------------*/
Term<out Expression expr>       (. Expression rhs; OperatorType type; .)
= 
  PowerOp<out expr>
  [ MultiplicativeOperator<out type>
    PowerOp<out rhs>		    (. expr = Expression.MakeBinaryExpr(type, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
MultiplicativeOperator<out OperatorType opType>
                            (. opType = OperatorType.None; .)
=
  ( '*'                     (. opType = OperatorType.Times; .)
  | '/'                     (. opType = OperatorType.Divide; .)
  | '%'                     (. opType = OperatorType.Modulus; .)
  ).
/*------------------------------------------------------------------------*/
PowerOp<out Expression expr>   (. Expression rhs; .)
= 
  Factor<out expr>
  [ "**"
    Factor<out rhs>            (. expr = Expression.MakeBinaryExpr(OperatorType.Power, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
Factor<out Expression expr> (. OperatorType type; Expression factor; expr = null; .)
=
  Primary<out expr>
  |
  UnaryOperator<out type>
  Factor<out factor>        (. expr = Expression.MakeUnaryExpr(type, factor); .).
/*------------------------------------------------------------------------*/
UnaryOperator<out OperatorType opType>  (. opType = OperatorType.None; .)
=
  ( AdditiveOperator<out opType>
  | '!'                             (. opType = OperatorType.Not; .)
  | '&'                             (. opType = OperatorType.Reference; .)
  | '*'                             (. opType = OperatorType.Dereference; .)
  ).
/*------------------------------------------------------------------------*/
Primary<out Expression expr>		(. expr = null; PathExpression path; .)
=
  ( PathExpression<out path>        (. expr = path; .) /* It's possible that a PathExpression turns out to be just an Identifier */
    [ObjectCreation<path, out expr>]
  | Atom<out expr>
  | NewExpression<out expr>
  )
  { Trailer<ref expr>
  }.
/*------------------------------------------------------------------------*/
NewExpression<out Expression expr>      (. PathExpression path; .)
=
  "new"
  PathExpression<out path>
  ObjectCreation<path, out expr>        (. expr = Expression.MakeNewExpr((ObjectCreationExpression)expr); .).
/*------------------------------------------------------------------------*/
ObjectCreation<PathExpression path, out Expression expr>
                                        (. var fields = new List<Identifier>(); var values = new List<Expression>();
                                        .)
=
  '{'
  { ident                               (. fields.Add(AstNode.MakeIdentifier(t.val)); .)
    ':'
    OrTest<out expr>                    (. values.Add(expr); .)
  }
  '}'                                   (. expr = Expression.MakeObjectCreation(path, fields, values); .).
/*------------------------------------------------------------------------*/
Trailer<ref Expression expr>	(. List<Expression> args; .)
=
  '('
  [ArgList<out args>]
  ')'							(. expr = Expression.MakeCallExpr(expr, args); .)
  | '['
    ArgList<out args>
    ']'							(. expr = Expression.MakeIndexer(expr, args); .)
  | '.'
    ident						(. expr = Expression.MakeMemRef(expr, AstNode.MakeIdentifier(t.val)); .).
/*------------------------------------------------------------------------*/
ArgList<. out List<Expression> args .>		(. args = new List<Expression>(); Expression expr; .)
=
  CondExpr<out expr>						(. args.Add(expr); .)
  { WEAK ','
    CondExpr<out expr>						(. args.Add(expr); .)
  }.
/*------------------------------------------------------------------------*/
Atom<out Expression expr>			(. string name; var exprs = new List<Expression>(); expr = null; .)
=
  Literal<out expr>
  | '('
    CondExpr<out expr>              (. exprs.Add(expr); .)
    { IF(NotFinalComma()) WEAK ','
      CondExpr<out expr>            (. exprs.Add(expr); .)
    }
    [',']
    ')'                             (. if(exprs.Count == 1)
                                           expr = Expression.MakeParen(exprs[0]);
                                       else
                                           expr = Expression.MakeParen(Expression.MakeSequence(exprs));
                                    .)
  | '['
    [SequenceMaker<out expr>]
    SYNC ']'						(.  if(expr == null)
    										expr = Expression.MakeSeqInitializer("array", new List<Expression>());
    								.)
  | '{'
    [DictMaker<out expr>]
    SYNC '}'                        (. if(expr == null)
                                           expr = Expression.MakeSeqInitializer("dictionary", null);
                                    .).
/*------------------------------------------------------------------------*/
PathExpression<out PathExpression path> (. var paths = new List<Identifier>(); .)
=
  ["::"]
  ident                                 (. paths.Add(AstNode.MakeIdentifier(t.val)); .)
  { "::"
    ident                               (. paths.Add(AstNode.MakeIdentifier(t.val)); .)
  }                                     (. path = Expression.MakePath(paths); .).
/*------------------------------------------------------------------------*/
SequenceMaker<out Expression expr>	(.  var exprs = new List<Expression>();
										expr = null; ComprehensionIter comp = null;
                                        string seq_type_name = "array";
									.)
=
  CondExpr<out expr>                    (. exprs.Add(expr); .)
  ( { IF(NotFinalComma()) WEAK ','
      CondExpr<out expr>                (. exprs.Add(expr); .)
    }
    [ ','
      "..."                             (. seq_type_name = "vector"; .)
    ]
  )                                     (. expr = Expression.MakeSeqInitializer(seq_type_name, exprs); .)
  | CompFor<out comp>                   (. expr = Expression.MakeComp(expr, (ComprehensionForClause)comp, type); .).
/*------------------------------------------------------------------------*/
DictMaker<out Expression expr>			(. Expression key, val; var list = new List<KeyValueLikeExpression>();
                                           KeyValueLikeExpression pair; ComprehensionIter comp;
                                        .)
=
  CondExpr<out key>
  ':'
  CondExpr<out val>                     (. pair = Expression.MakeKeyValuePair(key, val);
                                           list.Add(pair);
                                        .)
  ( { WEAK ','
      CondExpr<out key>
      ':'
      CondExpr<out val>                 (. pair = Expression.MakeKeyValuePair(key, val);
                                           list.Add(pair);
                                        .)
    }
  )                                     (. expr = Expression.MakeSeqInitializer("dictionary", list); .)
  | CompFor<out comp>                   (. comp = Expression.MakeComp(pair, (ComprehensionForClause)comp);
                                           expr = Expression.MakeSeqInitializer("dictionary", comp);
                                        .).
/*------------------------------------------------------------------------*/
CompIter<out ComprehensionIter expr>    (. expr = null; .)
=
  CompFor<out expr>
  | CompIf<out expr> .
/*------------------------------------------------------------------------*/
CompFor<out ComprehensionIter expr>		(. Expression rvalue = null; ComprehensionIter body = null; PatternConstruct target; .)
=
  "for"
  LhsPattern<out target>
  "in"
  CondExpr<out rvalue>
  [CompIter<out body>]					(. expr = Expression.MakeCompFor(target, rvalue, body); .).
/*------------------------------------------------------------------------*/
CompIf<out ComprehensionIter expr>		(. Expression tmp; ComprehensionIter body = null; .)
=
  "if"
  OrTest<out tmp>
  [CompIter<out body>]					(. expr = Expression.MakeCompIf(tmp, body); .).
/*------------------------------------------------------------------------*/
Literal<out Expression expr>	(. expr = null; string tmp; bool has_suffix = false;
                                   var start_loc = CurrentLocation;
                                .)
= 
  integer						(. tmp = t.val; .)
  [ 'l'							(. has_suffix = true; .)
  | 'L'							(. has_suffix = true; .)
  ]								(.  if(has_suffix)
  										expr = Expression.MakeConstant("bigint", BigInteger.Parse(tmp), start_loc);
  									else
  										expr = Expression.MakeConstant("int", Convert.ToInt32(tmp), start_loc);
  								.)
  | hex_digit					(. expr = Expression.MakeConstant("int", Convert.ToInt32(t.val, 16), start_loc); .)
  | float						(. expr = Expression.MakeConstant("double", Convert.ToDouble(t.val), start_loc); .)
  | string_literal				(. tmp = t.val;
  								   tmp = tmp.Substring(1, tmp.Length - 2);
  								   expr = Expression.MakeConstant("string", tmp, start_loc);
  								.)
  | "true"                      (. expr = Expression.MakeConstant("bool", true, start_loc); .)		
  | "false"                     (. expr = Expression.MakeConstant("bool", false, start_loc); .)
  | "self"                      (. expr = Expression.MakeSelfRef(start_loc); .)
  | "super"                     (. expr = Expression.MakeSuperRef(start_loc); .).
/*------------------------------------------------------------------------*/
END Expresso.
