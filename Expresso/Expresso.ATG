using System.Collections.Generic;
using System.Linq;
using System.Numerics;
using System.Text;

using Expresso.Ast;
using Expresso.Builtins;
using Expresso.Compiler.Meta;
using Expresso.Interpreter;
using Expresso.Runtime;
using Expresso.Utils;



COMPILER Expresso
	internal ScopeStatement cur_scope = null;		//the current scope of variables
	static List<BreakableStatement> breakables = new List<BreakableStatement>();	//the current parent breakables hierarchy
	public string ParsingFileName{get; set;}
	public ExpressoAst TopmostAst{get; private set;}	//the top-level AST the parser is parsing
	
	///<summary>
	/// Parser Implementation details:
	/// 	During parsing we'll resolve break and continue statements.(Find which a break or continue statement would have its effect
	/// 	on which a loop statement) And in post-parse process, do flow analysis and type validity check, including local name bindings.
	///		Note that the identifiers are just placeholders until after doing name binding. 
	/// 	(Thus referecing them cause runtime exceptions)
	///</summary>
	Parser()
	{
		//Add built-in functions
		/*FunctionDefinition[] native_funcs = {
			new NativeLambdaUnary("abs", ImplementationHelpers.MakeArg(new Identifier("val", new TypeAnnotation(ObjectTypes.VAR), null, 0)), ExpressoFunctions.Abs),
			new NativeLambdaUnary("sqrt", ImplementationHelpers.MakeArg(new Identifier("val", new TypeAnnotation(ObjectTypes.VAR), null, 0)), ExpressoFunctions.Sqrt),
			new NativeLambdaUnary("toInt", ImplementationHelpers.MakeArg(new Identifier("val", new TypeAnnotation(ObjectTypes.VAR), null, 0)), ExpressoFunctions.ToInt)
		};
		foreach(var tmp in native_funcs)
			cur_scope.AddFunction(tmp);*/
	}
	
	Constant CreateConstant(ObjectTypes type)
	{
		Constant result = null;
		
		switch(type){
		case ObjectTypes.INTEGER:
			result = Node.MakeConstant(type, 0);
			break;
			
		case ObjectTypes.BOOL:
			result = Node.MakeConstant(type, false);
			break;
			
		case ObjectTypes.FLOAT:
			result = Node.MakeConstant(type, 0.0);
			break;
			
		case ObjectTypes.STRING:
			result = Node.MakeConstant(type, "");
			break;
			
		default:
			SemErr("Unknown object type");
			break;
		}
		
		return result;
	}
	
	bool NotFollowedByDoubleDots()
	{
		Token x = la;
		scanner.ResetPeek();
		if(x.kind != _lbracket) return true;
		while(x.kind != 0 && x.kind != _double_dots && x.kind != _rbracket && x.kind != _semicolon && x.kind != _rparen && x.kind != _keyword_in)
			x = scanner.Peek();
		
		return x.kind != _double_dots;
	}
	
	bool IsSequenceInitializer()
	{
		Token x = la;
		if(x.kind != _lcurly) return true;
		scanner.ResetPeek();
		while(x.kind != 0 && x.kind != _keyword_for && x.kind != _rcurly) x = scanner.Peek();
		return x.kind != _keyword_for;
	}
	
	static BreakStatement MakeBreakStatement(int count)
	{
		var tmp = new List<BreakableStatement>();
		for(int len = Parser.breakables.Count, i = 0, j = count; j > 0; ++i){
			var enclosing = Parser.breakables[len - 1 - i];
			tmp.Add(enclosing);
			if(enclosing.Type == NodeType.WhileStatement || enclosing.Type == NodeType.ForStatement) --j;
		}
		return Node.MakeBreakStmt(count, tmp);
	}
	
	static ContinueStatement MakeContinueStatement(int count)
	{
		var tmp = new List<BreakableStatement>();
		for(int len = Parser.breakables.Count, i = 0, j = count; j > 0; ++i){
			var enclosing = Parser.breakables[len - 1 - i];
			if(enclosing.Type != NodeType.WhileStatement && enclosing.Type != NodeType.ForStatement
				|| j != 1)			//don't include the loop on which we'll continue
				tmp.Add(enclosing);
			
			if(enclosing.Type == NodeType.WhileStatement || enclosing.Type == NodeType.ForStatement)
				--j;
		}
		return Node.MakeContinueStmt(count, tmp);
	}
	
	Statement MakeDefaultCtor(string className)
	{
		var arg_this = Node.MakeArg("this", new TypeAnnotation(ObjectTypes.INSTANCE, className));
		var @params = new List<Argument>{arg_this};
		var ctor = Node.MakeFunc("constructor", @params, new Block(), TypeAnnotation.VoidType.Clone(), Flags.PublicAccess);
		return ctor;
	}
	
	public void SemanticError(string format, params object[] args)
	{
		//Convenient method for printing a semantic error with a format string
		SemErr(string.Format(format, args));
	}
	
/*--------------------------------------------------------------------------*/
CHARACTERS
  letter = 'A'..'Z' + 'a'..'z'.
  digit = '0'..'9'.
  hex_letter = digit + 'a'..'f' + 'A'..'F'.
  cr  = '\r'.
  lf  = '\n'.
  tab = '\t'.
  quotedLetter = ANY - '"' - '\''.
  dot = '.'.

TOKENS
  double_dots = "..".
  rbracket = ']'.
  colon = ':'.
  semicolon = ';'.
  lcurly = '{'.
  lparen = '('.
  lbracket = '['.
  rparen = ')'.
  rcurly = '}'.
  comma = ','.
  dot = '.'.
  ident  = (letter | '_') {'_' | letter | digit}.
  integer = digit {digit}
  			| digit {digit} CONTEXT("..").
  float = digit {digit} dot {digit} [('e' | 'E') ['+' | '-'] digit {digit}]
  		  | [digit {digit}] dot digit {digit} [('e' | 'E') ['+' | '-'] digit {digit}].
  hex_digit = '0' ('x' | 'X') hex_letter {hex_letter}.
  string_literal = '"' {quotedLetter} '"'.
  keyword_in = "in".
  keyword_for = "for".

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO lf

IGNORE cr + lf + tab



PRODUCTIONS
/*------------------------------------------------------------------------*/
Expresso                    		(. ExpressoAst module_decl = null; .)
= 
  ModuleBody<out module_decl>		(.  ExpressoNameBinder.BindAst(module_decl, this); //Here's the start of post-parse processing
  										this.TopmostAst = module_decl;	//Currently there is not so much code out there, though...
  									.).
/*------------------------------------------------------------------------*/
ModuleBody<out ExpressoAst decl>	(.  var decls = new List<Statement>(); var export_map = new List<bool>(); bool has_main = false;
										bool has_export = false; List<Statement> prog_defs = null; Statement stmt = null;
									.)
=
  [ ProgramDefinition<out prog_defs> (. if(prog_defs !=null) decls.AddRange(prog_defs); .)
  ]
  								
  [ "export"						(. has_export = true; .)
  ]
  ( ExprStmt<out stmt>
  | FuncDecl<out stmt>
  | ClassDecl<out stmt>
  )									(.  if(stmt is FunctionDefinition && ((FunctionDefinition)stmt).Name == "main")
  											has_main = true;
  										
  										decls.Add(stmt);
										export_map.Add(has_export);
										has_export = false;
									.)
  {
    [ "export"						(. has_export = true; .)
    ]
    ( ExprStmt<out stmt>
    | FuncDecl<out stmt>
    | ClassDecl<out stmt>
    )								(.  if(stmt is FunctionDefinition && ((FunctionDefinition)stmt).Name == "main")
    										has_main = true;
    									
    									decls.Add(stmt);
    									export_map.Add(has_export);
    									has_export = false;
    								.)
  }									(.  var module_name = has_main ? "main" : ParsingFileName;
  										decl = Node.MakeModuleDef(module_name, decls, export_map);
  									.) .
/*------------------------------------------------------------------------*/
ProgramDefinition<. out List<Statement> requires .>		(. requires = new List<Statement>(); Statement tmp; .)
=
  RequireStmt<out tmp>			(. requires.Add(tmp); .)
  { RequireStmt<out tmp>		(. requires.Add(tmp); .)
  }.
/*------------------------------------------------------------------------*/
RequireStmt<out Statement stmt>	(.  string module_name, alias = null; var module_names = new List<string>();
									var aliases = new List<string>();
								.)
=
  SYNC
  "require"
  ModuleName<out module_name>
  [ "as"
    ident						(. alias = t.val; .)
  ]								(.  module_names.Add(module_name);
  									aliases.Add(alias);
  								.)
  { ','
    ModuleName<out module_name>
    [ "as"
      ident						(. alias = t.val; .)
    ]							(.  module_names.Add(module_name);
  									aliases.Add(alias);
  								.)
  }
  SYNC ';' 						(. stmt = Node.MakeRequireStmt(module_names, aliases); .).
/*------------------------------------------------------------------------*/
ModuleName<out string name>		(. var sb = new StringBuilder(); .)
=
  ident							(. sb.Append(t.val); .)
  { '.'							(. sb.Append('.'); .)
    ident						(. sb.Append(t.val); .)
  }								(. name = sb.ToString(); .).
/*------------------------------------------------------------------------*/
ClassDecl<out Statement stmt>		(.  Expression expr = null; var stmts = new List<Statement>(); List<Expression> decls = null;
										string name; var base_names = new List<Identifier>(); Statement tmp = null; bool has_ctor = false;
                                        Expresso.Ast.Flags cur_flag = Flags.PrivateAccess;
									.)
=
  SYNC
  "class"
  ident				    				(. name = t.val; .)
  [ ':'
    ident		    					(. base_names.Add(Node.MakeIdentifier(t.val)); .)
    { ','
      ident							    (. base_names.Add(Node.MakeIdentifier(t.val)); .)
    }
  ]
  '{'
  {
    ( "public"						    (. cur_flag = Flags.PrivateAccess; .)
    | "protected"					    (. cur_flag = Flags.ProtectedAccess; .)
    | "private"					    	(. cur_flag = Flags.PublicAccess; .)
    )
    ':'								    (.  tmp = Node.MakeExprStmt(new List<Expression>{expr});
    									    stmts.Add(tmp);
    								    .)
  | ConstructorDecl<out tmp, name, cur_flag>
                                        (.  stmts.Add(tmp);
  										    has_ctor = true;
  									    .)
  | MethodDecl<out tmp, name, cur_flag>	(. stmts.Add(tmp); .)
  | FieldDecl<out decls, cur_flag>			
    ';'								    (.  tmp = Node.MakeExprStmt(decls);
  										    stmts.Add(tmp);
  									    .)
  | ClassDecl<out tmp>				    (. stmts.Add(tmp); .)
  }
  SYNC '}'							    (.  if(!has_ctor){		//Define the default constructor
  										    	stmts.Add(MakeDefaultCtor(name));
  									    	}
  										    stmt = Node.MakeClassDef(name, base_names, stmts);
  									    .) .
/*------------------------------------------------------------------------*/
ConstructorDecl<out Statement func, string className, Expresso.Ast.Flags flag>
                                (.  Statement block = null; var @params = new List<Argument>();
									Argument arg_this = null;
								.)
=
  SYNC
  "constructor"					(.  arg_this = Node.MakeArg("this", new TypeAnnotation(ObjectTypes.INSTANCE, className));
  									@params.Add(arg_this);
  								.)
  '('
  [ParamList<ref @params>]
  ')'
  Block<out block> 				(. func = Node.MakeFunc("constructor", @params, (Block)block, TypeAnnotation.VoidType.Clone(), flag);
  								.).
/*------------------------------------------------------------------------*/
MethodDecl<out Statement func, string className, Expresso.Ast.Flags flag>
                                (.
									string name; var type = TypeAnnotation.InferenceType.Clone(); Statement block = null;
									var @params = new List<Argument>(); Argument arg_this = null;
								.)
=
  SYNC
  "def"							(.  arg_this = Node.MakeArg("this", new TypeAnnotation(ObjectTypes.INSTANCE, className));
  									@params.Add(arg_this);
  								.)
  ident							(. name = t.val; .)
  '('
  [ParamList<ref @params>]
  ')'
  [ "->"
    Type<out type>
  ]
  Block<out block> 				(.  func = Node.MakeFunc(name, @params, (Block)block, type, flag); .).
/*------------------------------------------------------------------------*/
FieldDecl<. out List<Expression> outs, Expresso.Ast.Flags flag .>
  (. string name; TypeAnnotation type = TypeAnnotation.InferenceType.Clone(); Expression rhs = null;
	 Identifier variable; outs = new List<Expression>();
	 var vars = new List<Identifier>(); var exprs = new List<Expression>();
  .)
= 
  ident							(. name = t.val; .)
  [ "(-"
    Type<out type>
  ]
  [ '='
    ( IF(NotFollowedByDoubleDots())
      CondExpr<out rhs>
    | IntSeqExpr<out rhs>
    )
  ]
  { ','					 		(.  variable = Node.MakeField(name, type);
 						 			vars.Add(variable);
                                    if(rhs == null)
                                        rhs = Node.MakeDefaultExpr(type);
                                    
  						 			exprs.Add(rhs);
                                    rhs = null;
  						 		.)
    ident						(. name = t.val; .)
  	[ "(-"
   	  Type<out type>
  	]
  	[ '='
  	  ( IF(NotFollowedByDoubleDots())
	    CondExpr<out rhs>
	  | IntSeqExpr<out rhs>
	  )
  	]
  }								(.  variable = Node.MakeField(name, type);
  					   	   			vars.Add(variable);
                                    if(rhs == null)
                                        rhs = Node.MakeDefaultExpr(type);
                                    
  					   	   			exprs.Add(rhs);
  					   
  					   	   			outs.Add(Node.MakeVarDecl(vars, exprs, flag));
  								.).
/*------------------------------------------------------------------------*/
Type<out TypeAnnotation type>		(. type = TypeAnnotation.InferenceType.Clone(); .)
=
 ( "int"                			(. type.ObjType = ObjectTypes.INTEGER; .)
 | "bool"               			(. type.ObjType = ObjectTypes.BOOL; .)
 | "float"							(. type.ObjType = ObjectTypes.FLOAT; .)
 | "rational"						(. type.ObjType = ObjectTypes.RATIONAL; .)
 | "bigint"							(. type.ObjType = ObjectTypes.BIGINT; .)
 | "string"							(. type.ObjType = ObjectTypes.STRING; .)
 | "bytearray"						(. type.ObjType = ObjectTypes.BYTEARRAY; .)
 | "var"							(. type.ObjType = ObjectTypes.VAR; .)
 | "tuple"							(. type.ObjType = ObjectTypes.TUPLE; .)
 | "list"							(. type.ObjType = ObjectTypes.LIST; .)
 | "dictionary"						(. type.ObjType = ObjectTypes.DICT; .)
 | "expression"						(. type.ObjType = ObjectTypes.EXPRESSION; .)
 | "function"						(. type.ObjType = ObjectTypes.FUNCTION; .)
 | "intseq"							(. type.ObjType = ObjectTypes.SEQ; .)
 | "void"							(. type.ObjType = ObjectTypes.UNDEF; .)
 | ident							(. type.ObjType = ObjectTypes.INSTANCE; type.TypeName = t.val; .)
 ).
/*------------------------------------------------------------------------*/
Stmt<out Statement stmt>			(. stmt = null; .)
=
  SimpleStmt<out stmt>
  | CompoundStmt<out stmt> .
/*------------------------------------------------------------------------*/
SimpleStmt<out Statement stmt>		(. stmt = null; .)
=	IF(la.kind == _lcurly)	/* For DictMaker and Block conflict. Since DictMaker should not be a statement, we always choose the first(Block).*/
    Block<out stmt>
  | ExprStmt<out stmt>
  | PrintStmt<out stmt>
  | ReturnStmt<out stmt>
  | BreakStmt<out stmt>
  | ContinueStmt<out stmt>
  | ThrowStmt<out stmt>
  | YieldStmt<out stmt>
  | EmptyStmt<out stmt>.
/*------------------------------------------------------------------------*/
PrintStmt<out Statement stmt>		(. SequenceExpression exprs = null; bool trailing_comma = false; .)
=
  "print"
  [RValueList<out exprs>]
  [',']								(. trailing_comma = true; .)
  SYNC ';'							(. stmt = Node.MakePrintStmt(exprs, trailing_comma); .).
/*------------------------------------------------------------------------*/
ReturnStmt<out Statement stmt>		(. SequenceExpression items = null; .)
=
  "return"
  [RValueList<out items>]
  SYNC ';'							(. stmt = Node.MakeReturnStmt(items); .).
/*------------------------------------------------------------------------*/
BreakStmt<out Statement stmt>		(. int count = 1; .)
=
  "break"
  [ "upto"
    integer							(. count = Convert.ToInt32(t.val); .)
  ]
  SYNC ';' 							(. stmt = MakeBreakStatement(count); .).
/*------------------------------------------------------------------------*/
ContinueStmt<out Statement stmt>	(. int count = 1; .)
= 
  "continue"
  [ "upto"
    integer							(. count = Convert.ToInt32(t.val); .)
  ]
  SYNC ';' 							(. stmt = MakeContinueStatement(count); .).
/*------------------------------------------------------------------------*/
ThrowStmt<out Statement stmt>		(. Expression expr; .)
=
  "throw"
  CondExpr<out expr>
  SYNC ';'							(. stmt = Node.MakeThrowStmt(expr); .).
/*------------------------------------------------------------------------*/
YieldStmt<out Statement stmt>		(. Expression expr; .)
=
  "yield"
  CondExpr<out expr>
  SYNC ';'							(. stmt = Node.MakeYieldStmt(expr); .).
/*------------------------------------------------------------------------*/
EmptyStmt<out Statement stmt>
=
  ';'								(. stmt = Node.MakeEmptyStmt(); .).
/*------------------------------------------------------------------------*/
AugAssignOpe<ref OperatorType type>
=
  ( "+="							(. type = OperatorType.PLUS; .)
  | "-="							(. type = OperatorType.MINUS; .)
  | "*="							(. type = OperatorType.TIMES; .)
  | "/="							(. type = OperatorType.DIV; .)
  | "**="							(. type = OperatorType.POWER; .)
  | "%="							(. type = OperatorType.MOD; .)
  | "&="							(. type = OperatorType.BIT_AND; .)
  | "|="							(. type = OperatorType.BIT_OR; .)
  | "<<="							(. type = OperatorType.BIT_LSHIFT; .)
  | ">>="							(. type = OperatorType.BIT_RSHIFT; .)
  ).
/*------------------------------------------------------------------------*/
ExprStmt<out Statement stmt>				(.  List<Expression> lvalues = null; var targets = new List<SequenceExpression>();
												SequenceExpression seq = null;
												stmt = null; OperatorType op_type = OperatorType.NONE;
											.)
=
  ( VarDecl<out lvalues>
  |
  LValueList<out seq>						(. targets.Add(seq); .)
  { ( AugAssignOpe<ref op_type>
    | '='
    )
    RValueList<out seq>						(. targets.Add(seq); .)
  }											(.
  												seq = targets[targets.Count - 1];
  												targets.RemoveAt(targets.Count - 1);
  												if(op_type != OperatorType.NONE && targets.Count != 1)
  													SemErr("An augumented assignment can't have multiple left-hand-side.");
  												if(op_type != OperatorType.NONE &&		//See if it is an augumented assignment and
  													targets[0].Count != seq.Count)		//both sides have the same number of items
  													SemErr("An augumented assignment must have both sides balanced.");
  													
  												if(op_type != OperatorType.NONE)
  													stmt = Node.MakeAugumentedAssignment(targets[0], seq, op_type);
  												else
  													stmt = Node.MakeAssignment(targets.Cast<Expression>(), seq);
  											.)
  )
  SYNC ';' 									(.  if(stmt == null)
  													stmt = Node.MakeExprStmt(lvalues);
  											.).
/*------------------------------------------------------------------------*/
Block<out Statement block>			(. Block tmp; Statement stmt; .)
=
  '{'								(.  tmp = new Block();
  										Parser.breakables.Add(tmp);
  									.)
  Stmt<out stmt>					(. tmp.Statements.Add(stmt); .)
  { Stmt<out stmt>					(. tmp.Statements.Add(stmt); .)
  }
  '}' 								(.  block = tmp;
  										Parser.breakables.RemoveLast();
  									.).
/*------------------------------------------------------------------------*/
CompoundStmt<out Statement stmt>	(. stmt = null; .)
=
  SYNC
    IfStmt<out stmt>					
  | WhileStmt<out stmt>
  | ForStmt<out stmt>
  | SwitchStmt<out stmt>
  | FuncDecl<out stmt>
  | WithStmt<out stmt>
  | TryStmt<out stmt>.
/*------------------------------------------------------------------------*/
IfStmt<out Statement stmt>			(. Expression tmp; Statement true_block, false_block = null; .)
=
  "if" 
  '(' CondExpr<out tmp> ')'
  Stmt<out true_block>
  [ "else"
    Stmt<out false_block>
  ]                      			(. stmt = Node.MakeIfStmt(tmp, true_block, false_block); .).
/*------------------------------------------------------------------------*/
WhileStmt<out Statement stmt>		(. Expression cond; Statement body = null; WhileStatement tmp; .)
=
  "while"							(.  tmp = Node.MakeWhileStmt();
  										Parser.breakables.Add(tmp);
  									.)
  '(' CondExpr<out cond> ')'
  Stmt<out body>                   	(.  tmp.Condition = cond;
  										tmp.Body = body;
  										Parser.breakables.RemoveLast();
  										stmt = tmp;
  									.).
/*------------------------------------------------------------------------*/
ForStmt<out Statement stmt>				(.  SequenceExpression left = null; Expression rvalue = null; Statement body;
											ForStatement tmp; bool has_let = false;
										.)
=
  "for"									(.  tmp = Node.MakeForStmt();
	  										Parser.breakables.Add(tmp);
	  									.)
  '('
  ( LValueListWithLet<out left>			(. if(left != null) has_let = true; .)
  | LValueList<out left>
  )
  "in"
  ( IF(NotFollowedByDoubleDots())
    CondExpr<out rvalue>
  | IntSeqExpr<out rvalue>
  )
  ')'
  Stmt<out body>						(.  tmp.Left = left;
	  										tmp.Target = rvalue;
	  										tmp.Body = body;
	  										tmp.HasLet = has_let;
	  										Parser.breakables.RemoveLast();
	  										stmt = tmp;
	  									.).
/*------------------------------------------------------------------------*/
SwitchStmt<out Statement stmt>		(. Expression target; List<CaseClause> cases; .)
=
  "switch"
  '('
  CondExpr<out target>
  ')'
  '{'
  CaseClauseList<out cases>
  '}'								(. stmt = Node.MakeSwitchStmt(target, cases); .).
/*------------------------------------------------------------------------*/
CaseClauseList<. out List<CaseClause> clauses .>	(. clauses = new List<CaseClause>(); List<Expression> label_list; Statement inner; .)
=
  CaseLabelList<out label_list>
  Stmt<out inner>									(. clauses.Add(Node.MakeCaseClause(label_list, inner)); .)
  { CaseLabelList<out label_list>
    Stmt<out inner>									(. clauses.Add(Node.MakeCaseClause(label_list, inner)); .)
  }.
/*------------------------------------------------------------------------*/
CaseLabelList<. out List<Expression> label_list .>	(. label_list = new List<Expression>(); Expression tmp; .)
=
  CaseLabel<out tmp>								(. label_list.Add(tmp); .)
  { CaseLabel<out tmp>								(. label_list.Add(tmp); .)
  }.
/*------------------------------------------------------------------------*/
CaseLabel<out Expression expr>				(. expr = null; .)
=
  "case"
  ( Literal<out expr>
  | IntSeqExpr<out expr>
  | "default"								(. expr = Node.MakeConstant(ObjectTypes._CASE_DEFAULT, "default"); .)
  )
  SYNC ':' .
/*------------------------------------------------------------------------*/
LValueList<out SequenceExpression target>	(. Expression tmp; var exprs = new List<Expression>(); .)
=
  Primary<out tmp>							(. exprs.Add(tmp); .)
  { SYNC ','
    Primary<out tmp>						(. exprs.Add(tmp); .)
  }											(. target = Node.MakeSequence(exprs); .).
/*------------------------------------------------------------------------*/
LValueListWithLet<out SequenceExpression target>	(.  Identifier ident = null; string name;
														var type = TypeAnnotation.InferenceType; var items = new List<Expression>();
													.)
=
  "let"
  ident										(. name = t.val; .)									
  [ "(-"
    Type<out type>
  ]											(.  ident = Node.MakeLocalVar(name, type);
  												type = TypeAnnotation.InferenceType;
  												items.Add(ident);
  											.)
  { SYNC ','
    ident									(. name = t.val; .)
    [ "(-"
      Type<out type>
    ]										(.  ident = Node.MakeLocalVar(name, type);
    											type = TypeAnnotation.InferenceType;
    											items.Add(ident);
    										.)
  }											(. target = Node.MakeSequence(items); .).
/*------------------------------------------------------------------------*/
VarDecl<. out List<Expression> outs .> 	(.  string name; var type = TypeAnnotation.InferenceType.Clone(); Expression rhs = null;
											Identifier variable; outs = new List<Expression>();
								   			var vars = new List<Identifier>(); var exprs = new List<Expression>();
										.)
= 
  "let"
  ident							(. name = t.val; .)
  [ "(-"
    Type<out type>
  ]
  [ '='
    ( IF(NotFollowedByDoubleDots())
      CondExpr<out rhs>
    | IntSeqExpr<out rhs>
    )
  ]								(.  variable = Node.MakeLocalVar(name, type);
 						 			vars.Add(variable);
                                    if(rhs == null)
                                        rhs = Node.MakeDefaultExpr(type);
                                    
  						 			exprs.Add(rhs);
  						 			rhs = null;
  						 		.)
  { ','
    ident						(. name = t.val; .)
  	[ "(-"
   	  Type<out type>
  	]
  	[ '='
  	  ( IF(NotFollowedByDoubleDots())
	    CondExpr<out rhs>
	  | IntSeqExpr<out rhs>
	  )
  	]							(.  variable = Node.MakeLocalVar(name, type);
  									vars.Add(variable);
                                    if(rhs == null)
                                        rhs = Node.MakeDefaultExpr(type);
                                    
  									exprs.Add(rhs);
  									rhs = null;
  								.)
  }								(. outs.Add(Node.MakeVarDecl(vars, exprs)); .).
/*------------------------------------------------------------------------*/
FuncDecl<out Statement func>    (.  string name; var type = TypeAnnotation.VariantType.Clone(); Statement block;
									var @params = new List<Argument>(); Argument arg_this = null;
								.)
=
  SYNC
  "def"							(.  block = null;
  									arg_this = Node.MakeArg("this", new TypeAnnotation(ObjectTypes.TYPE_MODULE));
  									@params.Add(arg_this);
  								.)
  ident							(. name = t.val; .)
  '('
  [ParamList<ref @params>]
  ')'
  [ "->"
    Type<out type>
  ]
  Block<out block> 				(. func = Node.MakeFunc(name, @params, (Block)block, type); .).
/*------------------------------------------------------------------------*/
WithStmt<out Statement stmt>		(. Statement block = null; .)
=
  "with"
  '('
  ')'
  Block<out block>					(. stmt = null; .).
/*------------------------------------------------------------------------*/
TryStmt<out Statement stmt>			(.  Statement body, catch_body = null, finally_body = null; List<CatchClause> catches = null;
										TypeAnnotation excp_type = null; Identifier catch_ident = null; string name = null;
									.)
=
  "try"
  Block<out body>
  { "catch"							(. if(catches == null) catches = new List<CatchClause>(); .)
    '('
    ident							(. name = t.val; .)
    "(-"
    Type<out excp_type>
    ')'								(. catch_ident = Node.MakeLocalVar(name, excp_type); .)
    Block<out catch_body>			(. catches.Add(Node.MakeCatchClause((Block)catch_body, catch_ident)); .)
  }									
  [ "finally"
    Block<out finally_body>
  ]									(. stmt = Node.MakeTryStmt((Block)body, catches, (Block)finally_body); .).
/*------------------------------------------------------------------------*/
ParamList<. ref List<Argument> @params .>		(. Argument expr; .)
=
  Argument<out expr>							(. @params.Add(expr); .)
  { ','
    Argument<out expr>							(. @params.Add(expr); .)
  }.
/*------------------------------------------------------------------------*/
Argument<out Argument arg>		(. string name; Expression default_val = null; var type = TypeAnnotation.VariantType.Clone(); .)
=
  ident							(. name = t.val; .)
  [ "(-"
    Type<out type>
  ]
  [ '='
    Literal<out default_val>
  ]								(. arg = Node.MakeArg(name, type, default_val); .).
/*------------------------------------------------------------------------*/
RValueList<out SequenceExpression seq>		(. Expression tmp; var exprs = new List<Expression>(); .)
=
  CondExpr<out tmp>							(. exprs.Add(tmp); .)
  { SYNC ','
    CondExpr<out tmp>						(. exprs.Add(tmp);	.)
  }											(. seq = Node.MakeSequence(exprs); .).
/*------------------------------------------------------------------------*/
CondExpr<out Expression expr>		(. Expression true_expr, false_expr; .)
=
  OrTest<out expr>
  [ '?'
    OrTest<out true_expr>
    ':'
    CondExpr<out false_expr>		(. expr = Node.MakeCondExpr(expr, true_expr, false_expr); .)
  ].
/*------------------------------------------------------------------------*/
IntSeqExpr<out Expression expr>		(. Expression start = null, end = null, step = null; .)
=
  '['
  [OrTest<out start>]
  ".."
  OrTest<out end>
  [ ':'
    OrTest<out step>
  ]
  ']'								(.  if(start == null) start = CreateConstant(ObjectTypes.INTEGER);
  										if(step == null) step = Node.MakeConstant(ObjectTypes.INTEGER, 1);
  										expr = Node.MakeIntSeq(start, end, step);
  									.).
/*------------------------------------------------------------------------*/
OrTest<out Expression expr>			(. Expression rhs; .)
=
  AndTest<out expr>
  { "||"
    AndTest<out rhs>				(. expr = Node.MakeBinaryExpr(OperatorType.OR, expr, rhs); .)
  }.
/*------------------------------------------------------------------------*/
AndTest<out Expression expr>		(. Expression rhs; .)
=
  NotTest<out expr>
  { "&&"
    NotTest<out rhs>				(. expr = Node.MakeBinaryExpr(OperatorType.AND, expr, rhs); .)
  }.
/*------------------------------------------------------------------------*/
NotTest<out Expression expr>		(. Expression term; expr = null; .)
=
  ( '!'
    NotTest<out term>				(. expr = Node.MakeUnaryExpr(OperatorType.NOT, term); .)
  )
  | Comparison<out expr>.
/*------------------------------------------------------------------------*/
Comparison<out Expression expr>	(. Expression rhs; OperatorType type; .)
=
  BitOr<out expr>				(. type = OperatorType.EQUAL; .)
  [
    ( "=="               		(. type = OperatorType.EQUAL; .)
    | "!="						(. type = OperatorType.NOTEQ; .)
    | '<'                		(. type = OperatorType.LESS; .)
    | '>'                		(. type = OperatorType.GREAT; .)
    | "<="				 		(. type = OperatorType.LESE; .)
    | ">="				 		(. type = OperatorType.GRTE; .)
    )
    BitOr<out rhs>				(. expr = Node.MakeBinaryExpr(type, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
BitOr<out Expression expr>			(. Expression rhs; .)
=
  BitXor<out expr>
  { '|'
    BitXor<out rhs>					(. expr = Node.MakeBinaryExpr(OperatorType.BIT_OR, expr, rhs); .)
  }.
/*------------------------------------------------------------------------*/
BitXor<out Expression expr>			(. Expression rhs; .)
=
  BitAnd<out expr>
  { '^'
    BitAnd<out rhs>					(. expr = Node.MakeBinaryExpr(OperatorType.BIT_XOR, expr, rhs); .)
  }.
/*------------------------------------------------------------------------*/
BitAnd<out Expression expr>			(. Expression rhs; .)
=
  ShiftOpe<out expr>
  { '&'
    ShiftOpe<out rhs>				(. expr = Node.MakeBinaryExpr(OperatorType.BIT_AND, expr, rhs); .)
  }.
/*------------------------------------------------------------------------*/
ShiftOpe<out Expression expr>		(. Expression rhs; OperatorType type; .)
=
  AddOpe<out expr>
  {
  	( "<<" 							(. type = OperatorType.BIT_LSHIFT; .)
    | ">>"							(. type = OperatorType.BIT_RSHIFT; .)
    )
    AddOpe<out rhs>					(. expr = Node.MakeBinaryExpr(type, expr, rhs); .)
  }.
/*------------------------------------------------------------------------*/
AddOpe<out Expression expr>    		(. Expression rhs; OperatorType type; .)
= 
  Term<out expr>
  { 
    ( '+'							(. type = OperatorType.PLUS; .)
    | '-'							(. type = OperatorType.MINUS; .)
    )
    Term<out rhs>					(. expr = Node.MakeBinaryExpr(type, expr, rhs); .)
  }.
/*------------------------------------------------------------------------*/
Term<out Expression expr>   (. Expression rhs; OperatorType type; .)
= 
  Factor<out expr>
  {
    ( '*'					(. type = OperatorType.TIMES; .)
    | '/'					(. type = OperatorType.DIV; .)
    | '%'					(. type = OperatorType.MOD; .)
    )
    Factor<out rhs>			(. expr = Node.MakeBinaryExpr(type, expr, rhs); .)
  }.
/*------------------------------------------------------------------------*/
Factor<out Expression expr> (. OperatorType type; Expression factor; expr = null; .)
=
  PowerOpe<out expr>
  | ( '-' 					(. type = OperatorType.MINUS; .)
    | '+'			 		(. type = OperatorType.PLUS; .)
    )
  Factor<out factor>	 	(. expr = Node.MakeUnaryExpr(type, factor); .).
/*------------------------------------------------------------------------*/
PowerOpe<out Expression expr>    (. Expression rhs; .)
= 
  Primary<out expr>
  [ "**"
    Factor<out rhs>              (. expr = Node.MakeBinaryExpr(OperatorType.POWER, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
Primary<out Expression expr>		(. expr = null; .)
=
  ( Atom<out expr>
    { Trailer<ref expr>
    }
  )
  | NewExpression<out expr>.
/*------------------------------------------------------------------------*/
NewExpression<out Expression expr>		(. var args = new List<Expression>(); .)
=
  "new"
  ident									(. expr = Node.MakeIdentifier(t.val); .)
  { '.'
    ident								(. expr = Node.MakeMemRef(expr, Node.MakeField(t.val, TypeAnnotation.Subscription)); .)
  }
  '('
  [ArgList<ref args>]
  ')'									(. expr = Node.MakeNewExpr(expr, args); .).
/*------------------------------------------------------------------------*/
Trailer<ref Expression expr>	(. var args = new List<Expression>(); Expression subscript; .)
=
  '('							(.  if(expr is MemberReference)
                                        args.Add(((MemberReference)expr).Target);
                                    else
                                        args.Add(Node.MakeConstant(ObjectTypes.INSTANCE, this.TopmostAst));
                                .)
  [ArgList<ref args>]
  ')'							(. expr = Node.MakeCallExpr(expr, args); .)
  | '['
    Subscript<out subscript>
    ']'							(. expr = Node.MakeMemRef(expr, subscript); .)
  | '.'
    ident						(. expr = Node.MakeMemRef(expr, Node.MakeField(t.val, TypeAnnotation.Subscription)); .).
/*------------------------------------------------------------------------*/
Subscript<out Expression subscript>	(. subscript = null; .)
=
  IF(NotFollowedByDoubleDots())
  CondExpr<out subscript>
  | IntSeqExpr<out subscript>.
/*------------------------------------------------------------------------*/
ArgList<. ref List<Expression> args .>		(. Expression expr; .)
=
  CondExpr<out expr>						(. args.Add(expr); .)
  { ','
    CondExpr<out expr>						(. args.Add(expr); .)
  }.
/*------------------------------------------------------------------------*/
Atom<out Expression expr>			(. string name; expr = null; .)
=
  ident								(.  name = t.val;
  										expr = Node.MakeIdentifier(name);
  									.)
  | Literal<out expr>
  | '('
    [SequenceMaker<out expr, ObjectTypes.TUPLE>]
    SYNC ')'						(.  if(expr == null)
    										expr = Node.MakeSeqInitializer(ObjectTypes.TUPLE, new List<Expression>());
    								.)
  | '['
    [SequenceMaker<out expr, ObjectTypes.LIST>]
    SYNC ']'						(.  if(expr == null)
    										expr = Node.MakeSeqInitializer(ObjectTypes.LIST, new List<Expression>());
    								.)
  | '{'
    [DictMaker<out expr>]
    SYNC '}' 						(. if(expr == null) expr = Node.MakeSeqInitializer(ObjectTypes.DICT, new List<Expression>()); .).
/*------------------------------------------------------------------------*/
SequenceMaker<out Expression expr, ObjectTypes ObjType>	(.  Expression tmp = null; List<Expression> list = new List<Expression>();
															expr = null; ComprehensionIter comprehen = null;
														.)
=
  IF(IsSequenceInitializer())
  CondExpr<out tmp>						(. if(tmp != null) list.Add(tmp); .)
  { ','
    CondExpr<out tmp>					(. if(tmp != null) list.Add(tmp); .)
  }										(. expr = Node.MakeSeqInitializer(ObjType, list); .)
  | '{'
    CondExpr<out tmp>
    CompFor<out comprehen>
    '}'									(.  expr = Node.MakeComp(tmp, (ComprehensionFor)comprehen, ObjType); .).
/*------------------------------------------------------------------------*/
DictMaker<out Expression expr>			(. Expression lhs, rhs; List<Expression> list = new List<Expression>(); expr = null; .)
=
  ( CondExpr<out lhs>					(. if(lhs != null) list.Add(lhs); .)
    ':'
    CondExpr<out rhs>					(. if(rhs != null) list.Add(rhs); .)
  )
  { ','
    CondExpr<out lhs>					(. if(lhs != null) list.Add(lhs); .)
    ':'
    CondExpr<out rhs>					(. if(rhs != null) list.Add(rhs); .)
  }
  										(. if(list.Count > 0) expr = Node.MakeSeqInitializer(ObjectTypes.DICT, list); .).
/*------------------------------------------------------------------------*/
CompIter<out ComprehensionIter expr>			(. expr = null; .)
=
  CompFor<out expr>
  | CompIf<out expr> .
/*------------------------------------------------------------------------*/
CompFor<out ComprehensionIter expr>		(. Expression rvalue = null; ComprehensionIter body = null; SequenceExpression target; .)
=
  "for"
  LValueList<out target>
  "in"
  ( IF(NotFollowedByDoubleDots())
    CondExpr<out rvalue>
  | IntSeqExpr<out rvalue>
  )
  [CompIter<out body>]					(. expr = Node.MakeCompFor(target, rvalue, body); .).
/*------------------------------------------------------------------------*/
CompIf<out ComprehensionIter expr>		(. Expression tmp; ComprehensionIter body = null; .)
=
  "if"
  OrTest<out tmp>
  [CompIter<out body>]					(. expr = Node.MakeCompIf(tmp, body); .).
/*------------------------------------------------------------------------*/
Literal<out Expression expr>	(. expr = null; string tmp; bool has_suffix = false; .)
= 
  integer						(. tmp = t.val; .)
  [ 'l'							(. has_suffix = true; .)
  | 'L'							(. has_suffix = true; .)
  ]								(.  if(has_suffix)
  										expr = Node.MakeConstant(ObjectTypes.BIGINT, BigInteger.Parse(tmp));
  									else
  										expr = Node.MakeConstant(ObjectTypes.INTEGER, Convert.ToInt32(tmp));
  								.)
  | hex_digit					(. expr = Node.MakeConstant(ObjectTypes.INTEGER, Convert.ToInt32(t.val, 16)); .)
  | float						(. expr = Node.MakeConstant(ObjectTypes.FLOAT, Convert.ToDouble(t.val)); .)
  | string_literal				(. tmp = t.val;
  								   tmp = tmp.Substring(1, tmp.Length - 2);
  								   expr = Node.MakeConstant(ObjectTypes.STRING, tmp);
  								.)
  | 
    ( "true"				
  	| "false"
  	)							(. expr = Node.MakeConstant(ObjectTypes.BOOL, Convert.ToBoolean(t.val)); .)
  | "null"						(. expr = Node.MakeConstant(ObjectTypes.NULL, null); .).
/*------------------------------------------------------------------------*/
END Expresso.
