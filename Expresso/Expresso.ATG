using System.Collections.Generic;
using System.Linq;
using Expresso.Ast;
using Expresso.BuiltIns;
using Expresso.Interpreter;
using Expresso.Helpers;



COMPILER Expresso

	internal Scope cur_scope = new Scope();		//the current scope of variables
	static private Scope funcs = new Scope();	//the namespace for funcTable
	public Block root = new Block();
	static public Function main_func = null;	//the main function
	static private List<BreakableStatement> breakables = new List<BreakableStatement>();	//the current parent breakbles
	
	static Parser()
	{			//Add built-in functions
		Function[] native_funcs = {
			new NativeFunctionUnary<double, double>(
				"abs", new Argument{Name = "val", ParamType = TYPES.FLOAT}, Math.Abs
			),
			new NativeFunctionUnary<double, double>(
				"sqrt", new Argument{Name = "val", ParamType = TYPES.FLOAT}, Math.Sqrt
			),
			new NativeFunctionUnary<int, double>(
				"toInt", new Argument{Name = "val", ParamType = TYPES.FLOAT}, (double x) => (int)x
			)
		};
		foreach(var tmp in native_funcs)
			funcs.AddFunction(tmp);
	}
	
	Constant CreateConstant(TYPES type)
	{
		Constant result = null;
		
		switch(type){
		case TYPES.INTEGER:
			result = new Constant{ValType = type, Value = 0};
			break;
			
		case TYPES.BOOL:
			result = new Constant{ValType = type, Value = false};
			break;
			
		case TYPES.FLOAT:
			result = new Constant{ValType = type, Value = 0.0};
			break;
			
		case TYPES.STRING:
			result = new Constant{ValType = type, Value = ""};
			break;
			
		default:
			SemErr("Unknown object type");
			break;
		}
		
		return result;
	}
	
	bool NotFollowedByDoubleDots()
	{
		Token x = la;
		scanner.ResetPeek();
		while(x.kind != _double_dots && x.kind != _rbracket) x = scanner.Peek();
		return x.kind != _double_dots;
	}
	
	bool NotLookAtCurly()
	{
		return t.kind != _lcurly;
	}
	
	bool IdentIsNotCallable()
	{
		Token x = scanner.Peek();
		return x.kind != _lparen;
	}
	
	Identifier DeclareVariable(ref Expression rhs, string name, TYPES type)
	{
		var variable = new Identifier{
  			Name = name,
  			ParamType = type
  		};
  		if(rhs == null){
  			if(type == TYPES.VAR) SemErr("Can not declare a variable of \"var\" without initialization!");
  			rhs = CreateConstant(type);
  		}
  							
 		cur_scope.AddLocal(variable);
 		return variable;
	}
	
	static ExprStatement MakeExprStatement(List<Expression> exprs)
	{
		return new ExprStatement{Expressions = exprs};
	}
	
	static BreakStatement MakeBreakStatement(int count)
	{
		var tmp = new List<BreakableStatement>();
		for(int len = Parser.breakables.Count, i = 0, j = count; j > 0; ++i){
			var enclosing = Parser.breakables[len - 1 - i];
			tmp.Add(enclosing);
			if(enclosing.Type == NodeType.WhileStatement || enclosing.Type == NodeType.ForStatement) --j;
		}
		return new BreakStatement{Count = count, Enclosings = tmp};
	}
	
	static IfStatement MakeIfStatement(Expression condition, Statement trueBlock, Statement falseBlock)
	{
		return new IfStatement{Condition = condition, TrueBlock = trueBlock, FalseBlock = falseBlock};
	}
	
	static WhileStatement MakeWhileStatement()
	{
		return new WhileStatement();
	}
	
	static ForStatement MakeForStatement()
	{
		return new ForStatement();
	}
	
	static SwitchStatement MakeSwitchStatement(Expression target, List<CaseClause> cases)
	{
		return new SwitchStatement{Target = target, Cases = cases};
	}
	
	static CaseClause MakeCaseClause(List<Expression> labels, Statement body)
	{
		return new CaseClause{Labels = labels, Body = body};
	}
	
	static Function MakeFunc(string name, List<Argument> parameters, Block body, TYPES returnType)
	{
		return new Function{Name = name, Parameters = parameters, Body = body, ReturnType = returnType};
	}
	
	static UnaryExpression MakeUnaryExpr(OperatorType op, Expression operand)
	{
		return new UnaryExpression{Operator = op, Operand = operand};
	}
	
	static BinaryExpression MakeBinaryExpr(OperatorType op, Expression lhs, Expression rhs)
	{
		return new BinaryExpression{Operator = op, Left = lhs, Right = rhs};
	}
	
	static ObjectInitializer MakeObjInitializer(TYPES type, List<Expression> initializeList)
	{
		return new ObjectInitializer{InitializeList = initializeList, ObjType = type};
	}
	
	static Assignment MakeAssignment(List<Expression> targets, List<Expression> expressions)
	{
		return new Assignment{Targets = targets, Expressions = expressions};
	}
	
	static Assignment MakeAugumentedAssignment(List<Expression> targets, List<Expression> expressions, OperatorType opType)
	{
		var rvalues = new List<Expression>();
		for(int i = 0; i < expressions.Count; ++i){
			var rvalue = new BinaryExpression{Left = targets[i], Right = expressions[i], Operator = opType};
			rvalues.Add(rvalue);
		}
		return new Assignment{Targets = targets, Expressions = rvalues};
	}
	
	static Iteration MakeIteration(List<Expression> targets, List<Expression> exprs)
	{
		return new Iteration{Targets = targets, Expressions = exprs};
	}
	
	static Comprehension MakeComp(Expression body, Expression child)
	{
		return new Comprehension{Body = body, Child = child};
	}
	
	static ComprehensionFor MakeCompFor(Expression iteration, Expression body)
	{
		return new ComprehensionFor{Iteration = iteration, Body = body};
	}
	
	static ComprehensionIf MakeCompIf(Expression condition, Expression body)
	{
		return new ComprehensionIf{Condition = condition, Body = body};
	}
	
	static Constant MakeConstant(TYPES type, object val)
	{
		return new Constant{ValType = type, Value = val};
	}
	
	static IntSeqExpression MakeIntSeq(Expression start, Expression end, Expression step)
	{
		return new IntSeqExpression{Start = start, End = end, Step = step};
	}
	
/*--------------------------------------------------------------------------*/
CHARACTERS
  letter = 'A'..'Z' + 'a'..'z'.
  digit = '0'..'9'.
  cr  = '\r'.
  lf  = '\n'.
  tab = '\t'.
  quotedLetter = ANY - '"' - '\''.

TOKENS
  double_dots = "..".
  rbracket = ']'.
  colon = ':'.
  semicolon = ';'.
  lcurly = '{'.
  lparen = '('.
  ident  = (letter | '_') {'_' | letter | digit}.
  integer = digit {digit}
  			| digit {digit} CONTEXT("..").
  float = digit {digit} "." {digit} ["e" ["+" | "-"] digit {digit}].
  string_literal = '"' {quotedLetter} '"'.

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO lf

IGNORE cr + lf + tab



PRODUCTIONS
/*------------------------------------------------------------------------*/
Expresso                    (. Statement stmt = null; .)
= 
  //ProgramDefinition
  
  (  ExprStmt<out stmt>
  |  FuncDecl<out stmt>
  )							(. root.Statements.Add(stmt); .)
  {  ExprStmt<out stmt>		(. root.Statements.Add(stmt); .)
  |  FuncDecl<out stmt>		(. root.Statements.Add(stmt); .)
  }							(. Parser.main_func = funcs.GetFunction("main"); .).
/*------------------------------------------------------------------------*/
/*ProgramDefinition<out Statement require>
=
  {RequireStmt<out require>}.*/
/*------------------------------------------------------------------------*/
/*RequireStmt<out Statement stmt>
=
  SYNC
  "require"
  Module<out module>
  [  "as"
     Name<out name>
  ]
  {  ','
     Module<out module>
     [  "as"
        Name<out name>
     ]
  }
  SYNC ';' .*/
/*------------------------------------------------------------------------*/
Type<out TYPES type>
=                        (. type = TYPES.UNDEF; .)
 ( "int"                 (. type = TYPES.INTEGER; .)
 | "bool"                (. type = TYPES.BOOL; .)
 | "float"				 (. type = TYPES.FLOAT; .)
 | "rational"			 (. type = TYPES.RATIONAL; .)
 | "bigint"				 (. type = TYPES.BIGINT; .)
 | "string"				 (. type = TYPES.STRING; .)
 | "bytearray"			 (. type = TYPES.BYTEARRAY; .)
 | "var"				 (. type = TYPES.VAR; .)
 | "tuple"				 (. type = TYPES.TUPLE; .)
 | "list"				 (. type = TYPES.LIST; .)
 | "dictionary"			 (. type = TYPES.DICT; .)
 | "expression"			 (. type = TYPES.EXPRESSION; .)
 | "function"			 (. type = TYPES.FUNCTION; .)
 | "intseq"				 (. type = TYPES.SEQ; .)
 ).
/*------------------------------------------------------------------------*/
Stmt<out Statement stmt>			(. stmt = null; .)
=
  SimpleStmt<out stmt>
  | CompoundStmt<out stmt> .
/*------------------------------------------------------------------------*/
SimpleStmt<out Statement stmt>		(. stmt = null; .)
=		/* For DictMaker and Block conflict. Since DictMaker should not be a lvalue, we always choose the first(Block).*/
    Block<out stmt>
  | ExprStmt<out stmt>
  | PrintStmt<out stmt>
  | ReturnStmt<out stmt>
  | BreakStmt<out stmt>
  | ContinueStmt<out stmt>.
/*------------------------------------------------------------------------*/
PrintStmt<out Statement stmt>		(. List<Expression> exprs = null; bool trailing_comma = false; .)
=
  "print"
  [RValueList<out exprs>]
  [',']								(. trailing_comma = true; .)
  SYNC ';'							(. stmt = new PrintStatement{Expressions = exprs}; .).
/*------------------------------------------------------------------------*/
ReturnStmt<out Statement stmt>		(. List<Expression> target_list = new List<Expression>(); bool trailing_comma; .)
=
  "return"
  [RValueList<out target_list>]
  SYNC ';'							(. stmt = new Return{Expressions = target_list}; .).
/*------------------------------------------------------------------------*/
BreakStmt<out Statement stmt>		(. int count = 1; .)
=
  "break"
  [  "upto"
     integer						(. count = Convert.ToInt32(t.val); .)
  ]
  SYNC ';' 							(. stmt = MakeBreakStatement(count); .).
/*------------------------------------------------------------------------*/
ContinueStmt<out Statement stmt>	(. int count = 1; .)
= 
  "continue"
  [  "upto"
     integer						(. count = Convert.ToInt32(t.val); .)
  ]
  SYNC ';' 							(. stmt = new ContinueStatement{Count = count}; .).
/*------------------------------------------------------------------------*/
AugAssignOpe<ref OperatorType type>
=
  (  "+="							(. type = OperatorType.PLUS; .)
  |  "-="							(. type = OperatorType.MINUS; .)
  |  "*="							(. type = OperatorType.TIMES; .)
  |  "/="							(. type = OperatorType.DIV; .)
  |  "**="							(. type = OperatorType.POWER; .)
  |  "%="							(. type = OperatorType.MOD; .)
  |  "&="							(. type = OperatorType.BIT_AND; .)
  |  "|="							(. type = OperatorType.BIT_OR; .)
  |  "<<="							(. type = OperatorType.BIT_LSHIFT; .)
  |  ">>="							(. type = OperatorType.BIT_RSHIFT; .)
  ).
/*------------------------------------------------------------------------*/
ExprStmt<out Statement stmt>					(.
													List<Expression> targets = null; List<Expression> expr_list;
													stmt = null; bool trailing_comma; OperatorType op_type = OperatorType.NONE;
												.)
=
  (  VarDecl<out targets>
  |  RValueList<out targets>
    (  AugAssignOpe<ref op_type>
       RValueList<out expr_list>				(. stmt = MakeAugumentedAssignment(targets, expr_list, op_type); .)
    |
    {  '='
	   RValueList<out expr_list>				(. stmt = MakeAssignment(targets, expr_list); .)
    }
    )
  )SYNC ';' 									(. if(stmt == null) stmt = MakeExprStatement(targets); .).
/*------------------------------------------------------------------------*/
Block<out Statement block, bool needsScope = true>	(.
														Block tmp;
														if(needsScope) cur_scope = new Scope{Parent = cur_scope}; Statement stmt;
													.)
=
  '{'								(.
  										tmp = new Block();
  										Parser.breakables.Add(tmp);
  									.)
  Stmt<out stmt>					(. tmp.Statements.Add(stmt); .)
  { Stmt<out stmt>					(. tmp.Statements.Add(stmt); .)
  }
  '}' 								(.
  										cur_scope = cur_scope.Parent; block = tmp;
  										Parser.breakables.RemoveLast();
  									.).
/*------------------------------------------------------------------------*/
CompoundStmt<out Statement stmt>	(. stmt = null; .)
=
  SYNC
    IfStmt<out stmt>					
  | WhileStmt<out stmt>
  | ForStmt<out stmt>
  | SwitchStmt<out stmt>
  | FuncDecl<out stmt>.
/*------------------------------------------------------------------------*/
IfStmt<out Statement stmt>			(. Expression tmp; Statement true_block, false_block = null; .)
=
  "if" 
  '(' CondExpr<out tmp> ')'
  Stmt<out true_block>
  [ "else"
     Stmt<out false_block>
  ]                      			(. stmt = MakeIfStatement(tmp, true_block, false_block); .).
/*------------------------------------------------------------------------*/
WhileStmt<out Statement stmt>		(. Expression cond; Statement body = null; WhileStatement tmp; .)
=
  "while"							(.
  										tmp = MakeWhileStatement();
  										Parser.breakables.Add(tmp);
  									.)
  '(' CondExpr<out cond> ')'
  Stmt<out body>                   	(. 
  										tmp.Condition = cond;
  										tmp.Body = body;
  										Parser.breakables.RemoveLast();
  										stmt = tmp;
  									.).
/*------------------------------------------------------------------------*/
ForStmt<out Statement stmt>			(. List<Expression> target_list; Expression rvalue = null; Statement body; ForStatement tmp; .)
=
  "for"								(.
  										tmp = MakeForStatement();
  										Parser.breakables.Add(tmp);
  									.)
  '('
  ["let"]
  LValueList<out target_list>
  "in"
  (  IF(NotFollowedByDoubleDots())
     CondExpr<out rvalue>
  |  IntSeqExpr<out rvalue>
  )
  ')'
  Stmt<out body>					(. 
  										tmp.LValues = target_list;
  										tmp.Target = rvalue;
  										tmp.Body = body;
  										Parser.breakables.RemoveLast();
  										stmt = tmp;
  									.).
/*------------------------------------------------------------------------*/
SwitchStmt<out Statement stmt>		(. Expression target; List<CaseClause> cases; .)
=
  "switch"
  '('
  CondExpr<out target>
  ')'
  '{'
  CaseClauseList<out cases>
  '}'								(. stmt = MakeSwitchStatement(target, cases); .).
/*------------------------------------------------------------------------*/
CaseClauseList<. out List<CaseClause> clauses .>	(. clauses = new List<CaseClause>(); List<Expression> label_list; Statement inner; .)
=
  CaseLabelList<out label_list>
  Stmt<out inner>									(. clauses.Add(MakeCaseClause(label_list, inner)); .)
  {  CaseLabelList<out label_list>
     Stmt<out inner>								(. clauses.Add(MakeCaseClause(label_list, inner)); .)
  }.
/*------------------------------------------------------------------------*/
CaseLabelList<. out List<Expression> label_list .>	(. label_list = new List<Expression>(); Expression tmp; .)
=
  CaseLabel<out tmp>								(. label_list.Add(tmp); .)
  {  CaseLabel<out tmp>								(. label_list.Add(tmp); .)
  }.
/*------------------------------------------------------------------------*/
CaseLabel<out Expression expr>						(. expr = null; .)
=
  "case"
  (
    Literal<out expr>
  | IntSeqExpr<out expr>
  | "default"										(. expr = MakeConstant(TYPES._CASE_DEFAULT, "default"); .)
  )
  SYNC ':' .
/*------------------------------------------------------------------------*/
LValueList<. out List<Expression> targets .>		(. Expression tmp; .)
=													(. targets = new List<Expression>(); .)
  AddOpe<out tmp>									(. targets.Add(tmp); .)
  { WEAK ','
    AddOpe<out tmp>									(. targets.Add(tmp); .)
  }
  /*[',']*/ .
/*------------------------------------------------------------------------*/
VarDecl<. out List<Expression> outs .> 	(. string name; TYPES type; Expression rhs = null; Identifier variable; outs = new List<Expression>();
								   			var vars = new List<Identifier>(); var exprs = new List<Expression>();
										.)
= 
  "let"							(. type = TYPES.VAR; .)
  Variable<out name>
  [ "(-"
    Type<out type>
  ]
  [ '='
    CondExpr<out rhs>
  ]
  { ','					 (. variable = DeclareVariable(ref rhs, name, type);
 						 	vars.Add(variable);
  						 	exprs.Add(rhs);
  						 .)
    Variable<out name>
  	[ "(-"
   	  Type<out type>
  	]
  	[ '='
  	  CondExpr<out rhs>
  	]
  }						(. variable = DeclareVariable(ref rhs, name, type);
  					   	   vars.Add(variable);
  					   	   exprs.Add(rhs);
  					   
  					   	   outs.Add(new VarDeclaration{
  					   			Variables = vars,
  					   			Expressions = exprs
  					   	   });
  						.).
/*------------------------------------------------------------------------*/
FuncDecl<out Statement func>    (. string name; TYPES type; Statement block; List<Argument>@params = new List<Argument>(); .)
=
  SYNC
  "def"							(. type = TYPES.VAR; block = null; cur_scope = new Scope{Parent = cur_scope}; .)
  ident							(. name = t.val; .)
  '('
  [ParamList<ref @params>]
  ')'
  [  "(-"
     Type<out type>
  ]
  Block<out block, false> 		(. func = MakeFunc(name, @params, (Block)block, type);
  								   funcs.AddFunction(func as Function);
  								.).
/*------------------------------------------------------------------------*/
ParamList<. ref List<Argument> @params .>		(. Argument expr; .)
=
  Argument<out expr>							(. @params.Add(expr); .)
  {  ','
     Argument<out expr>							(. @params.Add(expr); .)
  }.
/*------------------------------------------------------------------------*/
Argument<out Argument arg>		(. string name; Expression default_val = null; TYPES type = TYPES.VAR; .)
=
  Variable<out name>
  [ "(-"
    Type<out type>
  ]
  [ '='
    Literal<out default_val>
  ]									(. Identifier param = new Identifier{Name = name, ParamType = type};
  									   cur_scope.AddLocal(param);
  									   arg = new Argument{
  											Name = name,
  											ParamType = type,
  											Option = default_val
  									   };
  									.).
/*------------------------------------------------------------------------*/
RValueList<. out List<Expression> exprs .>		(. Expression tmp; .)
=												(. exprs = new List<Expression>(); .)
  CondExpr<out tmp>								(. exprs.Add(tmp); .)
  { ','
    CondExpr<out tmp>							(. exprs.Add(tmp);	.)
  }.
/*------------------------------------------------------------------------*/
CondExpr<out Expression expr>		(. Expression true_expr, false_expr; .)
=
  OrTest<out expr>
  [ '?'
    OrTest<out true_expr>
    ':'
    CondExpr<out false_expr>		(. expr = new ConditionalExpression{
    										Condition = expr,
    										TrueExpression = true_expr,
    										FalseExpression = false_expr
    								   };
    								.)
  ].
/*------------------------------------------------------------------------*/
IntSeqExpr<out Expression expr>		(. Expression start = null, end = null, step = null; .)
=
  '['
  [OrTest<out start>]
  ".."
  OrTest<out end>
  [ ':'
    OrTest<out step>
  ]
  ']'								(. 
  										if(start == null) start = CreateConstant(TYPES.INTEGER);
  										if(step == null) step = MakeConstant(TYPES.INTEGER, 1);
  										expr = MakeIntSeq(start, end, step);
  									.).
/*------------------------------------------------------------------------*/
OrTest<out Expression expr>			(. Expression rhs; .)
=
  AndTest<out expr>
  {
    "or"
    AndTest<out rhs>				(. expr = MakeBinaryExpr(OperatorType.OR, expr, rhs); .)
  }.
/*------------------------------------------------------------------------*/
AndTest<out Expression expr>		(. Expression rhs; .)
=
  NotTest<out expr>
  {
    "and"
    NotTest<out rhs>				(. expr = MakeBinaryExpr(OperatorType.AND, expr, rhs); .)
  }.
/*------------------------------------------------------------------------*/
NotTest<out Expression expr>		(. Expression term; expr = null; .)
=
  ( "not"
    NotTest<out term>				(. expr = MakeUnaryExpr(OperatorType.MINUS, term); .)
  )
  | Comparison<out expr>.
/*------------------------------------------------------------------------*/
Comparison<out Expression expr>		(. Expression rhs; OperatorType type; .)
=
  BitOr<out expr>			(. type = OperatorType.EQUAL; .)
  [
    ( "=="               	(. type = OperatorType.EQUAL; .)
    | "!="					(. type = OperatorType.NOTEQ; .)
    | '<'                	(. type = OperatorType.LESS; .)
    | '>'                	(. type = OperatorType.GREAT; .)
    | "<="				 	(. type = OperatorType.LESE; .)
    | ">="				 	(. type = OperatorType.GRTE; .)
    )
    BitOr<out rhs>			(. expr = MakeBinaryExpr(type, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
BitOr<out Expression expr>			(. Expression rhs; .)
=
  BitXor<out expr>
  {  '|'
     BitXor<out rhs>				(. expr = MakeBinaryExpr(OperatorType.BIT_OR, expr, rhs); .)
  }.
/*------------------------------------------------------------------------*/
BitXor<out Expression expr>			(. Expression rhs; .)
=
  BitAnd<out expr>
  {  '^'
     BitAnd<out rhs>				(. expr = MakeBinaryExpr(OperatorType.BIT_XOR, expr, rhs); .)
  }.
/*------------------------------------------------------------------------*/
BitAnd<out Expression expr>			(. Expression rhs; .)
=
  ShiftOpe<out expr>
  {  '&'
     ShiftOpe<out rhs>				(. expr = MakeBinaryExpr(OperatorType.BIT_AND, expr, rhs); .)
  }.
/*------------------------------------------------------------------------*/
ShiftOpe<out Expression expr>		(. Expression rhs; OperatorType type; .)
=
  AddOpe<out expr>
  {  ( "<<" 						(. type = OperatorType.BIT_LSHIFT; .)
     | ">>"							(. type = OperatorType.BIT_RSHIFT; .)
     )
     AddOpe<out rhs>				(. expr = MakeBinaryExpr(type, expr, rhs); .)
  }.
/*------------------------------------------------------------------------*/
AddOpe<out Expression expr>    (. Expression rhs; OperatorType type; .)
= 
  Term<out expr>
  { 
    ( '+'							(. type = OperatorType.PLUS; .)
    | '-'							(. type = OperatorType.MINUS; .)
    )
    Term<out rhs>					(. expr = MakeBinaryExpr(type, expr, rhs); .)
  }.
/*------------------------------------------------------------------------*/
Term<out Expression expr>   (. Expression rhs; OperatorType type; .)
= 
  Factor<out expr>
  {
    ( '*'					(. type = OperatorType.TIMES; .)
    | '/'					(. type = OperatorType.DIV; .)
    | '%'					(. type = OperatorType.MOD; .)
    )
    Factor<out rhs>			(. expr = MakeBinaryExpr(type, expr, rhs); .)
  }.
/*------------------------------------------------------------------------*/
Factor<out Expression expr> (. OperatorType type; Expression factor; expr = null; .)
=
  PowerOpe<out expr>
  | ( '-' 					(. type = OperatorType.MINUS; .)
    | '+'			 		(. type = OperatorType.PLUS; .)
    )
  Factor<out factor>	 	(. expr = MakeUnaryExpr(type, factor); .).
/*------------------------------------------------------------------------*/
PowerOpe<out Expression expr>    (. Expression rhs; .)
= 
  Primary<out expr>
  [ "**"
    Factor<out rhs>              (. expr = MakeBinaryExpr(OperatorType.POWER, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
Primary<out Expression expr>	(. string name = ""; expr = null; .)
=
  (  IF(IdentIsNotCallable())
     Atom<out expr>
  |  ident						(. name = t.val; .)
  )
  {  Trailer<ref expr, name>
  }.
/*------------------------------------------------------------------------*/
Trailer<ref Expression expr, string name>	(. Function func; List<Expression> args = new List<Expression>(); Expression subscript; .)
=
  '('
  [ArgList<ref args>]
  ')'							(. 
  								   if(expr != null){
  								   		expr = new Call{
  								   			Function = null,
  								   			Arguments = args,
  								   			Reference = expr
  								   		};
  								   		return;
  								   }
  								   func = funcs.GetFunction(name);
  								   if(func == null){
  								   		SemErr("The function is not defined : " + name);
  								   }
  								   expr = new Call{
  								   		Function = func,
  										Arguments = args,
  										Reference = null
  								   };
  						 		.)
  |  '['
     Subscript<out subscript>
     ']'						(. expr = new MemberReference{
     									Parent = expr,
     									Subscription = subscript
     							   };
     							.)
  |  '.'
     ident						(. subscript = new Identifier{
     									Name = t.val,
     									ParamType = TYPES._SUBSCRIPT
     							   };
     							   expr = new MemberReference{
     							   		Parent = expr,
     							   		Subscription = subscript
     							   };
     							.).
/*------------------------------------------------------------------------*/
Subscript<out Expression subscript>	(. subscript = null; .)
=
  IF(NotFollowedByDoubleDots())
  CondExpr<out subscript>
  |  IntSeqExpr<out subscript>.
/*------------------------------------------------------------------------*/
ArgList<. ref List<Expression> args .>		(. Expression expr; .)
=
  CondExpr<out expr>						(. args.Add(expr); .)
  {  ','
     CondExpr<out expr>						(. args.Add(expr); .)
  }.
/*------------------------------------------------------------------------*/
Atom<out Expression expr>			(. string name; expr = null; .)
=
  Variable<out name>				(. expr = cur_scope.GetVariable(name);
  									   if(expr == null){
  									   		SemErr(string.Format("Attempt to refer to an undefined variable \"{0}\"", name));
  									   }
  									.)
  | Literal<out expr>
  | '('
    TupleMaker<out expr>
    SYNC ')'						(. if(expr == null) expr = MakeObjInitializer(TYPES.TUPLE, new List<Expression>()); .)
  | '['
    ListMaker<out expr>
    SYNC ']'						(. if(expr == null) expr = MakeObjInitializer(TYPES.LIST, new List<Expression>()); .)
  | '{'
    DictMaker<out expr>
    SYNC '}' 						(. if(expr == null) expr = MakeObjInitializer(TYPES.DICT, new List<Expression>()); .).
/*------------------------------------------------------------------------*/
TupleMaker<out Expression expr>			(. Expression tmp; List<Expression> list = new List<Expression>(); expr = null; .)
=
  CondExpr<out tmp>						(. if(tmp != null) list.Add(tmp); .)
  { ','
    CondExpr<out tmp>					(. if(tmp != null) list.Add(tmp); .)
  }
  /*(  //CompFor<out comp_expr>
        CondExpr<out tmp>				(. list.Add(tmp); .)
     }
  )*/									(. if(list.Count > 0) expr = MakeObjInitializer(TYPES.TUPLE, list); .).
/*------------------------------------------------------------------------*/
ListMaker<out Expression expr>			(. expr = null; Expression tmp; List<Expression> list = new List<Expression>(); .)
=
  CondExpr<out tmp>						(. if(tmp != null) list.Add(tmp); .)
  { ','
    CondExpr<out tmp>					(. if(tmp != null) list.Add(tmp); .)
  }
  /*|
  ( CompFor<out tmp>					(. expr = MakeComp(list[0], tmp); .)
  )*/									(. if(list.Count > 0) expr = MakeObjInitializer(TYPES.LIST, list); .).
/*------------------------------------------------------------------------*/
DictMaker<out Expression expr>			(. Expression lhs, rhs; List<Expression> list = new List<Expression>(); expr = null; .)
=
  ( CondExpr<out lhs>					(. if(lhs != null) list.Add(lhs); .)
    ':'
    CondExpr<out rhs>					(. if(rhs != null) list.Add(rhs); .)
  )
  { ','
    CondExpr<out lhs>					(. if(lhs != null) list.Add(lhs); .)
    ':'
    CondExpr<out rhs>					(. if(rhs != null) list.Add(rhs); .)
  }
  										(. if(list.Count > 0) expr = MakeObjInitializer(TYPES.DICT, list); .).
/*------------------------------------------------------------------------*/
/*CompIter<out Expression expr>			(. expr = null; .)
=
  CompFor<out expr>
  |  CompIf<out expr> .*/
/*------------------------------------------------------------------------*/
/*CompFor<out Expression expr>			(. Expression rvalue, body = null; List<Expression> target_list, test_list; ForStatement tmp; .)
=
  "for"									(.
  											tmp = MakeForStatement();
  											Parser.breakables.Add(tmp);
  										.)
  ["let"]
  LValueList<out target_list>
  "in"
  ( CondExpr<out rvalue>
  | IntSeqExpr<out rvalue>				(. iter = MakeIteration(expr_list, test_list); .)
  )
  [CompIter<out body>]					(. expr = MakeCompFor(iter, body); .).*/
/*------------------------------------------------------------------------*/
/*CompIf<out Expression expr>				(. Expression tmp, body = null; .)
=
  "if"
  OrTest<out tmp>
  [CompIter<out body>]					(. expr = MakeCompIf(tmp, body); .).*/
/*------------------------------------------------------------------------*/
Variable<out string name>
= 
  ident				(. name = t.val; .).
/*------------------------------------------------------------------------*/
Literal<out Expression expr>	(. expr = null; .)
= 
  integer				(. expr = MakeConstant(TYPES.INTEGER, Convert.ToInt32(t.val)); .)
  |  float				(. expr = MakeConstant(TYPES.FLOAT, Convert.ToDouble(t.val)); .)
  |  string_literal		(. string tmp = t.val;
  						   tmp = tmp.Substring(1, tmp.Length - 2);
  						   expr = MakeConstant(TYPES.STRING, tmp);
  						.)
  |  (  "true"				
  	 |  "false"
  	 )					(. expr = MakeConstant(TYPES.BOOL, Convert.ToBoolean(t.val)); .)
  |  "null"				(. expr = MakeConstant(TYPES.NULL, null); .).
/*------------------------------------------------------------------------*/
END Expresso.
