using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using System.Numerics;
using System.Text.RegularExpressions;

using Expresso.Ast;
using Expresso.Ast.Analysis;
using Expresso.CodeGen;
using Expresso.TypeSystem;

using ICSharpCode.NRefactory;


using ExpressoModifiers = Expresso.Ast.Modifiers;


COMPILER Expresso

$namespace=Expresso
	string cur_class_name;
	bool is_first_comprehension_for_clause = true;
    static uint ScopeId = 1;
    static Regex UnicodeEscapeFinder = new Regex(@"\\[uU]([\dA-Fa-f]{4}|[\dA-Fa-f]{6})", RegexOptions.Compiled);
    internal SymbolTable Symbols{get; set;}
    /// <summary>
    /// This flag determines whether we are doing post-parse processing including name binding,
    /// type validity check, type inference and flow analisys.
    /// </summary>
    public bool DoPostParseProcessing{get; set;}
	public ExpressoAst TopmostAst{get; private set;}	//the top-level AST the parser is parsing
    public TextLocation CurrentLocation{
        get{
            return new TextLocation(t.line, t.col);
        }
    }

    public TextLocation NextLocation{
        get{
            return new TextLocation(la.line, la.col);
        }
    }

	///<summary>
	/// Parser Implementation details:
	/// 	During parsing we'll construct the symbol table.
	/// 	And in post-parse process, do type validity check and flow analysis, including local name bindings
    ///     and type inference.
	///		Note that the identifiers are just placeholders until after doing name binding. 
	/// 	(Thus referencing them causes runtime exceptions)
	///</summary>
    ///<remarks>
    /// The Parser class itself is responsible for constructing the AST AND the symbol table.
    ///</remarks>
	Parser()
	{
        DoPostParseProcessing = false;
        Symbols = SymbolTable.Create();
	}
	
	LiteralExpression CreateDefaultValue(KnownTypeCode type)
	{
		LiteralExpression result = null;
		var loc = CurrentLocation;
        var type_name = type.ToString().ToLower();

		switch(type){
		case KnownTypeCode.Int:
        case KnownTypeCode.UInt:
        case KnownTypeCode.Byte:
			result = Expression.MakeConstant(type_name, 0, loc);
			break;
			
		case KnownTypeCode.Bool:
			result = Expression.MakeConstant(type_name, false, loc);
			break;
			
		case KnownTypeCode.Float:
			result = Expression.MakeConstant(type_name, 0.0, loc);
			break;
			
		case KnownTypeCode.String:
			result = Expression.MakeConstant(type_name, "", loc);
			break;

        case KnownTypeCode.Char:
            result = Expression.MakeConstant(type_name, '\0', loc);
			break;

		default:
			SemanticError("Error ES0030: Unknown object type");
			break;
		}
		
		return result;
	}

    AstType CreateType(string keyword, TextLocation loc, bool isReference)
    {
        AstType type = new PrimitiveType(keyword, loc);
        if(isReference)
            type = new ReferenceType(type, loc);

        return type;
    }

    LiteralExpression CreateLiteral(string value, TextLocation loc)
    {
        string type_name = "int";
        object obj = null;
        string suffix = value.Substring(value.Length - 1);
        string numerics = value.Replace("_", "");
        switch(suffix){
        case "u":
        case "U":
        {
            type_name = "uint";
            uint u;
            if(uint.TryParse(numerics.Substring(0, numerics.Length - 1), out u))
                obj = u;
            else
                SemanticError("Error ES0040: Invalid uint representation!");
            break;
        }

        case "l":
        case "L":
            type_name = "bigint";
            obj = BigInteger.Parse(numerics.Substring(0, numerics.Length - 1));
            break;

        case "f":
        case "F":
        {
            type_name = "float";
            float f;
            if(float.TryParse(numerics.Substring(0, numerics.Length - 1), out f))
                obj = f;
            else
                SemanticError("Error ES0050: Invalid float representation!");
            break; 
        }

        default:
        {
            double d;
            int i;
            if(int.TryParse(numerics, out i)){
                obj = i;
                type_name = "int";
            }else if(double.TryParse(numerics, out d)){
                obj = d;
                type_name = "double";
            }else{
                SemanticError("Error ES0051: Unknown sequence for numeric literals! Make sure that you write a number!");
            }
            break;
        }
        }

        return Expression.MakeConstant(type_name, obj, loc);
    }

    LiteralExpression HandleEscapes(string typeName, string literal, TextLocation loc)
    {
        string tmp = literal.Replace("\\n", "\n").Replace("\\r", "\r").Replace("\\t", "\t")
                            .Replace("\\v", "\v").Replace("\\f", "\f").Replace("\\0", "\0")
                            .Replace("\\b", "\b");
        tmp = UnicodeEscapeFinder.Replace(tmp, m => {
            return ((char)int.Parse(m.Value.Substring(2), NumberStyles.HexNumber)).ToString();
        });

        if(typeName == "char")
            return Expression.MakeConstant(typeName, Convert.ToChar(tmp), loc);
        else if(typeName == "string")
            return Expression.MakeConstant(typeName, tmp, loc);
        else
            throw new InvalidOperationException();
    }

    AstType ConvertPathToType(PathExpression path)
    {
        AstType type = null;
        foreach(var item in path.Items){
            item.Remove();
            if(type == null)
                type = AstType.MakeSimpleType(item, TextLocation.Empty);
            else
                type = AstType.MakeMemberType(type, AstType.MakeSimpleType(item, TextLocation.Empty), TextLocation.Empty);
        }

        return type;
    }

    SimpleType CreateTypeWithArgs(string typeName, params AstType[] typeArgs)
    {
        return new SimpleType(typeName, typeArgs, TextLocation.Empty, TextLocation.Empty);
    }

    bool IsPrimitiveGenericType(string name)
    {
        return name != null && (name == "dictionary" || name == "vector");
    }

    /// <summary>
    /// Creates a new <see ref="ICSharpCode.NRefactory.TextLocation">
    /// that points to the location n characters before the current.
    /// </summary>
    /// <remarks>
    /// It doesn't take line breaks into account.
    /// </remarks>
    TextLocation CreateLocationBefore(int n)
    {
        return new TextLocation(t.line, t.col - n);
    }

    void GoDownScope()
    {
        Symbols = Symbols.Children[Symbols.Children.Count - 1];
    }

    void GoUpScope()
    {
        Symbols = Symbols.Parent;
    }
	
	bool IsDefiningLValue()
	{
        return la.kind == _keyword_let || la.kind == _keyword_var;
	}
	
	bool IsSequenceInitializer()
	{
		Token x = la;
		if(x.kind != _comma)
            return true;
		
		while(x.kind != 0 && x.kind != _comma && x.kind != _keyword_for)
            x = scanner.Peek();

        scanner.ResetPeek();
        return x.kind != _keyword_for;
	}

    bool IsIdentifierPattern()
    {
        var la = this.la;
        var x = scanner.Peek();
        scanner.ResetPeek();
        return la.kind == _ident && x.kind != _double_colon && x.kind != _lcurly;
    }

    bool NotFinalComma()
    {
        var t = la;
        var tt = scanner.Peek();
        scanner.ResetPeek();
        return t.kind == _comma && tt.kind != _rparen && tt.kind != _rbracket && tt.kind != _triple_dots;
    }

    bool IsObjectCreation()
    {
        var t = la;
        if(t.kind != _lcurly && t.kind != _double_colon)
            return false;

        var x = t;
        while(x.kind == _ident || x.kind == _double_colon)
            x = scanner.Peek();

        if(x.kind != _lcurly){
            scanner.ResetPeek();
            return false;
        }

        var key = scanner.Peek();
        var tt = scanner.Peek();
        scanner.ResetPeek();
        return key.kind == _ident && tt.kind == _colon;
    }

    bool CheckKeyword(string name)
    {
        if(KnownTypeReference.Keywords.Contains(name)){
            SemanticError("Error ES0005: {0} is reserverd for a keyword.", name);
            return true;
        }

        return false;
    }

    /// <summary>
    /// Reports a semantical error message.
    /// It is intended to be used inside the Parser class.
    /// </summary>
	public void SemanticError(string format, params object[] args)
	{
		//Convenient method for printing a semantic error with a format string
		SemErr(string.Format(format, args));
	}

    /// <summary>
    /// Reports a warning message.
    /// It is intended to be used from outside the Parser class.
    /// </summary>
    public void ReportWarning(string format, AstNode node, params object[] objects)
    {
        errors.Warning(string.Format("{0} -- {1}", node.StartLocation, string.Format(format, objects)));
    }

    /// <summary>
    /// Reports a semantical error message.
    /// It is intended to be used from outside the Parser class.
    /// </summary>
    public void ReportSemanticError(string format, AstNode node, params object[] objects)
    {
        errors.SemErr(string.Format("{0} -- {1}", node.StartLocation, string.Format(format, objects)));
    }

    /// <summary>
    /// Reports a semantical error message 
    /// </summary>
    public void ReportSemanticErrorRegional(string format, AstNode start, AstNode end, params object[] objects)
    {
        var real_message = string.Format("{0} ~ {1} -- {2}", start.StartLocation, end.EndLocation, string.Format(format, objects));
        errors.SemErr(real_message);
    }
	
/*--------------------------------------------------------------------------*/
CHARACTERS
  letter = 'A'..'Z' + 'a'..'z'.
  digit = '0'..'9'.
  hex_letter = digit + 'a'..'f' + 'A'..'F'.
  cr  = '\r'.
  lf  = '\n'.
  tab = '\t'.
  backslash = '\\'.
  raw_prefix = 'r'.
  rawQuotedStringLetter = ANY - '"'.
  quotedStringLetter = ANY - '"' - '\\'.
  quotedLetter = ANY - '\'' - '\\'.
  dot = '.'.

TOKENS
  double_dots = "..".
  triple_dots = "...".
  rbracket = ']'.
  colon = ':'.
  double_colon = "::".
  semicolon = ';'.
  lcurly = '{'.
  lparen = '('.
  lbracket = '['.
  rparen = ')'.
  rcurly = '}'.
  comma = ','.
  dot = '.'.
  ident  = (letter | '_') {'_' | letter | digit}.
  integer = ( digit {digit | '_'} ['u' | 'U' | 'l' | 'L']
            | digit {digit | '_'} CONTEXT("..")   /*This context includes triple dots case*/
            ).
  float = ( digit {digit | '_'} dot [('e' | 'E') ['+' | '-'] digit {digit | '_'}]
  		  | [digit {digit | '_'}] dot digit {digit | '_'} [('e' | 'E') ['+' | '-'] digit {digit | '_'}]
          ) ['f' | 'F'].
  hex_digit = '0' ('x' | 'X') hex_letter {hex_letter}.
  unicode_escape = backslash ('u' | 'U') hex_letter hex_letter hex_letter hex_letter [hex_letter hex_letter].
  character_literal = '\''
                      [ quotedLetter
                      | backslash ( 'n' | 't' | 'r' | 'b' | 'f' | 'a' | backslash |
                        ('u' | 'U') hex_letter hex_letter hex_letter hex_letter [hex_letter hex_letter]
                        )
                      ]
                      '\''.
  string_literal = '"'
                   { quotedStringLetter
                   | backslash ( 'n' | 't' | 'r' | 'b' | 'f' | 'a' | backslash |
                     ('u' | 'U') hex_letter hex_letter hex_letter hex_letter [hex_letter hex_letter]
                     )
                   }
                   '"'.
  raw_string_literal = ( raw_prefix '"' {rawQuotedStringLetter} '"'
                       | raw_prefix '#' {'#'} '"' {rawQuotedStringLetter | '"'} '"' '#' {'#'}
                       ).
  keyword_if = "if".
  keyword_for = "for".
  keyword_in = "in".
  keyword_while = "while".
  keyword_match = "match".
  keyword_let = "let".
  keyword_var = "var".

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO lf

IGNORE cr + lf + tab



PRODUCTIONS
/*------------------------------------------------------------------------*/
Expresso                    		(. ExpressoAst module_decl = null;
                                       try{
                                    .)
= 
  ModuleBody<out module_decl>		(.
                                            Debug.Assert(Symbols.Parent.Name == "root");
                                            if(DoPostParseProcessing){
                                                CSharpCompilerHelper.Prepare();
                                                ExpressoNameBinder.BindAst(module_decl, this); //Here's the start of post-parse processing
                                            }
                                        }
                                        catch(ParserException e){
                                            SemanticError(e.Message);
                                        }
  										this.TopmostAst = module_decl;	//Currently there is not so much code out there, though...
  									.).
/*------------------------------------------------------------------------*/
ModuleBody<out ExpressoAst ast>	    (.  var decls = new List<EntityDeclaration>();
                                        string module_name; Modifiers modifiers = ExpressoModifiers.None;
										List<ImportDeclaration> prog_defs = null; EntityDeclaration decl = null;
									.)
=
  ModuleNameDefinition<out module_name>
  [ ProgramDefinition<out prog_defs>
  ]
  								
  [ "export"						(. modifiers = ExpressoModifiers.Export; .)
  ]
  ( FuncDecl<out decl, modifiers>
  | FieldDecl<out decl, modifiers>
  | ClassDecl<out decl, modifiers>
  )									(.  decls.Add(decl);
										modifiers = ExpressoModifiers.None;
									.)
  {
    [ "export"						(. modifiers = ExpressoModifiers.Export; .)
    ]
    ( FuncDecl<out decl, modifiers>
    | FieldDecl<out decl, modifiers>
    | ClassDecl<out decl, modifiers>
    )								(.  decls.Add(decl);
    									modifiers = ExpressoModifiers.None;
    								.)
  }									(.  ast = AstNode.MakeModuleDef(module_name, decls, prog_defs); .) .
/*------------------------------------------------------------------------*/
ModuleNameDefinition<out string moduleName>
=                               (. .)
  "module"
  ident                         (. moduleName = t.val; .)
  { '.'
    ident
  }
  SYNC ';'.
/*------------------------------------------------------------------------*/
ProgramDefinition<. out List<ImportDeclaration> imports .>	(. imports = new List<ImportDeclaration>();
                                                               ImportDeclaration tmp;
                                                            .)
=
  ImportDecl<out tmp>			(. imports.Add(tmp); .)
  { ImportDecl<out tmp>		    (. imports.Add(tmp); .)
  }.
/*------------------------------------------------------------------------*/
ImportDecl<out ImportDeclaration decl>
            (.  decl = null; /*var has_in = false; PathExpression path;*/ Identifier symbol = null;
				Identifier alias = null; var entities = new List<Identifier>();
			.)
=
  /*****************************
   * Do not add symbol names in external modules right here
   * because we can't figure out all names in those modules' scopes.
   *****************************/
  SYNC
  "import"
  string_literal                (.
                                   var path = t.val.Substring(1, t.val.Length - 2);
  								   symbol = AstNode.MakeIdentifier(path, CurrentLocation);
  								   Symbols.AddTypeSymbol(t.val, symbol);
  								   //entities.Add(symbol);
  								.)
  ( "as"
    ident						(.
    							   if(!CheckKeyword(t.val)){
    							       alias = AstNode.MakeIdentifier(t.val, CurrentLocation);
    							       Symbols.AddTypeSymbol(t.val, alias);
    							   }else{
    							       // Failed to parse an alias name.
    							       // Leave the parser to recover its state.
    							   }
    							.)
  )
  /*PathExpression<out path>      (. entities.Add(path); .)
  ( "as"
    ident						(.
                                   if(!CheckKeyword(t.val)){
                                       alias = AstNode.MakeIdentifier(t.val, CurrentLocation);
                                       Symbols.AddTypeSymbol(t.val, alias);
                                   }else{
                                       // Failed to parse an alias name.
                                       // Leave the parser to recover its state.
                                   }
                                .)
  | { WEAK ','
      PathExpression<out path>  (. entities.Add(path); .)
    }
    "in"                        (. has_in = true; .)
    PathExpression<out path>
  )*/
  SYNC ';'                      (. //if(has_in)
                                   //    decl = AstNode.MakeImportDecl(path, entities);
                                   //else
                                       decl = AstNode.MakeImportDecl(symbol, alias);
                                .).
/*------------------------------------------------------------------------*/
ClassDecl<out EntityDeclaration decl, Modifiers modifiers>   
  (.  EntityDeclaration entity = null; var decls = new List<EntityDeclaration>(); AstType type_path;
      string name; var bases = new List<AstType>(); Modifiers cur_flag; var start_loc = NextLocation;
      Identifier ident = null;
  .)
=
  SYNC
  "class"                               (. Symbols.AddScope(); .)
  ident				    				(. name = t.val;
                                           if(!CheckKeyword(name)){
                                               ident = AstNode.MakeIdentifier(name, CurrentLocation);
                                               Symbols.AddTypeSymbol(name, ident);
                                               cur_class_name = name;
                                           }else{
                                               // Failed to parse an identifier.
                                               // Leave the parser to recover its state.
                                           }
                                        .)
  [ ':'
    Type<out type_path>	                (. bases.Add(type_path); .)
    { ','
      Type<out type_path>	            (. bases.Add(type_path); .)
    }
  ]
  lcurly                                (. GoDownScope();
                                           Symbols.Name = "type_" + name + "`" + ScopeId++;
                                        .)
  {                                     (. cur_flag = ExpressoModifiers.Private; .)
    { Modifiers<ref cur_flag>
    }                                   (. //var tmp = cur_flag ^ ExpressoModifiers.Static;
                                           //tmp = tmp ^ ExpressoModifiers.VisibilityMask & ~ExpressoModifiers.Export;
                                           //if(tmp
                                        .)
    ( FuncDecl<out entity, cur_flag>    (. decls.Add(entity); .)
    | FieldDecl<out entity, cur_flag>	(. decls.Add(entity); .)
    | ClassDecl<out entity, cur_flag>   (. decls.Add(entity); .)
    )
  }
  SYNC rcurly							(. decl = EntityDeclaration.MakeClassDecl(ident, bases, decls, modifiers, start_loc, CurrentLocation);
                                           GoUpScope();
                                        .) .
/*------------------------------------------------------------------------*/
Modifiers<ref Modifiers modifiers>
=
  ( "public"                (. modifiers &= ~ExpressoModifiers.Private;
                               modifiers |= ExpressoModifiers.Public;
                            .)
  | "protected"             (. modifiers &= ~ExpressoModifiers.Private;
                               modifiers |= ExpressoModifiers.Protected;
                            .)
  | "private"               (. modifiers |= ExpressoModifiers.Private; .)
  | "static"                (. modifiers |= ExpressoModifiers.Static; .)
  ).
/*------------------------------------------------------------------------*/
FuncDecl<out EntityDeclaration decl, Modifiers modifiers>
                                (.  Identifier ident = null;
									string name; AstType type = null; BlockStatement block;
									var type_params = new List<ParameterType>();
									var @params = new List<ParameterDeclaration>();
                                    var start_loc = NextLocation;
                                    var replacer = new ParameterTypeReplacer(type_params);
								.)
=
  SYNC
  "def"                         (. Symbols.AddScope(); .)
  ident							(.
                                   name = t.val;
                                   if(!CheckKeyword(name)){
                                       ident = AstNode.MakeIdentifier(name, new PlaceholderType(TextLocation.Empty), CurrentLocation); 
                                       Symbols.AddSymbol(name, ident);
                                   }else{
                                       // The name is unsuitable for a method or a function name.
                                       // Leave the parser to recover its state.
                                   }
                                .)
 [ GenericTypeParameters<ref type_params> ]
  '('                           (. GoDownScope();
                                   Symbols.Name = "func " + name + "`" + ScopeId++;
                                .)
  [ParamList<type_params, ref @params>]
  ')'
  [ "->"
    Type<out type>
  ]                             (. if(type == null)
                                       type = new PlaceholderType(TextLocation.Empty);

                                   type.AcceptWalker(replacer);
                                .)
  Block<out block> 				(. decl = EntityDeclaration.MakeFunc(ident, @params, block, type, modifiers, start_loc);
                                   GoUpScope();
                                .).
/*------------------------------------------------------------------------*/
ParamList<. List<ParameterType> typeParams, ref List<ParameterDeclaration> @params .>
                                (. ParameterDeclaration param; bool seen_option = false; var replacer = new ParameterTypeReplacer(typeParams); .)
=
  Parameter<out param>          (.
                                   if(!param.Option.IsNull)
                                       seen_option = true;

                                   param.ReturnType.AcceptWalker(replacer);
                                   @params.Add(param);
                                .)
  { WEAK ','
    Parameter<out param>        (.
                                   if(seen_option && param.Option.IsNull)
                                       SemanticError("Error ES0002: You can't put optional parameters before non-optional parameters");
                                   else if(!seen_option && !param.Option.IsNull)
                                       seen_option = true;

                                   param.ReturnType.AcceptWalker(replacer);
                                   @params.Add(param);
                                .)
  }.
/*------------------------------------------------------------------------*/
Parameter<out ParameterDeclaration param>   (. string name; Identifier identifier; Expression option = null; AstType type = null; bool is_variadic = false; .)
=
  ident										(.
  												name = t.val;
  												if(CheckKeyword(name)){
  													// Failed to parse a name.
  													// Stop parsing parameters.
  													param = null;
  													return;
  												}
  											.)
  [ '='
    Literal<out option>                     
  | "..."									(. is_variadic = true; .)
  ]
  [ "(-"
    Type<out type>							(.
    										    if(is_variadic && la.kind == _ident)
    										    	SemanticError("Error ES0010: The variadic parameter has to be placed in the last position of a parameter list");
    										  	else if(is_variadic && (type == null || !(type is SimpleType) || ((SimpleType)type).Name != "array"))
    										  		SemanticError("Error ES0001: The variadic parameter must be an array!");
    										.)
  ]											(.
  												identifier = AstNode.MakeIdentifier(name, type);
  												if(identifier.Type is PlaceholderType && option == null)
  													SemanticError("Error ES0004: You can't imit both the type annotation and the default value!");

  												Symbols.AddSymbol(name, identifier);
  												param = EntityDeclaration.MakeParameter(identifier, option, is_variadic);
  											.).
/*------------------------------------------------------------------------*/
FieldDecl<out EntityDeclaration field, Modifiers modifiers>
  (. Expression rhs; Identifier ident; var start_loc = NextLocation;
     var idents = new List<Identifier>(); var exprs = new List<Expression>();
  .)
= 
  ( keyword_let                     (. modifiers |= ExpressoModifiers.Immutable; .)
  | keyword_var
  )
  VarDef<out ident, out rhs>        (.  
                                       idents.Add(ident);
                                       exprs.Add(rhs);
                                    .)  
  { ','
    VarDef<out ident, out rhs>      (.
                                       idents.Add(ident);
                                       exprs.Add(rhs);
                                    .)
  }
  SYNC ';'							(. field = EntityDeclaration.MakeField(idents, exprs, modifiers, start_loc, CurrentLocation); .).
/*------------------------------------------------------------------------*/
GenericTypeParameters<. ref List<ParameterType> types .>
=
  '<'
  ident												(. types.Add(AstType.MakeParameterType(t.val)); .)
  { ','
    ident											(. types.Add(AstType.MakeParameterType(t.val)); .)
  }
  '>'.
/*------------------------------------------------------------------------*/
Type<out AstType type>				(. var start_loc = NextLocation; type = new PlaceholderType(NextLocation);
       								   var is_reference = false; string name = null;
    								.)
=
 [ '&'                              (. is_reference = true; .)
 ]
 ( "int"                			(. type = CreateType(t.val, start_loc, is_reference); .)
 | "uint"                           (. type = CreateType(t.val, start_loc, is_reference); .)
 | "bool"               			(. type = CreateType(t.val, start_loc, is_reference); .)
 | "float"							(. type = CreateType(t.val, start_loc, is_reference); .)
 | "double"                         (. type = CreateType(t.val, start_loc, is_reference); .)
 | "bigint"							(. type = CreateType(t.val, start_loc, is_reference); .)
 | "string"							(. type = CreateType(t.val, start_loc, is_reference); .)
 | "byte"						    (. type = CreateType(t.val, start_loc, is_reference); .)
 | "char"                           (. type = CreateType(t.val, start_loc, is_reference); .)
 | TupleTypeSignature<out type>
 | "vector"							(. name = t.val; .)
 | "dictionary"						(. name = t.val; .)
 | "function"						(. type = CreateType(t.val, start_loc, is_reference); .)
 | "intseq"							(. type = CreateType(t.val, start_loc, is_reference); .)
 | "void"							(. type = AstType.MakeSimpleType("tuple", Enumerable.Empty<AstType>(), start_loc, CurrentLocation); .)
 | TypePathExpression<out type>     (. if(is_reference) type = AstType.MakeReferenceType(type, TextLocation.Empty); .)
 )                                  (. start_loc = NextLocation; .)
 [ GenericTypeSignature<name, is_reference, start_loc, out type>
                                    (.
                                        if(!IsPrimitiveGenericType(name)){
                                            SemanticError("Error ES0006: `{0}` is not a generic type!", name);
                                            return;
                                        }
                                    .)
 ]
 /* Split brackets into 2 tokens that represent the array type
    because otherwise it conflicts with the array literal.
 */
 { '[' ']'                          (. if(type.IsNull)
                                           SemanticError("Error ES0007: Array of unknown type is specified. Unknown type is just unknown!");
                
                                       type = AstType.MakeSimpleType("array", new []{type}, start_loc, CurrentLocation);
                                    .)
 }.
/*------------------------------------------------------------------------*/
TupleTypeSignature<out AstType type> (. var inners = new List<AstType>(); var start_loc = NextLocation; .)
=
  '('
  [ Type<out type>					(. inners.Add(type); .)
  ]
  { ','
    Type<out type>                  (. inners.Add(type); .)
  }
  ')'                               (. type = AstType.MakeSimpleType("tuple", inners, start_loc, CurrentLocation); .).
/*------------------------------------------------------------------------*/
GenericTypeSignature<string name, bool isReference, TextLocation startLoc, out AstType genericType> 
                                    (. var type_args = new List<AstType>(); AstType child_type; .)
=
  '<'
  Type<out child_type>              (. type_args.Add(child_type); .)
  { ','
    Type<out child_type>            (. type_args.Add(child_type); .)
  }
  '>'                               (.
                                       genericType = AstType.MakeSimpleType(name, type_args, startLoc, CurrentLocation);
                                       if(isReference)
                                       	   genericType = AstType.MakeReferenceType(genericType, CurrentLocation);
                                    .).
/*------------------------------------------------------------------------*/
Stmt<out Statement stmt>			(. stmt = null; .)
=
  SimpleStmt<out stmt>
  | CompoundStmt<out stmt> .
/*------------------------------------------------------------------------*/
SimpleStmt<out Statement stmt>		(. stmt = null; BlockStatement block = null; .)
=
  Block<out block>                  (. stmt = block; .)
  | ExprStmt<out stmt>
  | VarDeclStmt<out stmt>
  | ReturnStmt<out stmt>
  | BreakStmt<out stmt>
  | ContinueStmt<out stmt>
  | YieldStmt<out stmt>
  | ThrowStmt<out stmt>
  | EmptyStmt<out stmt>.
/*------------------------------------------------------------------------*/
ReturnStmt<out Statement stmt>		(. SequenceExpression items = null; .)
=
  "return"
  [RValueList<out items>]
  SYNC ';'							(. stmt = Statement.MakeReturnStmt(items); .).
/*------------------------------------------------------------------------*/
BreakStmt<out Statement stmt>		(. int count = 1; var start_loc = NextLocation; .)
=
  "break"
  [ "upto"
    integer							(. count = Convert.ToInt32(t.val); .)
  ]
  SYNC ';' 							(. stmt = Statement.MakeBreakStmt(
                                           Expression.MakeConstant("int", count, start_loc), start_loc, CurrentLocation
                                       );
                                    .).
/*------------------------------------------------------------------------*/
ContinueStmt<out Statement stmt>	(. int count = 1; var start_loc = NextLocation; .)
= 
  "continue"
  [ "upto"
    integer							(. count = Convert.ToInt32(t.val); .)
  ]
  SYNC ';' 							(. stmt = Statement.MakeContinueStmt(
                                           Expression.MakeConstant("int", count, start_loc), start_loc, CurrentLocation
                                       );
                                    .).
/*------------------------------------------------------------------------*/
YieldStmt<out Statement stmt>		(. Expression expr; var start_loc = NextLocation; .)
=
  "yield"
  CondExpr<out expr>
  SYNC ';'							(. stmt = Statement.MakeYieldStmt(expr, start_loc, CurrentLocation); .).
/*------------------------------------------------------------------------*/
ThrowStmt<out Statement stmt>       (. Expression obj; var start_loc = NextLocation; AstType type_path; .)
=
  "throw"
  Type<out type_path>
  ObjectCreation<type_path, out obj>
  SYNC ';'                          (. stmt = Statement.MakeThrowStmt((ObjectCreationExpression)obj, start_loc); .).
/*------------------------------------------------------------------------*/
EmptyStmt<out Statement stmt>       (. var start_loc = NextLocation; .)
=
  SYNC ';'							(. stmt = Statement.MakeEmptyStmt(start_loc); .).
/*------------------------------------------------------------------------*/
AugAssignOpe<ref OperatorType type>
=
  ( "+="							(. type = OperatorType.Plus; .)
  | "-="							(. type = OperatorType.Minus; .)
  | "*="							(. type = OperatorType.Times; .)
  | "/="							(. type = OperatorType.Divide; .)
  | "**="							(. type = OperatorType.Power; .)
  | "%="							(. type = OperatorType.Modulus; .)
  | "&="							(. type = OperatorType.BitwiseAnd; .)
  | "|="							(. type = OperatorType.BitwiseOr; .)
  | "<<="							(. type = OperatorType.BitwiseShiftLeft; .)
  | ">>="							(. type = OperatorType.BitwiseShiftRight; .)
  ).
/*------------------------------------------------------------------------*/
ExprStmt<out Statement stmt>			(.  SequenceExpression lhs = null, seq = null;
											var start_loc = NextLocation; stmt = null;
											OperatorType op_type = OperatorType.None;
                                            AssignmentExpression assign = null;
										.)
=
  LValueList<out lhs>
  [ ( AugAssignOpe<ref op_type>
      RValueList<out seq>                 
    )                                   (.  if(lhs.Count != seq.Count)  //See if both sides have the same number of items or not
                                                SemanticError("Error ES0007: An augmented assignment must have both sides balanced.");

                                            stmt = Statement.MakeAugmentedAssignment(op_type, lhs, seq, start_loc, CurrentLocation);
                                        .)
  | ( '='
      RValueList<out seq>               (. assign = Expression.MakeAssignment(lhs, seq); .)
      { '='
        RValueList<out seq>             (. assign = Expression.MakeMultipleAssignment(assign, seq); .)
      }								    (. stmt = Statement.MakeExprStmt(assign, start_loc, CurrentLocation); .)
    )
  ]
  SYNC ';' 								(.  if(stmt == null)
  												stmt = Statement.MakeExprStmt(lhs, start_loc, CurrentLocation);
  										.).
/*------------------------------------------------------------------------*/
LValueList<out SequenceExpression lhs>   (. var lvalues = new List<Expression>(); Expression tmp; .)
=
  LhsPrimary<out tmp>                    (. lvalues.Add(tmp); .)
  { WEAK ','
    LhsPrimary<out tmp>                  (. lvalues.Add(tmp); .)
  }                                      (. lhs = Expression.MakeSequenceExpression(lvalues); .).
/*------------------------------------------------------------------------*/
Block<out BlockStatement block>  (. List<Statement> stmts = new List<Statement>();
                   					Statement stmt; var start_loc = NextLocation;
                   					Symbols.AddScope();
                				 .)
=
  lcurly                    	 (. GoDownScope();
                               		Symbols.Name = "block`" + ScopeId++;
                            	 .)
  Stmt<out stmt>				 (. stmts.Add(stmt); .)
  { Stmt<out stmt>				 (. stmts.Add(stmt); .)
  }
  SYNC rcurly 					 (. block = Statement.MakeBlock(stmts, start_loc, CurrentLocation);
                               	 	GoUpScope();
                            	 .).
/*------------------------------------------------------------------------*/
CompoundStmt<out Statement stmt>	(. stmt = null; .)
=
    IfStmt<out stmt>					
  | WhileStmt<out stmt>
  | ForStmt<out stmt>
  | MatchStmt<out stmt>.
/*------------------------------------------------------------------------*/
IfStmt<out Statement stmt>			(. PatternConstruct pattern = null; BlockStatement true_block, false_block = null;
                                       var start_loc = NextLocation;
                                    .)
=
  keyword_if                        (. Symbols.AddScope();
                                       GoDownScope();
                                       Symbols.Name = "if`" + ScopeId++;
                                    .)
  ( ExpressionPattern<out pattern>
  | ValueBindingPattern<out pattern>
  )
  Block<out true_block>
  [ "else"
    Block<out false_block>
  ]                      			(. stmt = Statement.MakeIfStmt(pattern, true_block, false_block, start_loc);
                                       GoUpScope();
                                    .).
/*------------------------------------------------------------------------*/
WhileStmt<out Statement stmt>		(. Expression cond; BlockStatement body; var start_loc = NextLocation; .)
=
  "while"                           (.
                                       Symbols.AddScope();
                                       GoDownScope();
                                       Symbols.Name = "while`" + ScopeId++;
                                    .)
  CondExpr<out cond>
  Block<out body>                   (.
                                       stmt = Statement.MakeWhileStmt(cond, body, start_loc);
                                       GoUpScope();
                                    .).
/*------------------------------------------------------------------------*/
ForStmt<out Statement stmt>			(. PatternConstruct left = null; Expression rvalue; BlockStatement body; Identifier ident = null; Modifiers modifiers = ExpressoModifiers.None;
                                       var start_loc = NextLocation;
									.)
=
  keyword_for                       (. Symbols.AddScope();
                                       GoDownScope();
                                       Symbols.Name = "for`" + ScopeId++;
                                    .)
  ( ( keyword_let					(. modifiers = ExpressoModifiers.Immutable; .)
    | keyword_var
    )
    Identifier<out ident>			(. Symbols.AddSymbol(ident.Name, ident); .)
  | LhsPattern<out left>
  )
  keyword_in
  CondExpr<out rvalue>
  Block<out body>					(.
  									   if(ident != null){
  									       var initializer = AstNode.MakeVariableInitializer(ident, rvalue);
  									       stmt = Statement.MakeValueBindingForStmt(modifiers, body, initializer);
  									   }else{
  									       stmt = Statement.MakeForStmt(left, rvalue, body, start_loc);
  									   }
                                       GoUpScope();
                                    .).
/*------------------------------------------------------------------------*/
MatchStmt<out Statement stmt>		(. Expression target; List<MatchPatternClause> matches;
                                       var start_loc = NextLocation;
                                    .)
=
  keyword_match
  CondExpr<out target>
  lcurly                            (. Symbols.AddScope();
                                       GoDownScope();
                                       Symbols.Name = "match`" + ScopeId++;
                                    .)
  MatchPatternList<out matches>
  rcurly							(. stmt = Statement.MakeMatchStmt(target, matches, start_loc, CurrentLocation);
                                       GoUpScope();
                                    .).
/*------------------------------------------------------------------------*/
MatchPatternList<. out List<MatchPatternClause> clauses .>
                                             (. clauses = new List<MatchPatternClause>(); List<PatternConstruct> pattern_list;
                                                Statement inner; Expression guard;
                                                Symbols.AddScope();
                                                GoDownScope();
                                                Symbols.Name = "arm`" + ScopeId++;
                                             .)
=
  PatternList<out pattern_list, out guard>
  Stmt<out inner>					         (. clauses.Add(Statement.MakeMatchClause(pattern_list, guard, inner));
                                                GoUpScope();
                                             .)
  { ','                                      (. Symbols.AddScope();
                                                GoDownScope();
                                                Symbols.Name = "arm`" + ScopeId++;
                                             .)
    PatternList<out pattern_list, out guard> 
    Stmt<out inner>					         (. clauses.Add(Statement.MakeMatchClause(pattern_list, guard, inner));
                                                GoUpScope();
                                             .)
  }.
/*------------------------------------------------------------------------*/
PatternList<. out List<PatternConstruct> patterns, out Expression guard .>
                        (. patterns = new List<PatternConstruct>(); PatternConstruct tmp; guard = null; .)
=
  Pattern<out tmp>                  (. patterns.Add(tmp); .)
  { SYNC '|'
    Pattern<out tmp>				(. patterns.Add(tmp); .)
  }
  [ keyword_if
    CondExpr<out guard>
  ]
  "=>".
/*------------------------------------------------------------------------*/
VarDeclStmt<out Statement stmt>        (. Expression rhs = null; var start_loc = NextLocation;
								          Identifier ident; var modifiers = ExpressoModifiers.None;
								          var idents = new List<Identifier>(); var exprs = new List<Expression>();
								       .)
= 
  ( "let"                              (. modifiers = ExpressoModifiers.Immutable; .)
  | "var"
  )
  VarDef<out ident, out rhs>	       (. idents.Add(ident);
  						 			      exprs.Add(rhs ?? Expression.Null);
  						 			      rhs = null;
  						 		       .)
  { WEAK ','
    VarDef<out ident, out rhs>         (. idents.Add(ident);
  									      exprs.Add(rhs ?? Expression.Null);
  									      rhs = null;
  								       .)
  }
  SYNC ';'							   (. stmt = Statement.MakeVarDecl(idents, exprs, modifiers, start_loc, CurrentLocation); .).
/*------------------------------------------------------------------------*/
VarDef<out Identifier ident, out Expression option> (. option = null; .)
=
  Identifier<out ident>			(. Symbols.AddSymbol(ident.Name, ident); .)
  [ '='
    CondExpr<out option>
  ]                            (. if(ident.Type is PlaceholderType && option == null)
                                      SemanticError("Error ES0003: Give me some context or I can't infer the type of {0}", ident.Name);
                               .).
/*------------------------------------------------------------------------*/
PatternVarDef<out VariableInitializer init> (. Identifier ident; Expression expr = null; .)
=
  Identifier<out ident>
  [ '='
    PatternOrTest<out expr>
  ]                                         (. init = AstNode.MakeVariableInitializer(ident, expr); .).
/*------------------------------------------------------------------------*/
RValueList<out SequenceExpression seq>		(. Expression tmp; var exprs = new List<Expression>(); .)
=
  CondExpr<out tmp>							(. exprs.Add(tmp); .)
  { ','
    CondExpr<out tmp>						(. exprs.Add(tmp);	.)
  }											(. seq = Expression.MakeSequenceExpression(exprs); .).
/*------------------------------------------------------------------------*/
Pattern<out PatternConstruct pattern>       (. pattern = null; .)
=
  WildcardPattern<out pattern>
  | TuplePattern<out pattern>
  | IF(IsIdentifierPattern())
    IdentifierPattern<out pattern>
  | DestructuringPattern<out pattern>
  | RValuePattern<out pattern>.
/*------------------------------------------------------------------------*/
ValueBindingPattern<out PatternConstruct pattern>
                                (. VariableInitializer init; var modifier = ExpressoModifiers.None; .)
=
  ( keyword_let                 (. modifier = ExpressoModifiers.Immutable; .)
  | keyword_var
  )                             (. var inits = new List<VariableInitializer>(); .)
  PatternVarDef<out init>       (. inits.Add(init); .)
  { ','
    PatternVarDef<out init>     (. inits.Add(init); .)
  }                             (. pattern = PatternConstruct.MakeValueBindingPattern(inits, modifier); .).
/*------------------------------------------------------------------------*/
ExpressionPattern<out PatternConstruct pattern> (. Expression expr; .)
=
  PatternOrTest<out expr>                       (. pattern = PatternConstruct.MakeExpressionPattern(expr); .).
/*------------------------------------------------------------------------*/
RValuePattern<out PatternConstruct pattern>     (. Expression expr; .)
=
  LiteralIntSeqExpr<out expr>                   (. pattern = PatternConstruct.MakeExpressionPattern(expr); .).
/*------------------------------------------------------------------------*/
LhsPattern<out PatternConstruct pattern>    (. pattern = PatternConstruct.Null; .)
=
  WildcardPattern<out pattern>
  | ValueBindingPattern<out pattern>
  | IF(IsIdentifierPattern())
    IdentifierPattern<out pattern>
  | TuplePattern<out pattern>
  | DestructuringPattern<out pattern>.
/*------------------------------------------------------------------------*/
WildcardPattern<out PatternConstruct pattern>
=
  '_'                               (. pattern = PatternConstruct.MakeWildcardPattern(); .).
/*------------------------------------------------------------------------*/
IdentifierPattern<out PatternConstruct pattern> (. PatternConstruct inner = null; string name; AstType type = new PlaceholderType(TextLocation.Empty); .)
=
  ident                             (.
                                       name = t.val;
                                       var ident = AstNode.MakeIdentifier(name, type, CurrentLocation);
                                       Symbols.AddSymbol(name, ident);
                                    .)
  [ '@'
    Pattern<out inner>
  ]                                 (. pattern = PatternConstruct.MakeIdentifierPattern(ident, inner); .).
/*------------------------------------------------------------------------*/
TuplePattern<out PatternConstruct pattern>  (. var inners = new List<PatternConstruct>(); .)
=
  '('
  { ( LhsPattern<out pattern>
    | ExpressionPattern<out pattern>
    | ".."                                  (. pattern = PatternConstruct.MakeIgnoringRestPattern(CurrentLocation); .)
    )                                       (. inners.Add(pattern); .)
    ','
  }
  ')'                                       (. pattern = PatternConstruct.MakeTuplePattern(inners); .).
/*------------------------------------------------------------------------*/
DestructuringPattern<out PatternConstruct pattern>  
                (. pattern = PatternConstruct.Null; AstType type_path;
                   var patterns = new List<PatternConstruct>(); bool is_vector = false;
                .)
=
  ( TypePathExpression<out type_path>
    lcurly
    [ Pattern<out pattern>                  (. patterns.Add(pattern); .)
    ]
    { ','
      ( Pattern<out pattern>                (. patterns.Add(pattern); .)
      | ".."                                (. patterns.Add(PatternConstruct.MakeIgnoringRestPattern(CurrentLocation)); .)
      )
    }
    rcurly                                  (. pattern = PatternConstruct.MakeDestructuringPattern(type_path, patterns); .)
  | '['
    [ Pattern<out pattern>                  (. patterns.Add(pattern); .)
    ]
    { IF(NotFinalComma()) WEAK ','
      Pattern<out pattern>                  (. patterns.Add(pattern); .)
    }
    [ ','
      "..."                                 (. is_vector = true; .)
    ]
    ']'                                     (. pattern = PatternConstruct.MakeCollectionPattern(patterns, is_vector); .)
  ).
/*------------------------------------------------------------------------*/
CondExpr<out Expression expr>		(. Expression true_expr, false_expr; .)
=
  OrTest<out expr>
  [ '?'
    OrTest<out true_expr>
    ':'
    CondExpr<out false_expr>		(. expr = Expression.MakeCondExpr(expr, true_expr, false_expr); .)
  ].
/*------------------------------------------------------------------------*/
OrTest<out Expression expr>			(. Expression rhs; .)
=
  AndTest<out expr>
  [ "||"
    OrTest<out rhs>                 (. expr = Expression.MakeBinaryExpr(OperatorType.ConditionalOr, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
AndTest<out Expression expr>		(. Expression rhs; .)
=
  Comparison<out expr>
  [ "&&"
    AndTest<out rhs>				(. expr = Expression.MakeBinaryExpr(OperatorType.ConditionalAnd, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
Comparison<out Expression expr>	    (. Expression rhs; OperatorType type; .)
=
  IntSeqExpr<out expr>				(. type = OperatorType.Equality; .)
  [ ComparisonOperator<out type>
    Comparison<out rhs>			    (. expr = Expression.MakeBinaryExpr(type, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
ComparisonOperator<out OperatorType opType> (. opType = OperatorType.None; .)
=
  ( "=="                    (. opType = OperatorType.Equality; .)
  | "!="                    (. opType = OperatorType.InEquality; .)
  | '<'                     (. opType = OperatorType.LessThan; .)
  | '>'                     (. opType = OperatorType.GreaterThan; .)
  | "<="                    (. opType = OperatorType.LessThanOrEqual; .)
  | ">="                    (. opType = OperatorType.GreaterThanOrEqual; .)
  ).
/*------------------------------------------------------------------------*/
IntSeqExpr<out Expression expr>     (. Expression start = null, end = null, step = null;
                                       bool upper_inclusive = true;
                                    .)
=
  BitOr<out start>                  (. expr = start; .)
  [ RangeOperator<ref upper_inclusive>
    BitOr<out end>
    [ ':'
      BitOr<out step>
    ]                               (. if(step == null) step = Expression.MakeConstant("int", 1, TextLocation.Empty);
                                       expr = Expression.MakeIntSeq(start, end, step, upper_inclusive);
                                    .)
  ].
/*------------------------------------------------------------------------*/
RangeOperator<ref bool upper_inclusive>
=
  ( ".."                                (. upper_inclusive = false; .)
  | "..."                               (. upper_inclusive = true; .)
  ).
/*------------------------------------------------------------------------*/
BitOr<out Expression expr>			(. Expression rhs; .)
=
  BitXor<out expr>
  [ '|'
    BitOr<out rhs>					(. expr = Expression.MakeBinaryExpr(OperatorType.BitwiseOr, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
BitXor<out Expression expr>			(. Expression rhs; .)
=
  BitAnd<out expr>
  [ '^'
    BitXor<out rhs>					(. expr = Expression.MakeBinaryExpr(OperatorType.ExclusiveOr, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
BitAnd<out Expression expr>			(. Expression rhs; .)
=
  ShiftOp<out expr>
  [ '&'
    BitAnd<out rhs> 			    (. expr = Expression.MakeBinaryExpr(OperatorType.BitwiseAnd, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
ShiftOp<out Expression expr>		(. Expression rhs; OperatorType type; .)
=
  AddOp<out expr>
  [ ShiftOperator<out type>
    ShiftOp<out rhs>				 (. expr = Expression.MakeBinaryExpr(type, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
ShiftOperator<out OperatorType opType>  (. opType = OperatorType.None; .)
=
  ( "<<"                            (. opType = OperatorType.BitwiseShiftLeft; .)
  | ">>"                            (. opType = OperatorType.BitwiseShiftRight; .)
  ).
/*------------------------------------------------------------------------*/
AddOp<out Expression expr>    		(. Expression rhs; OperatorType type; .)
= 
  Term<out expr>
  [ AdditiveOperator<out type>
    AddOp<out rhs>					(. expr = Expression.MakeBinaryExpr(type, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
AdditiveOperator<out OperatorType opType>   (. opType = OperatorType.None; .)
=
  ( '+'                             (. opType = OperatorType.Plus; .)
  | '-'                             (. opType = OperatorType.Minus; .)
  ).
/*------------------------------------------------------------------------*/
Term<out Expression expr>       (. Expression rhs; OperatorType type; .)
= 
  PowerOp<out expr>
  [ MultiplicativeOperator<out type>
    Term<out rhs>		        (. expr = Expression.MakeBinaryExpr(type, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
MultiplicativeOperator<out OperatorType opType>
                            (. opType = OperatorType.None; .)
=
  ( '*'                     (. opType = OperatorType.Times; .)
  | '/'                     (. opType = OperatorType.Divide; .)
  | '%'                     (. opType = OperatorType.Modulus; .)
  ).
/*------------------------------------------------------------------------*/
PowerOp<out Expression expr>   (. Expression rhs; .)
= 
  Factor<out expr>
  [ "**"
    Factor<out rhs>            (. expr = Expression.MakeBinaryExpr(OperatorType.Power, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
Factor<out Expression expr> (. OperatorType type; Expression factor; expr = null; var start_loc = CurrentLocation; .)
=
  ( Primary<out expr>
  | UnaryOperator<out type>
    Factor<out factor>        (. expr = Expression.MakeUnaryExpr(type, factor, start_loc); .)
  ).
/*------------------------------------------------------------------------*/
UnaryOperator<out OperatorType opType>  (. opType = OperatorType.None; .)
=
  ( AdditiveOperator<out opType>
  | '!'                             (. opType = OperatorType.Not; .)
  | '&'                             (. opType = OperatorType.Reference; .)
  | '*'                             (. opType = OperatorType.Dereference; .)
  ).
/*------------------------------------------------------------------------*/
Primary<out Expression expr>		    (. expr = null; PathExpression path; AstType type_path = null; .)
=
  ( PathExpression<out path>            (. expr = path; .) /* It's possible that a PathExpression turns out to be just an identifier */
    [ IF(IsObjectCreation())            (. type_path = ConvertPathToType(path); .)
      ObjectCreation<type_path, out expr>
    ]
  | Atom<out expr>
  )
  { Trailer<ref expr>
  }.
/*------------------------------------------------------------------------*/
PatternOrTest<out Expression expr>    (. Expression rhs; .)
=
  PatternAndTest<out expr>
  [ "||"
    PatternOrTest<out rhs>            (. expr = Expression.MakeBinaryExpr(OperatorType.ConditionalOr, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
PatternAndTest<out Expression expr>   (. Expression rhs; .)
=
  PatternComparison<out expr>
  [ "&&"
    PatternAndTest<out rhs>           (. expr = Expression.MakeBinaryExpr(OperatorType.ConditionalAnd, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
PatternComparison<out Expression expr>     (. Expression rhs; OperatorType type = OperatorType.None; .)
=
  PatternIntSeqExpr<out expr>
  [ ComparisonOperator<out type>
    PatternComparison<out rhs>             (. expr = Expression.MakeBinaryExpr(type, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
PatternIntSeqExpr<out Expression expr> (. Expression start = null, end = null, step = null;
                                          bool upper_inclusive = true;
                                       .)
=
  PatternBitOr<out start>              (. expr = start; .)
  [ RangeOperator<ref upper_inclusive>
    PatternBitOr<out end>
    [ ':'
      PatternBitOr<out step>
    ]                                  (. if(step == null) step = Expression.MakeConstant("int", 1, TextLocation.Empty);
                                          expr = Expression.MakeIntSeq(start, end, step, upper_inclusive);
                                       .)
  ].
/*------------------------------------------------------------------------*/
PatternBitOr<out Expression expr>   (. Expression rhs; .)
=
  PatternBitXor<out expr>
  [ '|'
    PatternBitOr<out rhs>           (. expr = Expression.MakeBinaryExpr(OperatorType.BitwiseOr, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
PatternBitXor<out Expression expr>  (. Expression rhs; .)
=
  PatternBitAnd<out expr>
  [ '^'
    PatternBitXor<out rhs>          (. expr = Expression.MakeBinaryExpr(OperatorType.ExclusiveOr, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
PatternBitAnd<out Expression expr>  (. Expression rhs; .)
=
  PatternShiftOp<out expr>
  [ '&'
    PatternBitAnd<out rhs>          (. expr = Expression.MakeBinaryExpr(OperatorType.BitwiseAnd, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
PatternShiftOp<out Expression expr> (. Expression rhs; OperatorType type; .)
=
  PatternAddOp<out expr>
  [ ShiftOperator<out type>
    PatternShiftOp<out rhs>         (. expr = Expression.MakeBinaryExpr(type, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
PatternAddOp<out Expression expr>   (. Expression rhs; OperatorType type; .)
= 
  PatternTerm<out expr>
  [ AdditiveOperator<out type>
    PatternAddOp<out rhs>           (. expr = Expression.MakeBinaryExpr(type, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
PatternTerm<out Expression expr>    (. Expression rhs; OperatorType type; .)
= 
  PatternPowerOp<out expr>
  [ MultiplicativeOperator<out type>
    PatternTerm<out rhs>            (. expr = Expression.MakeBinaryExpr(type, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
PatternPowerOp<out Expression expr> (. Expression rhs; .)
= 
  PatternFactor<out expr>
  [ "**"
    PatternFactor<out rhs>          (. expr = Expression.MakeBinaryExpr(OperatorType.Power, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
PatternFactor<out Expression expr>  (. OperatorType type; Expression factor; expr = null; var start_loc = CurrentLocation; .)
=
  ( PatternPrimary<out expr>
  | UnaryOperator<out type>
    PatternFactor<out factor>       (. expr = Expression.MakeUnaryExpr(type, factor, start_loc); .)
  ).
/*------------------------------------------------------------------------*/
PatternPrimary<out Expression expr>     (. expr = null; PathExpression path; .)
=
  ( PathExpression<out path>            (. expr = path; .) /* It's possible that a PathExpression turns out to be just an identifier */
  | Literal<out expr>
  )
  { Trailer<ref expr>
  }.
/*------------------------------------------------------------------------*/
LhsPrimary<out Expression expr>     (. expr = null; PathExpression path; .)
=
  PathExpression<out path>          (. expr = path; .)
  { Trailer<ref expr>
  }.
/*------------------------------------------------------------------------*/
LiteralIntSeqExpr<out Expression expr>  (. Expression start = null, end = null, step = null; bool upper_inclusive = false; .)
=
  Literal<out start>                    (. expr = start; .)
  [ RangeOperator<ref upper_inclusive>
    Literal<out end>
    [ ':'
      Literal<out step>
    ]                                   (. if(step == null)
                                               step = Expression.MakeConstant("int", 1, TextLocation.Empty);

                                           expr = Expression.MakeIntSeq(start, end, step, upper_inclusive);
                                        .)
  ].
/*------------------------------------------------------------------------*/
ObjectCreation<AstType typePath, out Expression expr>
                                        (.
                                           var fields = new List<Identifier>(); var values = new List<Expression>(); var start_loc = CurrentLocation;
                                           /*Symbols.AddScope();
                                           GoDownScope();
                                           Symbols.Name = "ObjectCreation`" + ScopeId++;*/
                                        .)
=
  lcurly
  ident                                 (. fields.Add(AstNode.MakeIdentifier(t.val, CurrentLocation)); .)
  ':'
  CondExpr<out expr>                    (. values.Add(expr); .)
  { ','
    ident                               (. fields.Add(AstNode.MakeIdentifier(t.val, CurrentLocation)); .)
    ':'
    CondExpr<out expr>                  (. values.Add(expr); .)
  }
  SYNC '}'                              (.
                                           expr = Expression.MakeObjectCreation(typePath, fields, values, start_loc, CurrentLocation);
                                           //GoUpScope();
                                        .).
/*------------------------------------------------------------------------*/
Trailer<ref Expression expr>	(. var args = new List<Expression>(); var start_loc = CurrentLocation; .)
=
  '('
  [ArgList<out args>]
  ')'							(. expr = Expression.MakeCallExpr(expr, args, CurrentLocation); .)
  | '['
    ArgList<out args>
    ']'							(. expr = Expression.MakeIndexer(expr, args, CurrentLocation); .)
  | '.'
    ident						(. expr = Expression.MakeMemRef(expr, AstNode.MakeIdentifier(t.val, new PlaceholderType(TextLocation.Empty), start_loc, CurrentLocation)); .).
/*------------------------------------------------------------------------*/
ArgList<. out List<Expression> args .>		(. args = new List<Expression>(); Expression expr; .)
=
  CondExpr<out expr>						(. args.Add(expr); .)
  { ','
    CondExpr<out expr>						(. args.Add(expr); .)
  }.
/*------------------------------------------------------------------------*/
Atom<out Expression expr>			(. var exprs = new List<Expression>(); expr = null; bool seen_trailing_comma = false; .)
=
  Literal<out expr>
  | '('
    ( ')'                           (. expr = Expression.MakeParen(Expression.MakeSequenceExpression(null)); .)
    | CondExpr<out expr>            (. exprs.Add(expr); .)
      { IF(NotFinalComma()) WEAK ','
        CondExpr<out expr>          (. exprs.Add(expr); .)
      }
      [ ','                         (. seen_trailing_comma = true; .)
      ]
      ')'                           (. if(exprs.Count == 1)
                                           expr = Expression.MakeParen(seen_trailing_comma ? Expression.MakeSequenceExpression(exprs[0]) : exprs[0]);
                                       else
                                           expr = Expression.MakeParen(Expression.MakeSequenceExpression(exprs));
                                    .)
    )
  | '['
    [SequenceMaker<out expr>]
    SYNC ']'						(.  if(expr == null){
                                            var type = CreateTypeWithArgs("array", new PlaceholderType(TextLocation.Empty));
    										expr = Expression.MakeSequenceInitializer(type, Enumerable.Empty<Expression>());
                                        }
    								.)
  | lcurly
    [DictMaker<out expr>]
    SYNC rcurly                     (. if(expr == null){
                                           var type = CreateTypeWithArgs("dictionary", new PlaceholderType(TextLocation.Empty), new PlaceholderType(TextLocation.Empty));
                                           expr = Expression.MakeSequenceInitializer(type, Enumerable.Empty<Expression>());
                                       }
                                    .).
/*------------------------------------------------------------------------*/
TypePathExpression<out AstType type>
=
  ident        (. type = AstType.MakeSimpleType(t.val, CurrentLocation); .)
  { "::"
    ident      (.
                  type = AstType.MakeMemberType(type, AstType.MakeSimpleType(t.val, CurrentLocation), NextLocation);
               .)
  }.
/*------------------------------------------------------------------------*/
PathExpression<out PathExpression path> (. var paths = new List<Identifier>(); .)
=
  ident                                 (.
  										   var ident = AstNode.MakeIdentifier(t.val, new PlaceholderType(TextLocation.Empty), CurrentLocation);
  										   paths.Add(ident);
  										.)
  { "::"
    ident                               (.
    									   var ident2 = AstNode.MakeIdentifier(t.val, new PlaceholderType(TextLocation.Empty), CurrentLocation);
    									   paths.Add(ident2);
    									.)
  }                                     (. path = Expression.MakePath(paths); .).
/*------------------------------------------------------------------------*/
SequenceMaker<out Expression expr>	(.  var exprs = new List<Expression>();
										expr = null; ComprehensionIter comp = null;
                                        string seq_type_name = "array";
									.)
=
  "..."                                 (. expr = Expression.MakeSequenceInitializer(CreateTypeWithArgs("vector", new PlaceholderType(TextLocation.Empty)), Enumerable.Empty<Expression>()); .)
  | CondExpr<out expr>                  (. exprs.Add(expr); .)
  ( { IF(NotFinalComma()) WEAK ','
      CondExpr<out expr>                (. exprs.Add(expr); .)
    }
    [ ','
      "..."                             (. seq_type_name = "vector"; .)
    ]                                   (. var type = CreateTypeWithArgs(seq_type_name, new PlaceholderType(TextLocation.Empty));
                                           expr = Expression.MakeSequenceInitializer(type, exprs);
                                        .)
  | CompFor<out comp>                   (. var type = CreateTypeWithArgs("vector", new PlaceholderType(TextLocation.Empty));
                                           expr = Expression.MakeComp(expr, (ComprehensionForClause)comp, type);
                                           GoUpScope();
                                           is_first_comprehension_for_clause = true;
                                        .)
  ).
/*------------------------------------------------------------------------*/
DictMaker<out Expression expr>			(. Expression key, val; var list = new List<KeyValueLikeExpression>();
                                           KeyValueLikeExpression pair; ComprehensionIter comp; expr = null;
                                           var type = CreateTypeWithArgs("dictionary", new PlaceholderType(TextLocation.Empty), new PlaceholderType(TextLocation.Empty));
                                        .)
=
  BitOr<out key>
  ':'
  CondExpr<out val>                     (. pair = Expression.MakeKeyValuePair(key, val);
                                           list.Add(pair);
                                        .)
  ( { WEAK ','
      BitOr<out key>
      ':'
      CondExpr<out val>                 (. pair = Expression.MakeKeyValuePair(key, val);
                                           list.Add(pair);
                                        .)
    }                                   (. expr = Expression.MakeSequenceInitializer(type, list); .)
  | CompFor<out comp>                   (. expr = Expression.MakeComp(pair, (ComprehensionForClause)comp, type);
  										   GoDownScope();
  										   is_first_comprehension_for_clause = true;
  										.)
  ).
/*------------------------------------------------------------------------*/
CompIter<out ComprehensionIter expr>    (. expr = null; .)
=
  CompFor<out expr>
  | CompIf<out expr> .
/*------------------------------------------------------------------------*/
CompFor<out ComprehensionIter expr>		(. Expression rvalue = null; ComprehensionIter body = null; PatternConstruct target; .)
=
  keyword_for							(. if(is_first_comprehension_for_clause){
  										   	   Symbols.AddScope();
  										   	   GoDownScope();
  										   	   Symbols.Name = "Comprehension`" + ScopeId++;
  										   	   is_first_comprehension_for_clause = false;
  										   }
  										.)
  LhsPattern<out target>
  keyword_in
  CondExpr<out rvalue>
  [CompIter<out body>]					(.
  										   expr = Expression.MakeCompFor(target, rvalue, body);
  										.).
/*------------------------------------------------------------------------*/
CompIf<out ComprehensionIter expr>		(. Expression tmp; ComprehensionIter body = null; .)
=
  keyword_if
  OrTest<out tmp>
  [CompIter<out body>]					(. 
  										   expr = Expression.MakeCompIf(tmp, body);
  										.).
/*------------------------------------------------------------------------*/
Identifier<out Identifier ident>    (. string name; AstType type = new PlaceholderType(TextLocation.Empty); var start_loc = CurrentLocation;.)
=
  ident                             (.
                                        name = t.val;
                                        if(CheckKeyword(t.val)){
                                            ident = null;
                                            return;
                                        }
                                    .)
  [ "(-"
    Type<out type>
  ]                                 (. ident = AstNode.MakeIdentifier(name, type, start_loc, CurrentLocation); .).
/*------------------------------------------------------------------------*/
Literal<out Expression expr>	(. expr = null; string tmp;
                                   var start_loc = NextLocation;
                                .)
= 
  integer						(. expr = CreateLiteral(t.val, start_loc); .)
  | hex_digit					(. expr = Expression.MakeConstant("int", Convert.ToInt32(t.val, 16), start_loc); .)
  | float						(. expr = CreateLiteral(t.val, start_loc); .)
  | character_literal           (.
                                   tmp = t.val;
                                   tmp = tmp.Substring(1, tmp.Length - 2);
                                   expr = HandleEscapes("char", tmp, start_loc);
                                .)
  | string_literal				(.
                                   tmp = t.val;
  								   tmp = tmp.Substring(1, tmp.Length - 2);
  								   expr = HandleEscapes("string", tmp, start_loc);
  								.)
  | raw_string_literal          (.
                                   tmp = t.val.Substring(1);
                                   if(tmp.StartsWith("#")){
                                       int index_double_quote = tmp.IndexOf('"');
                                       int start_end_hashes = tmp.Length - index_double_quote - 1;
                                       int index_end_double_quote = tmp.LastIndexOf('"');
                                       if(start_end_hashes != index_end_double_quote + 1)
                                           SemanticError("Error ES0008: The number of opening and closing hash symbols in a raw string must match!");

                                       tmp = tmp.Substring(index_double_quote, tmp.Length - index_end_double_quote - index_double_quote);
                                   }
                                   tmp = tmp.Substring(1, tmp.Length - 2);
                                   expr = Expression.MakeConstant("string", tmp, start_loc);
                                .)
  | "true"                      (. expr = Expression.MakeConstant("bool", true, start_loc); .)		
  | "false"                     (. expr = Expression.MakeConstant("bool", false, start_loc); .)
  | "self"                      (.
  								   var self_expr = Expression.MakeSelfRef(start_loc);
  								   expr = self_expr;
  								   // Don't add self symbol because we only need one ParameterExpression instance per type.
  								   //Symbols.AddSymbol(cur_class_name + "self", self_expr.SelfIdentifier);
  								.)
  | "super"                     (.
  								   var super_expr = Expression.MakeSuperRef(start_loc);
  								   expr = super_expr;
  								   Symbols.AddSymbol(cur_class_name + "super", super_expr.SuperIdentifier);
  								.).
/*------------------------------------------------------------------------*/
END Expresso.
