using System.Collections.Generic;
using System.Linq;
using Expresso.Ast;
using Expresso.Builtins;
using Expresso.Interpreter;
using Expresso.Helpers;



COMPILER Expresso

	internal Scope cur_scope = new Scope();		//the current scope of variables
	private Scope funcs = new Scope();	//the namespace for funcTable
	public Block root = new Block();
	static public Function main_func = null;	//the main function
	static private List<BreakableStatement> breakables = new List<BreakableStatement>();	//the current parent breakbles
	bool ignore_parent_scope = false;
	static private readonly TypeAnnotation VoidType = new TypeAnnotation(TYPES.UNDEF);
	static private readonly TypeAnnotation VariadicType = new TypeAnnotation(TYPES.VAR);
	static private readonly TypeAnnotation InferenceType = new TypeAnnotation(TYPES._INFERENCE);
	
	Parser()
	{			//Add built-in functions
		Function[] native_funcs = {
			new NativeLambdaUnary("abs", new Identifier("val", new TypeAnnotation(TYPES.VAR), 0), ExpressoFunctions.Abs),
			new NativeLambdaUnary("sqrt", new Identifier("val", new TypeAnnotation(TYPES.VAR), 0), ExpressoFunctions.Sqrt),
			new NativeLambdaUnary("toInt", new Identifier("val", new TypeAnnotation(TYPES.VAR), 0), ExpressoFunctions.ToInt)
		};
		foreach(var tmp in native_funcs)
			funcs.AddFunction(tmp);
	}
	
	/*static Parser()
	{
		ImplementationHelpers.AddBuiltinObjects();
	}*/
	
	Constant CreateConstant(TYPES type)
	{
		Constant result = null;
		
		switch(type){
		case TYPES.INTEGER:
			result = new Constant{ValType = type, Value = 0};
			break;
			
		case TYPES.BOOL:
			result = new Constant{ValType = type, Value = false};
			break;
			
		case TYPES.FLOAT:
			result = new Constant{ValType = type, Value = 0.0};
			break;
			
		case TYPES.STRING:
			result = new Constant{ValType = type, Value = ""};
			break;
			
		default:
			SemErr("Unknown object type");
			break;
		}
		
		return result;
	}
	
	bool NotFollowedByDoubleDots()
	{
		Token x = la;
		scanner.ResetPeek();
		if(x.kind != _lbracket) return true;
		while(x.kind != 0 && x.kind != _double_dots && x.kind != _rbracket && x.kind != _semicolon && x.kind != _rparen && x.kind != _keyword_in)
			x = scanner.Peek();
		
		return x.kind != _double_dots;
	}
	
	bool IdentIsNotCallable()
	{
		Token x = scanner.Peek();
		return x.kind != _lparen;
	}
	
	bool IsObjectInitializer()
	{
		Token x = la;
		if(x.kind != _lcurly) return true;
		scanner.ResetPeek();
		while(x.kind != 0 && x.kind != _keyword_for && x.kind != _rcurly) x = scanner.Peek();
		return x.kind != _keyword_for;
	}
	
	Identifier DeclareVariable(ref Expression rhs, string name, TypeAnnotation type)
	{
		if(rhs == null){
  			if(type.ObjType == TYPES._INFERENCE) SemErr("Can not infer the type of the variable \"" + name + "\" without initialization!");
  			rhs = CreateConstant(type.ObjType);
  		}else{
  			if(type.ObjType == TYPES._INFERENCE){
  				if(rhs is Constant){
  					var constant = (Constant)rhs;
  					type.ObjType = constant.ValType;
  				}else if(rhs is ObjectInitializer){
  					var initializer = (ObjectInitializer)rhs;
  					type.ObjType = initializer.ObjType;
  				}else if(rhs is Comprehension){
  					var comprehen = (Comprehension)rhs;
  					type.ObjType = comprehen.ObjType;
  				}else if(rhs is NewExpression){
  					type.ObjType = TYPES.CLASS;
  					type.TypeName = ((NewExpression)rhs).TargetName;
  				}else if(rhs is Call){
  					var call = (Call)rhs;
  					if(call.Function != null){
  						type = call.Function.ReturnType;
  					}else{
  						
  					}
  				}else{
  					SemErr("Cannot infer the type of the variable \"" + name + "\" from that type of expression.");
  				}
  			}
  		}
  		
		var variable = new Identifier(name, type);
 		cur_scope.AddLocal(ref variable);
 		return variable;
	}
	
	Identifier DeclareArgument(string name, TypeAnnotation type)
	{
		var argument = new Identifier(name, type);
		
		cur_scope.AddLocal(ref argument);
		return argument;
	}
	
	static ExprStatement MakeExprStatement(List<Expression> exprs)
	{
		return new ExprStatement{Expressions = exprs};
	}
	
	static BreakStatement MakeBreakStatement(int count)
	{
		var tmp = new List<BreakableStatement>();
		for(int len = Parser.breakables.Count, i = 0, j = count; j > 0; ++i){
			var enclosing = Parser.breakables[len - 1 - i];
			tmp.Add(enclosing);
			if(enclosing.Type == NodeType.WhileStatement || enclosing.Type == NodeType.ForStatement) --j;
		}
		return new BreakStatement{Count = count, Enclosings = tmp};
	}
	
	static IfStatement MakeIfStatement(Expression condition, Statement trueBlock, Statement falseBlock)
	{
		return new IfStatement{Condition = condition, TrueBlock = trueBlock, FalseBlock = falseBlock};
	}
	
	static WhileStatement MakeWhileStatement()
	{
		return new WhileStatement();
	}
	
	static ForStatement MakeForStatement()
	{
		return new ForStatement();
	}
	
	static SwitchStatement MakeSwitchStatement(Expression target, List<CaseClause> cases)
	{
		return new SwitchStatement{Target = target, Cases = cases};
	}
	
	static CaseClause MakeCaseClause(List<Expression> labels, Statement body)
	{
		return new CaseClause{Labels = labels, Body = body};
	}
	
	static Function MakeFunc(string name, List<Argument> parameters, Block body, TypeAnnotation returnType)
	{
		return new Function(name, parameters, body, returnType);
	}
	
	static Function MakeClosure(string name, List<Argument> parameters, Block body, TypeAnnotation returnType, VariableStore environ)
	{
		return new Function(name, parameters, body, returnType, environ);
	}
	
	static UnaryExpression MakeUnaryExpr(OperatorType op, Expression operand)
	{
		return new UnaryExpression{Operator = op, Operand = operand};
	}
	
	static BinaryExpression MakeBinaryExpr(OperatorType op, Expression lhs, Expression rhs)
	{
		return new BinaryExpression{Operator = op, Left = lhs, Right = rhs};
	}
	
	static ObjectInitializer MakeObjInitializer(TYPES type, List<Expression> initializeList)
	{
		return new ObjectInitializer{Initializer = initializeList, ObjType = type};
	}
	
	static Assignment MakeAssignment(List<Expression> targets, List<Expression> expressions)
	{
		return new Assignment{Targets = targets, Expressions = expressions};
	}
	
	static Assignment MakeAugumentedAssignment(List<Expression> targets, List<Expression> expressions, OperatorType opType)
	{
		var rvalues = new List<Expression>();
		for(int i = 0; i < expressions.Count; ++i){
			var rvalue = new BinaryExpression{Left = targets[i], Right = expressions[i], Operator = opType};
			rvalues.Add(rvalue);
		}
		return new Assignment{Targets = targets, Expressions = rvalues};
	}
	
	static Comprehension MakeComp(Expression yieldExpr, ComprehensionFor body, TYPES objType)
	{
		return new Comprehension{YieldExpr = yieldExpr, Body = body, ObjType = objType};
	}
	
	static ComprehensionFor MakeCompFor(List<Expression> lValues, Expression target, ComprehensionIter body)
	{
		return new ComprehensionFor{LValues = lValues, Target = target, Body = body};
	}
	
	static ComprehensionIf MakeCompIf(Expression condition, ComprehensionIter body)
	{
		return new ComprehensionIf{Condition = condition, Body = body};
	}
	
	static Constant MakeConstant(TYPES type, object val)
	{
		return new Constant{ValType = type, Value = val};
	}
	
	static IntSeqExpression MakeIntSeq(Expression start, Expression end, Expression step)
	{
		return new IntSeqExpression{Start = start, End = end, Step = step};
	}
	
	static ClassDeclaration MakeClassDef(string className, List<string> bases, List<Statement> decls)
	{
		return new ClassDeclaration{Name = className, Bases = bases, Declarations = decls};
	}
	
	static NewExpression MakeNewExpr(string targetName, List<Expression> args)
	{
		return new NewExpression{TargetName = targetName, Arguments = args};
	}
	
	static RequireExpression MakeRequireExpr(string moduleName, string aliasName)
	{
		return new RequireExpression{ModuleName = moduleName, AliasName = aliasName};
	}
	
/*--------------------------------------------------------------------------*/
CHARACTERS
  letter = 'A'..'Z' + 'a'..'z'.
  digit = '0'..'9'.
  hex_letter = digit + 'a'..'f' + 'A'..'F'.
  cr  = '\r'.
  lf  = '\n'.
  tab = '\t'.
  quotedLetter = ANY - '"' - '\''.

TOKENS
  double_dots = "..".
  rbracket = ']'.
  colon = ':'.
  semicolon = ';'.
  lcurly = '{'.
  lparen = '('.
  lbracket = '['.
  rparen = ')'.
  rcurly = '}'.
  comma = ','.
  ident  = (letter | '_') {'_' | letter | digit}.
  integer = digit {digit}
  			| digit {digit} CONTEXT("..").
  float = [digit {digit}] '.' {digit} [('e' | 'E') ['+' | '-'] digit {digit}].
  hex_digit = '0' ('x' | 'X') hex_letter {hex_letter}.
  string_literal = '"' {quotedLetter} '"'.
  keyword_in = "in".
  keyword_for = "for".

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO lf

IGNORE cr + lf + tab



PRODUCTIONS
/*------------------------------------------------------------------------*/
Expresso                    (. Statement stmt = null; .)
= 
  //ProgramDefinition
  
  ( ExprStmt<out stmt>
  | FuncDecl<out stmt>
  | ClassDecl<out stmt>
  )							(. root.Statements.Add(stmt); .)
  { 
    ( ExprStmt<out stmt>
    | FuncDecl<out stmt>
    | ClassDecl<out stmt>
    )						(. root.Statements.Add(stmt); .)
  }							(. Parser.main_func = funcs.GetFunction("main"); .).
/*------------------------------------------------------------------------*/
/*ProgramDefinition<out Statement require>
=
  {RequireStmt<out require>}.*/
/*------------------------------------------------------------------------*/
/*RequireStmt<out Statement stmt>	(. string module_name, alias = ""; var requires = new List<Expression>(); .)
=
  SYNC
  "require"
  Module<out module_name>
  [ "as"
    ident							(. alias = t.val; .)
  ]
  { ','
    Module<out module>
    [ "as"
      ident
    ]
  }
  SYNC ';' 							(. stmt = MakeExprStatement(requires); .).*/
/*------------------------------------------------------------------------*/
/*Module<out string name>			(. var sb = new StringBuilder(); .)
=
  ident								(. sb.Append(t.val); .)
  { 
    ( '.'							(. sb.Append('.'); .)
    | '/'							(. sb.Append('/'); .)
    )
    ident							(. sb.Append(t.val); .)
  }									(. name = sb.ToString(); .).*/
/*------------------------------------------------------------------------*/
ClassDecl<out Statement stmt>		(.
										Expression expr = null; var stmts = new List<Statement>(); List<Expression> decls = null;
										string name; var base_names = new List<string>(); Statement tmp = null;
									.)
=
  SYNC
  "class"							(. cur_scope = new Scope{Parent = cur_scope}; .)
  ident								(. name = t.val; .)
  [ ':'
    ident							(. base_names.Add(t.val); .)
    { ','
      ident							(. base_names.Add(t.val); .)
    }
  ]
  '{'
  { 
    ( "public"						(. expr = MakeConstant(TYPES._LABEL_PUBLIC, null); .)
    | "private"						(. expr = MakeConstant(TYPES._LABEL_PRIVATE, null); .)
    )
    ':'								(.
    									tmp = MakeExprStatement(new List<Expression>{expr});
    									stmts.Add(tmp);
    								.)
  | ConstructorDecl<out tmp, name>	(. stmts.Add(tmp); .)
  | MethodDecl<out tmp, name>		(. stmts.Add(tmp); .)
  | FieldDecl<out decls>			
    ';'								(.
  										tmp = MakeExprStatement(decls);
  										stmts.Add(tmp);
  									.)
  }
  SYNC '}'							(. 
  										stmt = MakeClassDef(name, base_names, stmts);
  										cur_scope = cur_scope.Parent;
  									.) .
/*------------------------------------------------------------------------*/
ConstructorDecl<out Statement func, string className>	(. 
															Statement block = null; var @params = new List<Argument>();
															Identifier ident_this; Argument exs_this = null;
														.)
=
  SYNC
  "constructor"					(. 
  									cur_scope = new Scope{Parent = cur_scope};
  									ident_this = DeclareArgument("this", new TypeAnnotation(TYPES.CLASS, className));
  									exs_this = new Argument{
  										Ident = ident_this,
  										Option = null
  									};
  								.)
  '('
  [ParamList<ref @params>]		(. @params.Insert(0, exs_this); .)
  ')'
  Block<out block> 				(.
  									func = MakeFunc("constructor", @params, (Block)block, VoidType);
  									cur_scope = cur_scope.Parent;
  								.).
/*------------------------------------------------------------------------*/
MethodDecl<out Statement func, string className>  (.
													string name; TypeAnnotation type = VariadicType; Statement block = null;
													var @params = new List<Argument>(); Identifier ident_this; Argument exs_this = null;
												  .)
=
  SYNC
  "def"							(.
  									cur_scope = new Scope{Parent = cur_scope};
  									ident_this = DeclareArgument("this", new TypeAnnotation(TYPES.CLASS, className));
  									exs_this = new Argument{
  										Ident = ident_this,
  										Option = null
  									};
  								.)
  ident							(. name = t.val; .)
  '('
  [ParamList<ref @params>]		(. @params.Insert(0, exs_this); .)
  ')'
  [ "->"
    Type<out type>
  ]
  Block<out block> 				(.
  									func = MakeFunc(name, @params, (Block)block, type);
  									cur_scope = cur_scope.Parent;
  								.).
/*------------------------------------------------------------------------*/
FieldDecl<. out List<Expression> outs .> (. string name; TypeAnnotation type = InferenceType; Expression rhs = null; Identifier variable;
											outs = new List<Expression>();
								   			var vars = new List<Identifier>(); var exprs = new List<Expression>();
										 .)
= 
  Variable<out name>
  [ "(-"
    Type<out type>
  ]
  [ '='
    ( IF(NotFollowedByDoubleDots())
      CondExpr<out rhs>
    | IntSeqExpr<out rhs>
    )
  ]
  { ','					 		(. 
  									variable = DeclareVariable(ref rhs, name, type);
 						 			vars.Add(variable);
  						 			exprs.Add(rhs);
  						 		.)
    Variable<out name>
  	[ "(-"
   	  Type<out type>
  	]
  	[ '='
  	  ( IF(NotFollowedByDoubleDots())
	    CondExpr<out rhs>
	  | IntSeqExpr<out rhs>
	  )
  	]
  }								(.
  									variable = DeclareVariable(ref rhs, name, type);
  					   	   			vars.Add(variable);
  					   	   			exprs.Add(rhs);
  					   
  					   	   			outs.Add(new VarDeclaration{
  					   					Variables = vars,
  					   					Expressions = exprs
  					   	   			});
  								.).
/*------------------------------------------------------------------------*/
Type<out TypeAnnotation type>		(. type = new TypeAnnotation(TYPES._INFERENCE); .)
=
 ( "int"                			(. type.ObjType = TYPES.INTEGER; .)
 | "bool"               			(. type.ObjType = TYPES.BOOL; .)
 | "float"							(. type.ObjType = TYPES.FLOAT; .)
 | "rational"						(. type.ObjType = TYPES.RATIONAL; .)
 | "bigint"							(. type.ObjType = TYPES.BIGINT; .)
 | "string"							(. type.ObjType = TYPES.STRING; .)
 | "bytearray"						(. type.ObjType = TYPES.BYTEARRAY; .)
 | "var"							(. type.ObjType = TYPES.VAR; .)
 | "tuple"							(. type.ObjType = TYPES.TUPLE; .)
 | "list"							(. type.ObjType = TYPES.LIST; .)
 | "dictionary"						(. type.ObjType = TYPES.DICT; .)
 | "expression"						(. type.ObjType = TYPES.EXPRESSION; .)
 | "function"						(. type.ObjType = TYPES.FUNCTION; .)
 | "intseq"							(. type.ObjType = TYPES.SEQ; .)
 | "void"							(. type.ObjType = TYPES.UNDEF; .)
 | ident							(. type.ObjType = TYPES.CLASS; type.TypeName = t.val; .)
 ).
/*------------------------------------------------------------------------*/
Stmt<out Statement stmt>			(. stmt = null; .)
=
  SimpleStmt<out stmt>
  | CompoundStmt<out stmt> .
/*------------------------------------------------------------------------*/
SimpleStmt<out Statement stmt>		(. stmt = null; .)
=	IF(la.kind == _lcurly)	/* For DictMaker and Block conflict. Since DictMaker should not be a statement, we always choose the first(Block).*/
    Block<out stmt>
  | ExprStmt<out stmt>
  | PrintStmt<out stmt>
  | ReturnStmt<out stmt>
  | BreakStmt<out stmt>
  | ContinueStmt<out stmt>.
/*------------------------------------------------------------------------*/
PrintStmt<out Statement stmt>		(. List<Expression> exprs = null; bool trailing_comma = false; .)
=
  "print"
  [RValueList<out exprs>]
  [',']								(. trailing_comma = true; .)
  SYNC ';'							(. stmt = new PrintStatement{Expressions = exprs, HasTrailing = trailing_comma}; .).
/*------------------------------------------------------------------------*/
ReturnStmt<out Statement stmt>		(. List<Expression> target_list = new List<Expression>(); /*bool trailing_comma;*/ .)
=
  "return"
  [RValueList<out target_list>]
  SYNC ';'							(. stmt = new Return{Expressions = target_list}; .).
/*------------------------------------------------------------------------*/
BreakStmt<out Statement stmt>		(. int count = 1; .)
=
  "break"
  [ "upto"
    integer							(. count = Convert.ToInt32(t.val); .)
  ]
  SYNC ';' 							(. stmt = MakeBreakStatement(count); .).
/*------------------------------------------------------------------------*/
ContinueStmt<out Statement stmt>	(. int count = 1; .)
= 
  "continue"
  [ "upto"
    integer							(. count = Convert.ToInt32(t.val); .)
  ]
  SYNC ';' 							(. stmt = new ContinueStatement{Count = count}; .).
/*------------------------------------------------------------------------*/
AugAssignOpe<ref OperatorType type>
=
  ( "+="							(. type = OperatorType.PLUS; .)
  | "-="							(. type = OperatorType.MINUS; .)
  | "*="							(. type = OperatorType.TIMES; .)
  | "/="							(. type = OperatorType.DIV; .)
  | "**="							(. type = OperatorType.POWER; .)
  | "%="							(. type = OperatorType.MOD; .)
  | "&="							(. type = OperatorType.BIT_AND; .)
  | "|="							(. type = OperatorType.BIT_OR; .)
  | "<<="							(. type = OperatorType.BIT_LSHIFT; .)
  | ">>="							(. type = OperatorType.BIT_RSHIFT; .)
  ).
/*------------------------------------------------------------------------*/
ExprStmt<out Statement stmt>				(.
												List<Expression> targets = null; List<Expression> expr_list;
												stmt = null; OperatorType op_type = OperatorType.NONE;
											.)
=
  ( VarDecl<out targets>
  | RValueList<out targets>
    ( AugAssignOpe<ref op_type>
      RValueList<out expr_list>				(. stmt = MakeAugumentedAssignment(targets, expr_list, op_type); .)
    |
    { '='
	  RValueList<out expr_list>				(. stmt = MakeAssignment(targets, expr_list); .)
    }
    )
  )
  SYNC ';' 									(. if(stmt == null) stmt = MakeExprStatement(targets); .).
/*------------------------------------------------------------------------*/
Block<out Statement block>			(. Block tmp; Statement stmt; .)
=
  '{'								(.
  										tmp = new Block();
  										Parser.breakables.Add(tmp);
  									.)
  Stmt<out stmt>					(. tmp.Statements.Add(stmt); .)
  { Stmt<out stmt>					(. tmp.Statements.Add(stmt); .)
  }
  '}' 								(.
  										block = tmp;
  										Parser.breakables.RemoveLast();
  									.).
/*------------------------------------------------------------------------*/
CompoundStmt<out Statement stmt>	(. stmt = null; .)
=
  SYNC
    IfStmt<out stmt>					
  | WhileStmt<out stmt>
  | ForStmt<out stmt>
  | SwitchStmt<out stmt>
  | FuncDecl<out stmt>.
/*------------------------------------------------------------------------*/
IfStmt<out Statement stmt>			(. Expression tmp; Statement true_block, false_block = null; .)
=
  "if" 
  '(' CondExpr<out tmp> ')'
  Stmt<out true_block>
  [ "else"
    Stmt<out false_block>
  ]                      			(. stmt = MakeIfStatement(tmp, true_block, false_block); .).
/*------------------------------------------------------------------------*/
WhileStmt<out Statement stmt>		(. Expression cond; Statement body = null; WhileStatement tmp; .)
=
  "while"							(.
  										tmp = MakeWhileStatement();
  										Parser.breakables.Add(tmp);
  									.)
  '(' CondExpr<out cond> ')'
  Stmt<out body>                   	(. 
  										tmp.Condition = cond;
  										tmp.Body = body;
  										Parser.breakables.RemoveLast();
  										stmt = tmp;
  									.).
/*------------------------------------------------------------------------*/
ForStmt<out Statement stmt>				(. 
											List<Expression> target_list = null; Expression rvalue = null; Statement body;
											ForStatement tmp; bool has_let = false;
										.)
=
  "for"									(.
	  										tmp = MakeForStatement();
	  										Parser.breakables.Add(tmp);
	  									.)
  '('
  ( LValueListWithLet<out target_list>	(. if(target_list != null) has_let = true; .)
  | LValueList<out target_list>
  )
  "in"
  ( IF(NotFollowedByDoubleDots())
    CondExpr<out rvalue>
  | IntSeqExpr<out rvalue>
  )
  ')'
  Stmt<out body>					(. 
  										tmp.LValues = target_list;
  										tmp.Target = rvalue;
  										tmp.Body = body;
  										tmp.HasLet = has_let;
  										Parser.breakables.RemoveLast();
  										stmt = tmp;
  									.).
/*------------------------------------------------------------------------*/
SwitchStmt<out Statement stmt>		(. Expression target; List<CaseClause> cases; .)
=
  "switch"
  '('
  CondExpr<out target>
  ')'
  '{'
  CaseClauseList<out cases>
  '}'								(. stmt = MakeSwitchStatement(target, cases); .).
/*------------------------------------------------------------------------*/
CaseClauseList<. out List<CaseClause> clauses .>	(. clauses = new List<CaseClause>(); List<Expression> label_list; Statement inner; .)
=
  CaseLabelList<out label_list>
  Stmt<out inner>									(. clauses.Add(MakeCaseClause(label_list, inner)); .)
  { CaseLabelList<out label_list>
    Stmt<out inner>									(. clauses.Add(MakeCaseClause(label_list, inner)); .)
  }.
/*------------------------------------------------------------------------*/
CaseLabelList<. out List<Expression> label_list .>	(. label_list = new List<Expression>(); Expression tmp; .)
=
  CaseLabel<out tmp>								(. label_list.Add(tmp); .)
  { CaseLabel<out tmp>								(. label_list.Add(tmp); .)
  }.
/*------------------------------------------------------------------------*/
CaseLabel<out Expression expr>						(. expr = null; .)
=
  "case"
  ( Literal<out expr>
  | IntSeqExpr<out expr>
  | "default"										(. expr = MakeConstant(TYPES._CASE_DEFAULT, "default"); .)
  )
  SYNC ':' .
/*------------------------------------------------------------------------*/
LValueList<. out List<Expression> targets .>		(. Expression tmp; .)
=													(. targets = new List<Expression>(); .)
  AddOpe<out tmp>									(. targets.Add(tmp); .)
  { WEAK ','
    AddOpe<out tmp>									(. targets.Add(tmp); .)
  }
  /*[',']*/ .
/*------------------------------------------------------------------------*/
LValueListWithLet<. out List<Expression> targets .>	(. Expression tmp; Identifier ident = null; .)
=													(. targets = null; .)
  "let"												(. targets = new List<Expression>(); .)
  AddOpe<out tmp>									(. 
  														ident = tmp as Identifier;
  														if(ident == null) SemErr("Expected a lvalue!");
  														cur_scope.AddLocal(ref ident);
  														targets.Add(ident);
  													.)
  { WEAK ','
    AddOpe<out tmp>									(.
    													ident = tmp as Identifier;
    													if(ident == null) SemErr("Expected a lvalue!");
    													cur_scope.AddLocal(ref ident);
    													targets.Add(ident);
    												.)
  }.
/*------------------------------------------------------------------------*/
VarDecl<. out List<Expression> outs .> 	(.
											string name; TypeAnnotation type = InferenceType; Expression rhs = null;
											Identifier variable; outs = new List<Expression>();
								   			var vars = new List<Identifier>(); var exprs = new List<Expression>();
										.)
= 
  "let"
  Variable<out name>
  [ "(-"
    Type<out type>
  ]
  [ '='
    ( IF(NotFollowedByDoubleDots())
      CondExpr<out rhs>
    | IntSeqExpr<out rhs>
    )
  ]
  { ','					 		(. 
  									variable = DeclareVariable(ref rhs, name, type);
 						 			vars.Add(variable);
  						 			exprs.Add(rhs);
  						 		.)
    Variable<out name>
  	[ "(-"
   	  Type<out type>
  	]
  	[ '='
  	  ( IF(NotFollowedByDoubleDots())
	    CondExpr<out rhs>
	  | IntSeqExpr<out rhs>
	  )
  	]
  }								(.
  									variable = DeclareVariable(ref rhs, name, type);
  					   	   			vars.Add(variable);
  					   	   			exprs.Add(rhs);
  					   
  					   	   			outs.Add(new VarDeclaration{
  					   					Variables = vars,
  					   					Expressions = exprs
  					   	   			});
  								.).
/*------------------------------------------------------------------------*/
FuncDecl<out Statement func>    (. string name; TypeAnnotation type = VariadicType; Statement block; var @params = new List<Argument>(); .)
=
  SYNC
  "def"							(. block = null; cur_scope = new Scope{Parent = cur_scope}; .)
  ident							(. name = t.val; .)
  '('
  [ParamList<ref @params>]
  ')'
  [ "->"
    Type<out type>
  ]
  Block<out block> 				(. func = MakeFunc(name, @params, (Block)block, type);
  								   funcs.AddFunction(func as Function);
  								   cur_scope = cur_scope.Parent;
  								.).
/*------------------------------------------------------------------------*/
ParamList<. ref List<Argument> @params .>		(. Argument expr; .)
=
  Argument<out expr>							(. @params.Add(expr); .)
  { ','
    Argument<out expr>							(. @params.Add(expr); .)
  }.
/*------------------------------------------------------------------------*/
Argument<out Argument arg>		(. string name; Expression default_val = null; TypeAnnotation type = null; .)
=
  Variable<out name>
  [ "(-"
    Type<out type>
  ]
  [ '='
    Literal<out default_val>
  ]									(.
  										Identifier param = DeclareArgument(name, type);
  									   	arg = new Argument{
  											Ident = param,
  											Option = default_val
  									   	};
  									.).
/*------------------------------------------------------------------------*/
RValueList<. out List<Expression> exprs .>		(. Expression tmp; .)
=												(. exprs = new List<Expression>(); .)
  CondExpr<out tmp>								(. exprs.Add(tmp); .)
  { ','
    CondExpr<out tmp>							(. exprs.Add(tmp);	.)
  }.
/*------------------------------------------------------------------------*/
CondExpr<out Expression expr>		(. Expression true_expr, false_expr; .)
=
  OrTest<out expr>
  [ '?'
    OrTest<out true_expr>
    ':'
    CondExpr<out false_expr>		(. expr = new ConditionalExpression{
    										Condition = expr,
    										TrueExpression = true_expr,
    										FalseExpression = false_expr
    								   };
    								.)
  ].
/*------------------------------------------------------------------------*/
IntSeqExpr<out Expression expr>		(. Expression start = null, end = null, step = null; .)
=
  '['
  [OrTest<out start>]
  ".."
  OrTest<out end>
  [ ':'
    OrTest<out step>
  ]
  ']'								(. 
  										if(start == null) start = CreateConstant(TYPES.INTEGER);
  										if(step == null) step = MakeConstant(TYPES.INTEGER, 1);
  										expr = MakeIntSeq(start, end, step);
  									.).
/*------------------------------------------------------------------------*/
OrTest<out Expression expr>			(. Expression rhs; .)
=
  AndTest<out expr>
  { "or"
    AndTest<out rhs>				(. expr = MakeBinaryExpr(OperatorType.OR, expr, rhs); .)
  }.
/*------------------------------------------------------------------------*/
AndTest<out Expression expr>		(. Expression rhs; .)
=
  NotTest<out expr>
  { "and"
    NotTest<out rhs>				(. expr = MakeBinaryExpr(OperatorType.AND, expr, rhs); .)
  }.
/*------------------------------------------------------------------------*/
NotTest<out Expression expr>		(. Expression term; expr = null; .)
=
  ( "not"
    NotTest<out term>				(. expr = MakeUnaryExpr(OperatorType.MINUS, term); .)
  )
  | Comparison<out expr>.
/*------------------------------------------------------------------------*/
Comparison<out Expression expr>		(. Expression rhs; OperatorType type; .)
=
  BitOr<out expr>			(. type = OperatorType.EQUAL; .)
  [
    ( "=="               	(. type = OperatorType.EQUAL; .)
    | "!="					(. type = OperatorType.NOTEQ; .)
    | '<'                	(. type = OperatorType.LESS; .)
    | '>'                	(. type = OperatorType.GREAT; .)
    | "<="				 	(. type = OperatorType.LESE; .)
    | ">="				 	(. type = OperatorType.GRTE; .)
    )
    BitOr<out rhs>			(. expr = MakeBinaryExpr(type, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
BitOr<out Expression expr>			(. Expression rhs; .)
=
  BitXor<out expr>
  { '|'
    BitXor<out rhs>					(. expr = MakeBinaryExpr(OperatorType.BIT_OR, expr, rhs); .)
  }.
/*------------------------------------------------------------------------*/
BitXor<out Expression expr>			(. Expression rhs; .)
=
  BitAnd<out expr>
  { '^'
    BitAnd<out rhs>					(. expr = MakeBinaryExpr(OperatorType.BIT_XOR, expr, rhs); .)
  }.
/*------------------------------------------------------------------------*/
BitAnd<out Expression expr>			(. Expression rhs; .)
=
  ShiftOpe<out expr>
  { '&'
    ShiftOpe<out rhs>				(. expr = MakeBinaryExpr(OperatorType.BIT_AND, expr, rhs); .)
  }.
/*------------------------------------------------------------------------*/
ShiftOpe<out Expression expr>		(. Expression rhs; OperatorType type; .)
=
  AddOpe<out expr>
  {
  	( "<<" 							(. type = OperatorType.BIT_LSHIFT; .)
    | ">>"							(. type = OperatorType.BIT_RSHIFT; .)
    )
    AddOpe<out rhs>					(. expr = MakeBinaryExpr(type, expr, rhs); .)
  }.
/*------------------------------------------------------------------------*/
AddOpe<out Expression expr>    (. Expression rhs; OperatorType type; .)
= 
  Term<out expr>
  { 
    ( '+'							(. type = OperatorType.PLUS; .)
    | '-'							(. type = OperatorType.MINUS; .)
    )
    Term<out rhs>					(. expr = MakeBinaryExpr(type, expr, rhs); .)
  }.
/*------------------------------------------------------------------------*/
Term<out Expression expr>   (. Expression rhs; OperatorType type; .)
= 
  Factor<out expr>
  {
    ( '*'					(. type = OperatorType.TIMES; .)
    | '/'					(. type = OperatorType.DIV; .)
    | '%'					(. type = OperatorType.MOD; .)
    )
    Factor<out rhs>			(. expr = MakeBinaryExpr(type, expr, rhs); .)
  }.
/*------------------------------------------------------------------------*/
Factor<out Expression expr> (. OperatorType type; Expression factor; expr = null; .)
=
  PowerOpe<out expr>
  | ( '-' 					(. type = OperatorType.MINUS; .)
    | '+'			 		(. type = OperatorType.PLUS; .)
    )
  Factor<out factor>	 	(. expr = MakeUnaryExpr(type, factor); .).
/*------------------------------------------------------------------------*/
PowerOpe<out Expression expr>    (. Expression rhs; .)
= 
  Primary<out expr>
  [ "**"
    Factor<out rhs>              (. expr = MakeBinaryExpr(OperatorType.POWER, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
Primary<out Expression expr>		(. string name = ""; expr = null; var args = new List<Expression>(); .)
=
  ( 
    ( IF(IdentIsNotCallable())
      Atom<out expr>
    | ident							(. name = t.val; .)
    )
    { Trailer<ref expr, name>
    }
  )
  | "new"
    ident							(. name = t.val; .)
    '('
    [ArgList<ref args>]
    ')'								(. expr = MakeNewExpr(name, args); .).
/*------------------------------------------------------------------------*/
Trailer<ref Expression expr, string name>	(. Function func; var args = new List<Expression>(); Expression subscript; .)
=
  '('
  [ArgList<ref args>]
  ')'							(. 
  								   if(expr != null){
  								   		expr = new Call{
  								   			Function = null,
  								   			Arguments = args,
  								   			Reference = expr
  								   		};
  								   		return;
  								   }
  								   func = funcs.GetFunction(name);
  								   if(func == null){
  								   		SemErr("The function is not defined : " + name);
  								   }
  								   expr = new Call{
  								   		Function = func,
  										Arguments = args,
  										Reference = null
  								   };
  						 		.)
  | '['
    Subscript<out subscript>
    ']'							(. expr = new MemberReference{
     									Parent = expr,
     									Subscription = subscript
     							   };
     							.)
  | '.'
    ident						(. subscript = new Identifier(t.val, new TypeAnnotation(TYPES._SUBSCRIPT));
     							   expr = new MemberReference{
     							   		Parent = expr,
     							   		Subscription = subscript
     							   };
     							.).
/*------------------------------------------------------------------------*/
Subscript<out Expression subscript>	(. subscript = null; .)
=
  IF(NotFollowedByDoubleDots())
  CondExpr<out subscript>
  | IntSeqExpr<out subscript>.
/*------------------------------------------------------------------------*/
ArgList<. ref List<Expression> args .>		(. Expression expr; .)
=
  CondExpr<out expr>						(. args.Add(expr); .)
  { ','
    CondExpr<out expr>						(. args.Add(expr); .)
  }.
/*------------------------------------------------------------------------*/
Atom<out Expression expr>			(. string name; expr = null; .)
=
  Variable<out name>				(.
  										expr = cur_scope.GetVariable(name, !ignore_parent_scope);
  										if(expr == null){
  											expr = new Identifier(name);
  											if(ignore_parent_scope){	//for the comprehension expression
  												var ident = (Identifier)expr;
  												cur_scope.AddLocal(ref ident);
  												expr = ident;
  											}
  										}
  									.)
  | Literal<out expr>
  | '('
    [SequenceMaker<out expr, TYPES.TUPLE>]
    SYNC ')'						(. 
    									if(expr == null)
    										expr = MakeObjInitializer(TYPES.TUPLE, new List<Expression>());
    								.)
  | '['
    [SequenceMaker<out expr, TYPES.LIST>]
    SYNC ']'						(.
    									if(expr == null)
    										expr = MakeObjInitializer(TYPES.LIST, new List<Expression>());
    								.)
  | '{'
    [DictMaker<out expr>]
    SYNC '}' 						(. if(expr == null) expr = MakeObjInitializer(TYPES.DICT, new List<Expression>()); .).
/*------------------------------------------------------------------------*/
SequenceMaker<out Expression expr, TYPES ObjType>	(.
														Expression tmp = null; List<Expression> list = new List<Expression>();
														expr = null; ComprehensionIter comprehen = null;
													.)
=
  IF(IsObjectInitializer())
  CondExpr<out tmp>						(. if(tmp != null) list.Add(tmp); .)
  { ','
    CondExpr<out tmp>					(. if(tmp != null) list.Add(tmp); .)
  }										(. expr = MakeObjInitializer(ObjType, list); .)
  | '{' 								(.
      										cur_scope = new Scope{Parent = cur_scope};
      										ignore_parent_scope = true;
      									.)
    CondExpr<out tmp>
    CompFor<out comprehen>
    '}'									(.
      										expr = MakeComp(tmp, (ComprehensionFor)comprehen, ObjType);
      										cur_scope = cur_scope.Parent;
      										ignore_parent_scope = false;
      									.).
/*------------------------------------------------------------------------*/
DictMaker<out Expression expr>			(. Expression lhs, rhs; List<Expression> list = new List<Expression>(); expr = null; .)
=
  ( CondExpr<out lhs>					(. if(lhs != null) list.Add(lhs); .)
    ':'
    CondExpr<out rhs>					(. if(rhs != null) list.Add(rhs); .)
  )
  { ','
    CondExpr<out lhs>					(. if(lhs != null) list.Add(lhs); .)
    ':'
    CondExpr<out rhs>					(. if(rhs != null) list.Add(rhs); .)
  }
  										(. if(list.Count > 0) expr = MakeObjInitializer(TYPES.DICT, list); .).
/*------------------------------------------------------------------------*/
CompIter<out ComprehensionIter expr>			(. expr = null; .)
=
  CompFor<out expr>
  | CompIf<out expr> .
/*------------------------------------------------------------------------*/
CompFor<out ComprehensionIter expr>		(. Expression rvalue = null; ComprehensionIter body = null; List<Expression> target_list; .)
=
  "for"									(. ignore_parent_scope = true; .)
  LValueList<out target_list>			(.
  											foreach(var target in target_list){
  												var ident = target as Identifier;
  												if(ident == null) SemErr("Expected a lvalue!");
  												if(!cur_scope.Contains(ident.Name))
  													cur_scope.AddLocal(ref ident);
  											}
  											ignore_parent_scope = false;
  										.)
  "in"
  ( IF(NotFollowedByDoubleDots())
    CondExpr<out rvalue>
  | IntSeqExpr<out rvalue>
  )
  [CompIter<out body>]					(. expr = MakeCompFor(target_list, rvalue, body); .).
/*------------------------------------------------------------------------*/
CompIf<out ComprehensionIter expr>		(. Expression tmp; ComprehensionIter body = null; .)
=
  "if"
  OrTest<out tmp>
  [CompIter<out body>]					(. expr = MakeCompIf(tmp, body); .).
/*------------------------------------------------------------------------*/
Variable<out string name>
= 
  ident							(. name = t.val; .).
/*------------------------------------------------------------------------*/
Literal<out Expression expr>	(. expr = null; .)
= 
  integer						(. expr = MakeConstant(TYPES.INTEGER, Convert.ToInt32(t.val)); .)
  | hex_digit					(. expr = MakeConstant(TYPES.INTEGER, Convert.ToInt32(t.val, 16)); .)
  | float						(. expr = MakeConstant(TYPES.FLOAT, Convert.ToDouble(t.val)); .)
  | string_literal				(. string tmp = t.val;
  								   tmp = tmp.Substring(1, tmp.Length - 2);
  								   expr = MakeConstant(TYPES.STRING, tmp);
  								.)
  | 
    ( "true"				
  	| "false"
  	)							(. expr = MakeConstant(TYPES.BOOL, Convert.ToBoolean(t.val)); .)
  | "null"						(. expr = MakeConstant(TYPES.NULL, null); .).
/*------------------------------------------------------------------------*/
END Expresso.
