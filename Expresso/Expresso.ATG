using System.Collections.Generic;
using System.Linq;
using System.Numerics;
using System.Text;

using Expresso.Ast;
using Expresso.Compiler.Meta;
using Expresso.Runtime;
using Expresso.Utils;



COMPILER Expresso
	internal ScopeStatement cur_scope = null;		//the current scope of variables
	static List<BreakableStatement> breakables = new List<BreakableStatement>();	//the current parent breakables hierarchy
	public string ParsingFileName{get; set;}
	public ExpressoAst TopmostAst{get; private set;}	//the top-level AST the parser is parsing
	
	///<summary>
	/// Parser Implementation details:
	/// 	During parsing we'll resolve break and continue statements.(Find which a break or continue statement would have its effect
	/// 	on which a loop statement) And in post-parse process, do flow analysis and type validity check, including local name bindings.
	///		Note that the identifiers are just placeholders until after doing name binding. 
	/// 	(Thus referencing them causes runtime exceptions)
	///</summary>
	Parser()
	{
		//Add built-in functions
		/*FunctionDefinition[] native_funcs = {
			new NativeLambdaUnary("abs", ImplementationHelpers.MakeArg(new Identifier("val", new TypeAnnotation(ObjectTypes.Var), null, 0)), ExpressoFunctions.Abs),
			new NativeLambdaUnary("sqrt", ImplementationHelpers.MakeArg(new Identifier("val", new TypeAnnotation(ObjectTypes.Var), null, 0)), ExpressoFunctions.Sqrt),
			new NativeLambdaUnary("toInt", ImplementationHelpers.MakeArg(new Identifier("val", new TypeAnnotation(ObjectTypes.Var), null, 0)), ExpressoFunctions.ToInt)
		};
		foreach(var tmp in native_funcs)
			cur_scope.AddFunction(tmp);*/
	}
	
	LiteralExpression CreateConstant(KnownTypeCode type)
	{
		LiteralExpression result = null;
		var loc = new TextLocation(t.line, t.col);

		switch(type){
		case ObjectTypes.Integer:
			result = AstNode.MakeConstant(new PrimitiveType("int", loc), 0);
			break;
			
		case ObjectTypes.Bool:
			result = AstNode.MakeConstant(new PrimitiveType("bool", loc), false);
			break;
			
		case ObjectTypes.Float:
			result = AstNode.MakeConstant(new PrimitiveType("float", loc), 0.0);
			break;
			
		case ObjectTypes.String:
			result = AstNode.MakeConstant(new PrimitiveType("string", loc), "");
			break;
			
		default:
			SemErr("Unknown object type");
			break;
		}
		
		return result;
	}
	
	bool NotFollowedByDoubleDots()
	{
		Token x = la;
		scanner.ResetPeek();
		if(x.kind != _lbracket)
            return true;
		
        while(x.kind != 0 && x.kind != _double_dots && x.kind != _rbracket && x.kind != _semicolon && x.kind != _rparen && x.kind != _keyword_in)
			x = scanner.Peek();
		
		return x.kind != _double_dots;
	}
	
	bool IsSequenceInitializer()
	{
		Token x = la;
        scanner.ResetPeek();
		if(x.kind != _comma)
            return true;
		
		while(x.kind != 0 && x.kind != _comma && x.kind != _keyword_for)
            x = scanner.Peek();
		
        return x.kind != _keyword_for;
	}
	
	static BreakStatement MakeBreakStatement(int count)
	{
		var tmp = new List<BreakableStatement>();
		for(int len = Parser.breakables.Count, i = 0, j = count; j > 0; ++i){
			var enclosing = Parser.breakables[len - 1 - i];
			tmp.Add(enclosing);
			if(enclosing.Type == NodeType.WhileStatement || enclosing.Type == NodeType.ForStatement) --j;
		}
		return AstNode.MakeBreakStmt(count, tmp);
	}
	
	static ContinueStatement MakeContinueStatement(int count)
	{
		var tmp = new List<BreakableStatement>();
		for(int len = Parser.breakables.Count, i = 0, j = count; j > 0; ++i){
			var enclosing = Parser.breakables[len - 1 - i];
			if(enclosing.Type != NodeType.WhileStatement && enclosing.Type != NodeType.ForStatement
				|| j != 1)			//don't include the loop on which we'll continue
				tmp.Add(enclosing);
			
			if(enclosing.Type == NodeType.WhileStatement || enclosing.Type == NodeType.ForStatement)
				--j;
		}
		return AstNode.MakeContinueStmt(count, tmp);
	}
	
	Statement MakeDefaultCtor(string className)
	{
		var ctor = AstNode.MakeFunc("constructor", null, new BlockStatement(), TypeAnnotation.VoidType.Clone(), Modifiers.Public);
		return ctor;
	}

    Statement MakeDefaultDtor(string className)
    {
        var dtor = AstNode.MakeFunc("destructor", null, new BlockStatement(), TypeAnnotation.VoidType.Clone(), Modifiers.Public);
        return dtor;
    }
	
	public void SemanticError(string format, params object[] args)
	{
		//Convenient method for printing a semantic error with a format string
		SemErr(string.Format(format, args));
	}
	
/*--------------------------------------------------------------------------*/
CHARACTERS
  letter = 'A'..'Z' + 'a'..'z'.
  digit = '0'..'9'.
  hex_letter = digit + 'a'..'f' + 'A'..'F'.
  cr  = '\r'.
  lf  = '\n'.
  tab = '\t'.
  quotedLetter = ANY - '"' - '\''.
  dot = '.'.

TOKENS
  double_dots = "..".
  triple_dots = "...".
  rbracket = ']'.
  colon = ':'.
  semicolon = ';'.
  lcurly = '{'.
  lparen = '('.
  lbracket = '['.
  rparen = ')'.
  rcurly = '}'.
  comma = ','.
  dot = '.'.
  ident  = (letter | '_') {'_' | letter | digit}.
  integer = digit {digit}
  			| digit {digit} CONTEXT("..").
  float = digit {digit} dot {digit} [('e' | 'E') ['+' | '-'] digit {digit}]
  		  | [digit {digit}] dot digit {digit} [('e' | 'E') ['+' | '-'] digit {digit}].
  hex_digit = '0' ('x' | 'X') hex_letter {hex_letter}.
  string_literal = '"' {quotedLetter} '"'.
  keyword_in = "in".
  keyword_for = "for".

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO lf

IGNORE cr + lf + tab



PRODUCTIONS
/*------------------------------------------------------------------------*/
Expresso                    		(. ExpressoAst module_decl = null; .)
= 
  ModuleBody<out module_decl>		(.  try{
                                            ExpressoNameBinder.BindAst(module_decl, this); //Here's the start of post-parse processing
                                        }
                                        catch(ParserException pe){
                                            SemanticError(pe.Message, pe.Objects);
                                        }
  										this.TopmostAst = module_decl;	//Currently there is not so much code out there, though...
  									.).
/*------------------------------------------------------------------------*/
ModuleBody<out ExpressoAst decl>	(.  var decls = new List<Statement>();
                                        string module_name; Modifiers modifiers = Modifiers.None;
										List<Statement> prog_defs = null; Statement stmt = null;
									.)
=
  ModuleNameDefinition<out module_name>
  [ ProgramDefinition<out prog_defs> (. if(prog_defs !=null) decls.AddRange(prog_defs); .)
  ]
  								
  [ "export"						(. modifiers = Modifiers.Export; .)
  ]
  ( ExprStmt<out stmt>
  | FuncDecl<out stmt, modifiers>
  | ClassDecl<out stmt, modifiers>
  )									(.  decls.Add(stmt);
										modifiers = Modifiers.None;
									.)
  {
    [ "export"						(. modifiers = Modifiers.Export; .)
    ]
    ( ExprStmt<out stmt>
    | FuncDecl<out stmt, modifiers>
    | ClassDecl<out stmt, modifiers>
    )								(.  decls.Add(stmt);
    									modifiers = Modifiers.None;
    								.)
  }									(.  decl = AstNode.MakeModuleDef(module_name, decls, export_map);
  									.) .
/*------------------------------------------------------------------------*/
ModuleNameDefinition<out string moduleName>
=
  "module"
  ident                             (. moduleName = t.val; .)
  SYNC ';'.
/*------------------------------------------------------------------------*/
ProgramDefinition<. out List<Statement> imports .>	(. imports = new List<Statement>(); Statement tmp; .)
=
  ImportStmt<out tmp>			(. imports.Add(tmp); .)
  { ImportStmt<out tmp>		    (. imports.Add(tmp); .)
  }.
/*------------------------------------------------------------------------*/
ImportDecl<out EntityDeclaration decl>
            (.  string module_name, alias = null; var module_names = new List<string>();
				var aliases = new List<string>();
			.)
=
  SYNC
  "import"
  ModuleName<out module_name>
  [ "as"
    ident						(. alias = t.val; .)
  ]								(.  module_names.Add(module_name);
  									aliases.Add(alias);
  								.)
  { ','
    ModuleName<out module_name>
    [ "as"
      ident						(. alias = t.val; .)
    ]							(.  module_names.Add(module_name);
  									aliases.Add(alias);
  								.)
  }
  SYNC ';' 						(. stmt = AstNode.MakeImportStmt(module_names, aliases); .).
/*------------------------------------------------------------------------*/
ModuleName<out string name>		(. var sb = new StringBuilder(); .)
=
  ident							(. sb.Append(t.val); .)
  { '.'							(. sb.Append('.'); .)
    ident						(. sb.Append(t.val); .)
  }								(. name = sb.ToString(); .).
/*------------------------------------------------------------------------*/
ClassDecl<out EntityDeclaration decl, Modifiers modifiers>   
  (.  EntityDeclaration entity = null; var decls = new List<EntityDeclaration>();
      string name; var base_names = new List<Identifier>(); bool has_ctor = false;
      Modifiers cur_flag = Modifiers.Private;
  .)
=
  SYNC
  "class"
  ident				    				(. name = t.val; .)
  [ ':'
    ident		    					(. base_names.Add(AstNode.MakeIdentifier(t.val)); .)
    { ','
      ident							    (. base_names.Add(AstNode.MakeIdentifier(t.val)); .)
    }
  ]
  '{'
  {
    ( "public"						    (. cur_flag = Modifiers.Private; .)
    | "protected"					    (. cur_flag = Modifiers.Protected; .)
    | "private"					    	(. cur_flag = Modifiers.Public; .)
    )
    ':'
  | ConstructorDecl<out entity, name, cur_flag>
                                        (.  decls.Add(entity);
  										    has_ctor = true;
  									    .)
  | DestructorDecl<out entity, name, cur_flag>
                                        (. decls.Add(entity); .)
  | MethodDecl<out entity, name, cur_flag>(. decls.Add(entity); .)
  | FieldDecl<out entity, cur_flag>
    ';'								    (. decls.Add(entity); .)
  | ClassDecl<out entity>			    (. decls.Add(entity); .)
  }
  SYNC '}'							    (.  if(!has_ctor){		//Define the default constructor
  										    	decls.Add(MakeDefaultCtor(name));
  									    	}
  										    decl = AstNode.MakeClassDecl(name, base_names, decls, modifiers);
  									    .) .
/*------------------------------------------------------------------------*/
ConstructorDecl<out EntityDeclaration decl, string className, Modifiers modifiers>
                                (.  Statement block = null; var @params = new List<Argument>(); .)
=
  SYNC
  "constructor"
  '('
  [ParamList<ref @params>]
  ')'
  Block<out block> 				(. decl = AstNode.MakeFunc("constructor", @params, (Block)block, TypeAnnotation.VoidType.Clone(), modifiers);
  								.).
/*------------------------------------------------------------------------*/
DestructorDecl<out EntityDeclaration decl, string className, Modifiers modifiers>
                                (. Statement block = null; var @params = new List<Argument>(); .)
=
  SYNC
  "destructor"
  '('
  [ParamList<ref @params>]
  ')'
  Block<out block>              (. decl = AstNode.MakeFunc("destructor", @params, (Block)block, TypeAnnotation.VoidType.Clone(), modifiers); .).
/*------------------------------------------------------------------------*/
MethodDecl<out EntityDeclaration decl, string className, Modifiers modifiers>
                                (.
									string name; var type = TypeAnnotation.InferenceType.Clone(); Statement block = null;
									var @params = new List<Argument>();
								.)
=
  SYNC
  "def"
  ident							(. name = t.val; .)
  '('
  [ParamList<ref @params>]
  ')'
  [ "->"
    Type<out type>
  ]
  Block<out block> 				(.  decl = AstNode.MakeFunc(name, @params, (Block)block, type, modifiers); .).
/*------------------------------------------------------------------------*/
FieldDecl<. out List<EntityDeclaration> outs, Modifiers modifiers .>
  (. string name; var type = TypeAnnotation.InferenceType.Clone(); Expression rhs = null;
	 Identifier variable; outs = new List<Expression>();
	 var vars = new List<Identifier>(); var exprs = new List<Expression>();
  .)
= 
  ( "let"
  | "var"
  )
  VarDef<out name, out type, out rhs> (.  variable = AstNode.MakeField(name, type);
                                          vars.Add(variable);
                                          if(rhs == null)
                                              rhs = AstNode.MakeDefaultExpr(type);
                                    
                                          exprs.Add(rhs);
                                          rhs = null;
                                      .)  
  { ','					 		
    VarDef<out name, out type, out rhs> (. variable = AstNode.MakeField(name, type);
                                           vars.Add(variable);
                                           if(rhs == null)
                                               rhs = AstNode.MakeDefaultExpr(type);
                                    
                                           exprs.Add(rhs);
                                        .)
  }								       (. outs.Add(AstNode.MakeVarDecl(vars, exprs, flag)); .).
/*------------------------------------------------------------------------*/
Type<out TypeAnnotation type>		(. type = TypeAnnotation.InferenceType.Clone(); int dimension = 0; .)
=
 ( "Int"                			(. type.ObjType = ObjectTypes.Integer; .)
 | "Bool"               			(. type.ObjType = ObjectTypes.Bool; .)
 | "Float"							(. type.ObjType = ObjectTypes.Float; .)
 | "Rational"						(. type.ObjType = ObjectTypes.Rational; .)
 | "Bigint"							(. type.ObjType = ObjectTypes.BigInt; .)
 | "String"							(. type.ObjType = ObjectTypes.String; .)
 | "Byte"						    (. type.ObjType = ObjectTypes.Byte; .)
 | "Variadic"						(. type.ObjType = ObjectTypes.Var; .)
 | "Tuple"							(. type.ObjType = ObjectTypes.Tuple; .)
 | "List"							(. type.ObjType = ObjectTypes.List; .)
 | "Dictionary"						(. type.ObjType = ObjectTypes.Dict; .)
 | "Expression"						(. type.ObjType = ObjectTypes.Expression; .)
 | "Function"						(. type.ObjType = ObjectTypes.Function; .)
 | "Intseq"							(. type.ObjType = ObjectTypes.Seq; .)
 | "Void"							(. type.ObjType = ObjectTypes.Undef; .)
 | ident							(. type.ObjType = ObjectTypes.Instance; type.TypeName = t.val; .)
 )
 { "[]"                             (. if(!type.IsArray)
                                           type.IsArray = true;
                                       
                                       ++dimension;
                                    .)
 }                                  (. type.Dimension = dimension; .).
/*------------------------------------------------------------------------*/
Stmt<out Statement stmt>			(. stmt = null; .)
=
  SimpleStmt<out stmt>
  | CompoundStmt<out stmt> .
/*------------------------------------------------------------------------*/
SimpleStmt<out Statement stmt>		(. stmt = null; .)
=	IF(la.kind == _lcurly)	/* For DictMaker and Block conflict. Since DictMaker should not be a statement, we always choose the first(Block).*/
    Block<out stmt>
  | ExprStmt<out stmt>
  | ReturnStmt<out stmt>
  | BreakStmt<out stmt>
  | ContinueStmt<out stmt>
  | ThrowStmt<out stmt>
  | YieldStmt<out stmt>
  | EmptyStmt<out stmt>.
/*------------------------------------------------------------------------*/
ReturnStmt<out Statement stmt>		(. SequenceExpression items = null; .)
=
  "return"
  [RValueList<out items>]
  SYNC ';'							(. stmt = AstNode.MakeReturnStmt(items); .).
/*------------------------------------------------------------------------*/
BreakStmt<out Statement stmt>		(. int count = 1; .)
=
  "break"
  [ "upto"
    integer							(. count = Convert.ToInt32(t.val); .)
  ]
  SYNC ';' 							(. stmt = MakeBreakStatement(count); .).
/*------------------------------------------------------------------------*/
ContinueStmt<out Statement stmt>	(. int count = 1; .)
= 
  "continue"
  [ "upto"
    integer							(. count = Convert.ToInt32(t.val); .)
  ]
  SYNC ';' 							(. stmt = MakeContinueStatement(count); .).
/*------------------------------------------------------------------------*/
ThrowStmt<out Statement stmt>		(. Expression expr; .)
=
  "throw"
  CondExpr<out expr>
  SYNC ';'							(. stmt = AstNode.MakeThrowStmt(expr); .).
/*------------------------------------------------------------------------*/
YieldStmt<out Statement stmt>		(. Expression expr; .)
=
  "yield"
  CondExpr<out expr>
  SYNC ';'							(. stmt = AstNode.MakeYieldStmt(expr); .).
/*------------------------------------------------------------------------*/
EmptyStmt<out Statement stmt>
=
  SYNC ';'							(. stmt = AstNode.MakeEmptyStmt(); .).
/*------------------------------------------------------------------------*/
AugAssignOpe<ref OperatorType type>
=
  ( "+="							(. type = OperatorType.Plus; .)
  | "-="							(. type = OperatorType.Minus; .)
  | "*="							(. type = OperatorType.Times; .)
  | "/="							(. type = OperatorType.Divide; .)
  | "**="							(. type = OperatorType.Power; .)
  | "%="							(. type = OperatorType.Modulus; .)
  | "&="							(. type = OperatorType.BitwiseAnd; .)
  | "|="							(. type = OperatorType.BitwiseOr; .)
  | "<<="							(. type = OperatorType.BitwiseShiftLeft; .)
  | ">>="							(. type = OperatorType.BitwiseShiftRight; .)
  ).
/*------------------------------------------------------------------------*/
ExprStmt<out Statement stmt>				(.  List<Expression> lvalues = null; var targets = new List<SequenceExpression>();
												SequenceExpression seq = null;
												stmt = null; OperatorType op_type = OperatorType.None;
											.)
=
  ( VarDecl<out lvalues>
  |
  LValueList<out seq>						(. targets.Add(seq); .)
  { ( AugAssignOpe<ref op_type>
    | '='
    )
    RValueList<out seq>						(. targets.Add(seq); .)
  }											(.
  												seq = targets[targets.Count - 1];
  												targets.RemoveAt(targets.Count - 1);
  												if(op_type != OperatorType.None && targets.Count != 1)
  													SemErr("An augumented assignment can't have multiple left-hand-side.");
  												if(op_type != OperatorType.None &&		//See if it is an augumented assignment and
  													targets[0].Count != seq.Count)		//both sides have the same number of items
  													SemErr("An augumented assignment must have both sides balanced.");
  													
  												if(op_type != OperatorType.None)
  													stmt = AstNode.MakeAugumentedAssignment(targets[0], seq, op_type);
  												else
  													stmt = AstNode.MakeAssignment(targets.Cast<Expression>(), seq);
  											.)
  )
  SYNC ';' 									(.  if(stmt == null)
  													stmt = AstNode.MakeExprStmt(lvalues);
  											.).
/*------------------------------------------------------------------------*/
Block<out Statement block>			(. Block tmp; Statement stmt; .)
=
  '{'								(.  tmp = new Block();
  									.)
  Stmt<out stmt>					(. tmp.Statements.Add(stmt); .)
  { Stmt<out stmt>					(. tmp.Statements.Add(stmt); .)
  }
  '}' 								(.  block = tmp;
  									.).
/*------------------------------------------------------------------------*/
CompoundStmt<out Statement stmt>	(. stmt = null; .)
=
  SYNC
    IfStmt<out stmt>					
  | WhileStmt<out stmt>
  | ForStmt<out stmt>
  | SwitchStmt<out stmt>
  | FuncDecl<out stmt>
  | WithStmt<out stmt>
  | TryStmt<out stmt>.
/*------------------------------------------------------------------------*/
IfStmt<out Statement stmt>			(. Expression tmp; Statement true_block, false_block = null; .)
=
  "if" 
  '(' CondExpr<out tmp> ')'
  Stmt<out true_block>
  [ "else"
    Stmt<out false_block>
  ]                      			(. stmt = AstNode.MakeIfStmt(tmp, true_block, false_block); .).
/*------------------------------------------------------------------------*/
WhileStmt<out Statement stmt>		(. Expression cond; Statement body = null; WhileStatement tmp; .)
=
  "while"							(.  tmp = AstNode.MakeWhileStmt(); .)
  '(' CondExpr<out cond> ')'
  Stmt<out body>                   	(.  tmp.Condition = cond;
  										tmp.Body = body;
  										stmt = tmp;
  									.).
/*------------------------------------------------------------------------*/
ForStmt<out Statement stmt>				(.  SequenceExpression left = null; Expression rvalue = null; Statement body;
											ForStatement tmp;
										.)
=
  "for"									(.  tmp = AstNode.MakeForStmt(); .)
  '('
  LValueList<out left>
  "in"
  ( IF(NotFollowedByDoubleDots())
    CondExpr<out rvalue>
  | IntSeqExpr<out rvalue>
  )
  ')'
  Stmt<out body>						(.  tmp.Left = left;
	  										tmp.Target = rvalue;
	  										tmp.Body = body;
	  										stmt = tmp;
	  									.).
/*------------------------------------------------------------------------*/
SwitchStmt<out Statement stmt>		(. Expression target; List<CaseClause> cases; .)
=
  "switch"
  '('
  CondExpr<out target>
  ')'
  '{'
  CaseClauseList<out cases>
  '}'								(. stmt = AstNode.MakeSwitchStmt(target, cases); .).
/*------------------------------------------------------------------------*/
CaseClauseList<. out List<CaseClause> clauses .>	(. clauses = new List<CaseClause>(); List<Expression> label_list; Statement inner; .)
=
  CaseLabelList<out label_list>
  Stmt<out inner>									(. clauses.Add(AstNode.MakeCaseClause(label_list, inner)); .)
  { CaseLabelList<out label_list>
    Stmt<out inner>									(. clauses.Add(AstNode.MakeCaseClause(label_list, inner)); .)
  }.
/*------------------------------------------------------------------------*/
CaseLabelList<. out List<Expression> label_list .>	(. label_list = new List<Expression>(); Expression tmp; .)
=
  CaseLabel<out tmp>								(. label_list.Add(tmp); .)
  { CaseLabel<out tmp>								(. label_list.Add(tmp); .)
  }.
/*------------------------------------------------------------------------*/
CaseLabel<out Expression expr>				(. expr = null; .)
=
  "case"
  ( Literal<out expr>
  | IntSeqExpr<out expr>
  | "default"								(. expr = AstNode.MakeConstant(ObjectTypes._CASE_DEFAULT, "default"); .)
  )
  SYNC ':' .
/*------------------------------------------------------------------------*/
LValueList<out SequenceExpression target>	(. Expression tmp; var exprs = new List<Expression>(); .)
=
  Primary<out tmp>							(. exprs.Add(tmp); .)
  { SYNC ','
    Primary<out tmp>						(. exprs.Add(tmp); .)
  }											(. target = AstNode.MakeSequence(exprs); .).
/*------------------------------------------------------------------------*/
VarDecl<. out List<Expression> outs .> 	(.  string name; var type = TypeAnnotation.InferenceType.Clone(); Expression rhs = null;
											Identifier variable; outs = new List<Expression>();
								   			var vars = new List<Identifier>(); var exprs = new List<Expression>();
                                            bool is_const = false;
										.)
= 
  ( "let"                               (. is_const = true; .)
  | "var"
  )
  VarDef<out name, out type, out rhs>	(.  variable = AstNode.MakeLocalVar(name, type);
                                            vars.Add(variable);
                                            if(rhs == null)
                                                rhs = AstNode.MakeDefaultExpr(type);
                                    
  						 			        exprs.Add(rhs);
  						 			        rhs = null;
  						 		        .)
  { WEAK ','
    VarDef<out name, out type, out rhs>(. variable = AstNode.MakeLocalVar(name, type);
                                          vars.Add(variable);
                                          if(rhs == null)
                                              rhs = AstNode.MakeDefaultExpr(type);
                                    
  									      exprs.Add(rhs);
  									      rhs = null;
  								       .)
  }								       (. outs.Add(AstNode.MakeVarDecl(vars, exprs)); .).
/*------------------------------------------------------------------------*/
VarDef<out string name, out Type type, out Expression @default>  (. type = TypeAnnotation.InferenceType.Clone();
                                                                    @default = null;
                                                                 .)
=
  ident                        (. name = t.val; .)
  [ "(-"
    Type<out type>
  ]
  [ '='
    ( IF(NotFollowedByDoubleDots())
      CondExpr<out @default>
    | IntSeqExpr<out @default>
    )
  ].
/*------------------------------------------------------------------------*/
FuncDecl<out Statement func>    (.  string name; var type = TypeAnnotation.VariantType.Clone(); Statement block;
									var @params = new List<Argument>(); Argument arg_this = null;
								.)
=
  SYNC
  "def"							(.  block = null;
  									arg_this = AstNode.MakeArg("this", new TypeAnnotation(ObjectTypes.TypeModule));
  									@params.Add(arg_this);
  								.)
  ident							(. name = t.val; .)
  '('
  [ParamList<ref @params>]
  ')'
  [ "->"
    Type<out type>
  ]
  Block<out block> 				(. func = AstNode.MakeFunc(name, @params, (Block)block, type); .).
/*------------------------------------------------------------------------*/
WithStmt<out Statement stmt>		(. Statement block = null; .)
=
  "with"
  '('
  ')'
  Block<out block>					(. stmt = null; .).
/*------------------------------------------------------------------------*/
TryStmt<out Statement stmt>			(.  Statement body, catch_body = null, finally_body = null; List<CatchClause> catches = null;
										TypeAnnotation excp_type = null; Identifier catch_ident = null; string name = null;
									.)
=
  "try"
  Block<out body>
  { "catch"							(. if(catches == null) catches = new List<CatchClause>(); .)
    '('
    ident							(. name = t.val; .)
    "(-"
    Type<out excp_type>
    ')'								(. catch_ident = AstNode.MakeLocalVar(name, excp_type); .)
    Block<out catch_body>			(. catches.Add(AstNode.MakeCatchClause((Block)catch_body, catch_ident)); .)
  }									
  [ "finally"
    Block<out finally_body>
  ]									(. stmt = AstNode.MakeTryStmt((Block)body, catches, (Block)finally_body); .).
/*------------------------------------------------------------------------*/
ParamList<. ref List<ParameterDeclaration> @params .>	(. ParameterDeclaration expr; .)
=
  Argument<out expr>							        (. @params.Add(expr); .)
  { WEAK ','
    Argument<out expr>							        (. @params.Add(expr); .)
  }.
/*------------------------------------------------------------------------*/
Argument<out ParameterDeclaration arg>	(. string name; Expression default_val = null; var type = TypeAnnotation.VariantType.Clone(); .)
=
  ident							        (. name = t.val; .)
  [ "(-"
    Type<out type>
  ]
  [ '='
    Literal<out default_val>
  ]								        (. arg = AstNode.MakeArg(name, type, default_val); .).
/*------------------------------------------------------------------------*/
RValueList<out SequenceExpression seq>		(. Expression tmp; var exprs = new List<Expression>(); .)
=
  CondExpr<out tmp>							(. exprs.Add(tmp); .)
  { WEAK ','
    CondExpr<out tmp>						(. exprs.Add(tmp);	.)
  }											(. seq = AstNode.MakeSequence(exprs); .).
/*------------------------------------------------------------------------*/
CondExpr<out Expression expr>		(. Expression true_expr, false_expr; .)
=
  OrTest<out expr>
  [ '?'
    OrTest<out true_expr>
    ':'
    CondExpr<out false_expr>		(. expr = AstNode.MakeCondExpr(expr, true_expr, false_expr); .)
  ].
/*------------------------------------------------------------------------*/
IntSeqExpr<out Expression expr>		(. Expression start = null, end = null, step = null;
                                       bool upper_inclusive = true;
                                    .)
=
  '['
  [OrTest<out start>]
  ( ".."                            (. upper_inclusive = false; .)
  | "..."
  )
  OrTest<out end>
  [ ':'
    OrTest<out step>
  ]
  ']'								(.  if(start == null) start = CreateConstant(ObjectTypes.Integer);
  										if(step == null) step = AstNode.MakeConstant(ObjectTypes.Integer, 1);
  										expr = AstNode.MakeIntSeq(start, end, step, upper_inclusive);
  									.).
/*------------------------------------------------------------------------*/
OrTest<out Expression expr>			(. Expression rhs; .)
=
  AndTest<out expr>
  { "||"
    AndTest<out rhs>				(. expr = AstNode.MakeBinaryExpr(OperatorType.ConditionalOr, expr, rhs); .)
  }.
/*------------------------------------------------------------------------*/
AndTest<out Expression expr>		(. Expression rhs; .)
=
  NotTest<out expr>
  { "&&"
    NotTest<out rhs>				(. expr = AstNode.MakeBinaryExpr(OperatorType.ConditionalAnd, expr, rhs); .)
  }.
/*------------------------------------------------------------------------*/
NotTest<out Expression expr>		(. Expression term; expr = null; .)
=
  ( '!'
    NotTest<out term>				(. expr = AstNode.MakeUnaryExpr(OperatorType.Not, term); .)
  )
  | Comparison<out expr>.
/*------------------------------------------------------------------------*/
Comparison<out Expression expr>	(. Expression rhs; OperatorType type; .)
=
  BitOr<out expr>				(. type = OperatorType.Equality; .)
  [
    ( "=="               		(. type = OperatorType.Equality; .)
    | "!="						(. type = OperatorType.InEquality; .)
    | '<'                		(. type = OperatorType.LessThan; .)
    | '>'                		(. type = OperatorType.GreaterThan; .)
    | "<="				 		(. type = OperatorType.LessThanOrEqual; .)
    | ">="				 		(. type = OperatorType.GreaterThanOrEqual; .)
    )
    BitOr<out rhs>				(. expr = AstNode.MakeBinaryExpr(type, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
BitOr<out Expression expr>			(. Expression rhs; .)
=
  BitXor<out expr>
  { '|'
    BitXor<out rhs>					(. expr = AstNode.MakeBinaryExpr(OperatorType.BitwiseOr, expr, rhs); .)
  }.
/*------------------------------------------------------------------------*/
BitXor<out Expression expr>			(. Expression rhs; .)
=
  BitAnd<out expr>
  { '^'
    BitAnd<out rhs>					(. expr = AstNode.MakeBinaryExpr(OperatorType.ExclusiveOr, expr, rhs); .)
  }.
/*------------------------------------------------------------------------*/
BitAnd<out Expression expr>			(. Expression rhs; .)
=
  ShiftOpe<out expr>
  { '&'
    ShiftOpe<out rhs>				(. expr = AstNode.MakeBinaryExpr(OperatorType.BitwiseAnd, expr, rhs); .)
  }.
/*------------------------------------------------------------------------*/
ShiftOpe<out Expression expr>		(. Expression rhs; OperatorType type; .)
=
  AddOpe<out expr>
  {
  	( "<<" 							(. type = OperatorType.BitwiseShiftLeft; .)
    | ">>"							(. type = OperatorType.BitwiseShiftRight; .)
    )
    AddOpe<out rhs>					(. expr = AstNode.MakeBinaryExpr(type, expr, rhs); .)
  }.
/*------------------------------------------------------------------------*/
AddOpe<out Expression expr>    		(. Expression rhs; OperatorType type; .)
= 
  Term<out expr>
  { 
    ( '+'							(. type = OperatorType.Plus; .)
    | '-'							(. type = OperatorType.Minus; .)
    )
    Term<out rhs>					(. expr = AstNode.MakeBinaryExpr(type, expr, rhs); .)
  }.
/*------------------------------------------------------------------------*/
Term<out Expression expr>   (. Expression rhs; OperatorType type; .)
= 
  Factor<out expr>
  {
    ( '*'					(. type = OperatorType.Times; .)
    | '/'					(. type = OperatorType.Divide; .)
    | '%'					(. type = OperatorType.Modulus; .)
    )
    Factor<out rhs>			(. expr = AstNode.MakeBinaryExpr(type, expr, rhs); .)
  }.
/*------------------------------------------------------------------------*/
Factor<out Expression expr> (. OperatorType type; Expression factor; expr = null; .)
=
  ( '+'                     (. type = OperatorType.Plus; .)
  | '-'                     (. type = OperatorType.Minus; .)
  )
  Factor<out factor>        (. expr = AstNode.MakeUnaryExpr(type, factor); .)
  | PowerOpe<out expr> .
/*------------------------------------------------------------------------*/
PowerOpe<out Expression expr>    (. Expression rhs; .)
= 
  Primary<out expr>
  [ "**"
    Factor<out rhs>              (. expr = AstNode.MakeBinaryExpr(OperatorType.Power, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
Primary<out Expression expr>		(. expr = null; .)
=
  ( Atom<out expr>
    { Trailer<ref expr>
    }
  )
  | NewExpression<out expr>.
/*------------------------------------------------------------------------*/
NewExpression<out Expression expr>		(. var args = new List<Expression>(); .)
=
  "new"
  ident									(. expr = AstNode.MakeIdentifier(t.val); .)
  { '.'
    ident								(. expr = AstNode.MakeMemRef(expr, AstNode.MakeIdentifier(t.val)); .)
  }
  '('
  [ArgList<ref args>]
  ')'									(. expr = AstNode.MakeNewExpr(expr, args); .).
/*------------------------------------------------------------------------*/
Trailer<ref Expression expr>	(. var args = new List<Expression>(); Expression subscript; .)
=
  '('							(.  if(expr is MemberReference)
                                        args.Add(((MemberReference)expr).Target);
                                    else
                                        args.Add(AstNode.MakeConstant(ObjectTypes.Instance, this.TopmostAst));
                                .)
  [ArgList<ref args>]
  ')'							(. expr = AstNode.MakeCallExpr(expr, args); .)
  | '['
    Subscript<out subscript>
    ']'							(. expr = AstNode.MakeIndexer(expr, subscript); .)
  | '.'
    ident						(. expr = AstNode.MakeMemRef(expr, AstNode.MakeIdent(t.val)); .).
/*------------------------------------------------------------------------*/
Subscript<out Expression subscript>	(. subscript = null; .)
=
  IF(NotFollowedByDoubleDots())
  CondExpr<out subscript>
  | IntSeqExpr<out subscript>.
/*------------------------------------------------------------------------*/
ArgList<. ref List<Expression> args .>		(. Expression expr; .)
=
  CondExpr<out expr>						(. args.Add(expr); .)
  { WEAK ','
    CondExpr<out expr>						(. args.Add(expr); .)
  }.
/*------------------------------------------------------------------------*/
Atom<out Expression expr>			(. string name; expr = null; .)
=
  ident								(.  name = t.val;
  										expr = AstNode.MakeIdentifier(name);
  									.)
  | Literal<out expr>
  | '('
    [SequenceMaker<out expr, ObjectTypes.Tuple>]
    SYNC ')'						(.  if(expr == null)
    										expr = AstNode.MakeSeqInitializer(ObjectTypes.Tuple, new List<Expression>());
    								.)
  | '['
    [SequenceMaker<out expr, ObjectTypes.List>]
    SYNC ']'						(.  if(expr == null)
    										expr = AstNode.MakeSeqInitializer(ObjectTypes.List, new List<Expression>());
    								.)
  | '{'
    [DictMaker<out expr>]
    SYNC '}' 						(. if(expr == null) expr = AstNode.MakeSeqInitializer(ObjectTypes.Dict, new List<Expression>()); .).
/*------------------------------------------------------------------------*/
SequenceMaker<out Expression expr, ObjectTypes ObjType>	(.  Expression tmp = null; List<Expression> list = new List<Expression>();
															expr = null; ComprehensionIter comprehen = null;
														.)
=
  CondExpr<out tmp>						(. if(tmp != null) list.Add(tmp); .)
  ( { WEAK ','
    CondExpr<out tmp>					(. if(tmp != null) list.Add(tmp); .)
    }								    (. expr = AstNode.MakeSeqInitializer(ObjType, list); .)
  | CondExpr<out tmp>
    CompFor<out comprehen>              (. expr = AstNode.MakeComp(tmp, (ComprehensionForClause)comprehen, ObjType); .)
  ).
/*------------------------------------------------------------------------*/
DictMaker<out Expression expr>			(. Expression key, val; List<Expression> list = new List<Expression>(); expr = null; .)
=
  ( CondExpr<out key>					(. if(key != null) list.Add(key); .)
    ':'
    CondExpr<out val>					(. if(val != null) list.Add(val); .)
  )
  { ','
    CondExpr<out key>					(. if(key != null) list.Add(key); .)
    ':'
    CondExpr<out val>					(. if(val != null) list.Add(val); .)
  }
  										(. if(list.Count > 0) expr = AstNode.MakeSeqInitializer(ObjectTypes.Dict, list); .).
/*------------------------------------------------------------------------*/
CompIter<out ComprehensionIter expr>			(. expr = null; .)
=
  CompFor<out expr>
  | CompIf<out expr> .
/*------------------------------------------------------------------------*/
CompFor<out ComprehensionIter expr>		(. Expression rvalue = null; ComprehensionIter body = null; SequenceExpression target; .)
=
  "for"
  LValueList<out target>
  "in"
  ( IF(NotFollowedByDoubleDots())
    CondExpr<out rvalue>
  | IntSeqExpr<out rvalue>
  )
  [CompIter<out body>]					(. expr = AstNode.MakeCompFor(target, rvalue, body); .).
/*------------------------------------------------------------------------*/
CompIf<out ComprehensionIter expr>		(. Expression tmp; ComprehensionIter body = null; .)
=
  "if"
  OrTest<out tmp>
  [CompIter<out body>]					(. expr = AstNode.MakeCompIf(tmp, body); .).
/*------------------------------------------------------------------------*/
Literal<out Expression expr>	(. expr = null; string tmp; bool has_suffix = false; .)
= 
  integer						(. tmp = t.val; .)
  [ 'l'							(. has_suffix = true; .)
  | 'L'							(. has_suffix = true; .)
  ]								(.  if(has_suffix)
  										expr = AstNode.MakeConstant(ObjectTypes.BigInt, BigInteger.Parse(tmp));
  									else
  										expr = AstNode.MakeConstant(ObjectTypes.Integer, Convert.ToInt32(tmp));
  								.)
  | hex_digit					(. expr = AstNode.MakeConstant(ObjectTypes.Integer, Convert.ToInt32(t.val, 16)); .)
  | float						(. expr = AstNode.MakeConstant(ObjectTypes.Float, Convert.ToDouble(t.val)); .)
  | string_literal				(. tmp = t.val;
  								   tmp = tmp.Substring(1, tmp.Length - 2);
  								   expr = AstNode.MakeConstant(ObjectTypes.String, tmp);
  								.)
  | 
    ( "true"				
  	| "false"
  	)							(. expr = AstNode.MakeConstant(ObjectTypes.Bool, Convert.ToBoolean(t.val)); .)
  | "null"						(. expr = AstNode.MakeNullRef(); .)
  | "this"                      (. expr = AstNode.MakeThisRef(); .)
  | "base"                      (. expr = AstNode.MakeThisRef(); .).
/*------------------------------------------------------------------------*/
END Expresso.
