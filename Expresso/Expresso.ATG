using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Numerics;
using System.Text;

using Expresso.Ast;
using Expresso.Ast.Analysis;
using Expresso.TypeSystem;

using ICSharpCode.NRefactory;


using ExpressoModifiers = Expresso.Ast.Modifiers;



COMPILER Expresso
    internal SymbolTable Symbols{get; set;}
    public string ParsingFileName{get; set;}
	public ExpressoAst TopmostAst{get; private set;}	//the top-level AST the parser is parsing
    public TextLocation CurrentLocation{
        get{
            return new TextLocation(t.line, t.col);
        }
    }

	///<summary>
	/// Parser Implementation details:
	/// 	During parsing we'll construct the symbol table.
	/// 	And in post-parse process, do type validity check and flow analysis, including local name bindings
    ///     and type inference.
	///		Note that the identifiers are just placeholders until after doing name binding. 
	/// 	(Thus referencing them causes runtime exceptions)
	///</summary>
    ///<remarks>
    /// The Parser class itself is responsible for constructing the AST AND the symbol table.
    ///</remarks>
	Parser()
	{
        Symbols = new SymbolTable();
	}
	
	LiteralExpression CreateDefaultValue(KnownTypeCode type)
	{
		LiteralExpression result = null;
		var loc = CurrentLocation;
        var type_name = type.ToString().ToLower();

		switch(type){
		case KnownTypeCode.Int:
        case KnownTypeCode.UInt:
        case KnownTypeCode.Byte:
			result = Expression.MakeConstant(type_name, 0, loc);
			break;
			
		case KnownTypeCode.Bool:
			result = Expression.MakeConstant(type_name, false, loc);
			break;
			
		case KnownTypeCode.Float:
			result = Expression.MakeConstant(type_name, 0.0, loc);
			break;
			
		case KnownTypeCode.String:
			result = Expression.MakeConstant(type_name, "", loc);
			break;

        case KnownTypeCode.Char:
            result = Expression.MakeConstant(type_name, '\0', loc);
			break;

		default:
			SemErr("Unknown object type");
			break;
		}
		
		return result;
	}

    AstType CreateType(string keyword, TextLocation loc, bool isReference)
    {
        AstType type = new PrimitiveType(keyword, loc);
        if(isReference)
            type = new ReferenceType(type, loc);

        return type;
    }

    LiteralExpression CreateLiteral(string value, TextLocation loc)
    {
        string type_name = "int";
        object obj = null;
        string suffix = value.Substring(value.Length - 1);
        switch(suffix){
        case "u":
        case "U":
        {
            type_name = "uint";
            uint u;
            if(uint.TryParse(value.Substring(0, value.Length - 1), out u))
                obj = u;
            else
                SemErr("Invalid uint representation!");
            break;
        }

        case "l":
        case "L":
            type_name = "bigint";
            obj = BigInteger.Parse(value.Substring(0, value.Length - 1));
            break;

        case "f":
        case "F":
        {
            type_name = "float";
            float f;
            if(float.TryParse(value.Substring(0, value.Length - 1), out f))
                obj = f;
            else
                SemErr("Invalid float representation!");
            break; 
        }

        default:
        {
            double d;
            int i;
            if(int.TryParse(value, out i)){
                obj = i;
                type_name = "int";
            }else if(double.TryParse(value, out d)){
                obj = d;
                type_name = "double";
            }else{
                SemErr("Unknown sequence for numeric literals! Make sure that you write a number!");
            }
            break;
        }
        }

        return Expression.MakeConstant(type_name, obj, loc);
    }

    AstType ConvertPathToType(PathExpression path)
    {
        AstType type = null;
        foreach(var item in path.Items){
            if(type == null)
                type = new SimpleType(item, TextLocation.Empty);
            else
                type = new MemberType(type, item);
        }

        return type;
    }

    AstType CreateTypeWithArgs(string typeName, params AstType[] typeArgs)
    {
        return new SimpleType(typeName, typeArgs, TextLocation.Empty, TextLocation.Empty);
    }

    /// <summary>
    /// Creates a new <see ref="ICSharpCode.NRefactory.TextLocation">
    /// that points to the location n characters before the current.
    /// </summary>
    /// <remarks>
    /// It doesn't take line breaks into account.
    /// </remarks>
    TextLocation CreateLocationBefore(int n)
    {
        return new TextLocation(t.line, t.col - n);
    }

    void GoDownScope(int index = 0)
    {
        Symbols = Symbols.Children[index];
    }

    void GoUpScope()
    {
        Symbols = Symbols.Parent;
    }
	
	bool IsDefiningLValue()
	{
        return la.kind == _keyword_let || la.kind == _keyword_var;
	}
	
	bool IsSequenceInitializer()
	{
		Token x = la;
		if(x.kind != _comma)
            return true;
		
		while(x.kind != 0 && x.kind != _comma && x.kind != _keyword_for)
            x = scanner.Peek();
		
        scanner.ResetPeek();
        return x.kind != _keyword_for;
	}

    /*bool IsObjectCreation()
    {
        scanner.StartPeek();
        Token x = la;
        if(x.kind == 
    }

    bool IsIntegerSequenceExpression()
    {
        scanner.StartPeek();
        var x = la;
        while(x.kind != Tokens.)
    }*/

    bool NotFinalComma()
    {
        var t = la;
        var tt = scanner.Peek();
        scanner.ResetPeek();
        return t.kind == _comma && tt.kind != _rparen && tt.kind != _rbracket && tt.kind != _triple_dots;
    }
	
	public void SemanticError(string format, params object[] args)
	{
		//Convenient method for printing a semantic error with a format string
		SemErr(string.Format(format, args));
	}
	
/*--------------------------------------------------------------------------*/
CHARACTERS
  letter = 'A'..'Z' + 'a'..'z'.
  digit = '0'..'9'.
  hex_letter = digit + 'a'..'f' + 'A'..'F'.
  cr  = '\r'.
  lf  = '\n'.
  tab = '\t'.
  quotedStringLetter = ANY - '"'.
  quotedLetter = ANY - '\''.
  dot = '.'.

TOKENS
  double_dots = "..".
  triple_dots = "...".
  rbracket = ']'.
  colon = ':'.
  semicolon = ';'.
  lcurly = '{'.
  lparen = '('.
  lbracket = '['.
  rparen = ')'.
  rcurly = '}'.
  comma = ','.
  dot = '.'.
  ident  = (letter | '_') {'_' | letter | digit}.
  integer = ( digit {digit} ['u' | 'U' | 'l' | 'L']
            | digit {digit} CONTEXT("..")   /*This context includes triple dots case*/
            ).
  float = ( digit {digit} dot {digit} [('e' | 'E') ['+' | '-'] digit {digit}]
  		  | [digit {digit}] dot digit {digit} [('e' | 'E') ['+' | '-'] digit {digit}]
          ) ['f' | 'F'].
  hex_digit = '0' ('x' | 'X') hex_letter {hex_letter}.
  character_literal = '\'' [quotedLetter] '\''.
  string_literal = '"' {quotedStringLetter} '"'.
  keyword_for = "for".
  keyword_let = "let".
  keyword_var = "var".

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO lf

IGNORE cr + lf + tab



PRODUCTIONS
/*------------------------------------------------------------------------*/
Expresso                    		(. ExpressoAst module_decl = null; .)
= 
  ModuleBody<out module_decl>		(.
                                        Debug.Assert(Symbols.Parent == null);
                                        try{
                                            ExpressoNameBinder.BindAst(module_decl, this); //Here's the start of post-parse processing
                                        }
                                        catch(Exception e){
                                            SemErr(e.Message);
                                        }
  										this.TopmostAst = module_decl;	//Currently there is not so much code out there, though...
  									.).
/*------------------------------------------------------------------------*/
ModuleBody<out ExpressoAst ast>	    (.  var decls = new List<EntityDeclaration>();
                                        string module_name; Modifiers modifiers = ExpressoModifiers.None;
										List<ImportDeclaration> prog_defs = null; EntityDeclaration decl = null;
									.)
=
  ModuleNameDefinition<out module_name>
  [ ProgramDefinition<out prog_defs>
  ]
  								
  [ "export"						(. modifiers = ExpressoModifiers.Export; .)
  ]
  ( FuncDecl<out decl, modifiers>
  | ClassDecl<out decl, modifiers>
  )									(.  decls.Add(decl);
										modifiers = ExpressoModifiers.None;
									.)
  {
    [ "export"						(. modifiers = ExpressoModifiers.Export; .)
    ]
    ( FuncDecl<out decl, modifiers>
    | ClassDecl<out decl, modifiers>
    )								(.  decls.Add(decl);
    									modifiers = ExpressoModifiers.None;
    								.)
  }									(.  ast = AstNode.MakeModuleDef(module_name, decls, prog_defs); .) .
/*------------------------------------------------------------------------*/
ModuleNameDefinition<out string moduleName>
=                               (. .)
  "module"
  ident                         (. moduleName = t.val; .)
  { '.'
    ident
  }
  SYNC ';'.
/*------------------------------------------------------------------------*/
ProgramDefinition<. out List<ImportDeclaration> imports .>	(. imports = new List<ImportDeclaration>();
                                                               ImportDeclaration tmp;
                                                            .)
=
  ImportDecl<out tmp>			(. imports.Add(tmp); .)
  { ImportDecl<out tmp>		    (. imports.Add(tmp); .)
  }.
/*------------------------------------------------------------------------*/
ImportDecl<out ImportDeclaration decl>
            (.  decl = null; var has_in = false; PathExpression path;
				string alias = null; var entities = new List<PathExpression>();
			.)
=
  SYNC
  "import"
  PathExpression<out path>      (. entities.Add(path); .)
  ( [ "as"
      ident						(. alias = t.val; .)
    ]
  | { ','
      PathExpression<out path>  (. entities.Add(path); .)
    }
    [ "in"                      (. has_in = true; .)
      PathExpression<out path>
    ]
  )
  SYNC ';'                      (. if(has_in)
                                       decl = AstNode.MakeImportDecl(path, entities);
                                   else
                                       decl = AstNode.MakeImportDecl(entities[0], alias);
                                .).
/*------------------------------------------------------------------------*/
ClassDecl<out EntityDeclaration decl, Modifiers modifiers>   
  (.  EntityDeclaration entity = null; var decls = new List<EntityDeclaration>(); PathExpression path;
      string name; var bases = new List<AstType>(); Modifiers cur_flag; var start_loc = CurrentLocation;
  .)
=
  SYNC
  "class"                               (. Symbols.AddScope(); .)
  ident				    				(. name = t.val;
                                           Symbols.AddTypeSymbol(name, new SimpleType(name, TextLocation.Empty));
                                        .)
  [ ':'
    PathExpression<out path>		    (. bases.Add(ConvertPathToType(path)); .)
    { ','
      PathExpression<out path>			(. bases.Add(ConvertPathToType(path)); .)
    }
  ]
  '{'                                   (. GoDownScope(); .)
  { Modifiers<out cur_flag>
    ( MethodDecl<out entity, cur_flag>  (. decls.Add(entity); .)
    | FieldDecl<out entity, cur_flag>
      ';'								(. decls.Add(entity); .)
    | ClassDecl<out entity, cur_flag>   (. decls.Add(entity); .)
    )
  }
  SYNC '}'							    (. decl = EntityDeclaration.MakeClassDecl(name, bases, decls, modifiers, start_loc, CurrentLocation);
                                           GoUpScope();
                                        .) .
/*------------------------------------------------------------------------*/
Modifiers<out Modifiers modifiers>  (. modifiers = ExpressoModifiers.Private; .)
=
  { "public"                (. modifiers |= ExpressoModifiers.Public; .)
  | "protected"             (. modifiers |= ExpressoModifiers.Protected; .)
  | "private"               (. modifiers |= ExpressoModifiers.Private; .)
  | "static"                (. modifiers |= ExpressoModifiers.Static; .)
  }.
/*------------------------------------------------------------------------*/
MethodDecl<out EntityDeclaration decl, Modifiers modifiers>
                                (.
									string name; AstType type = null; BlockStatement block;
									var @params = new List<ParameterDeclaration>();
                                    var start_loc = CurrentLocation;
								.)
=
  SYNC
  "def"                         (. Symbols.AddScope(); .)
  ident							(. name = t.val;
                                   Symbols.AddSymbol(name, AstType.Null);
                                .)
  '('
  [ParamList<out @params>]
  ')'
  [ "->"
    Type<out type>
  ]                             (. if(type == null)
                                       type = new PlaceholderType(TextLocation.Empty);
                                .)
  Block<out block> 				(. decl = EntityDeclaration.MakeFunc(name, @params, block, type, modifiers, start_loc); .).
/*------------------------------------------------------------------------*/
FieldDecl<out EntityDeclaration field, Modifiers modifiers>
  (. string name; AstType type; Expression rhs; Identifier ident;
     var idents = new List<Identifier>(); var exprs = new List<Expression>();
     var start_loc = CurrentLocation;
  .)
= 
  ( "let"
  | "var"
  )
  VarDef<out name, out type, out rhs> (.  ident = AstNode.MakeIdentifier(name, type);
                                          idents.Add(ident);
                                          exprs.Add(rhs);
                                          Symbols.AddSymbol(name, ident);
                                      .)  
  { ','					 		
    VarDef<out name, out type, out rhs> (. ident = AstNode.MakeIdentifier(name, type);
                                           idents.Add(ident);
                                           exprs.Add(rhs);
                                           Symbols.AddSymbol(name, ident);
                                        .)
  }								       (. field = EntityDeclaration.MakeField(idents, exprs, modifiers, start_loc, CurrentLocation); .).
/*------------------------------------------------------------------------*/
Type<out AstType type>              (. var start_loc = CurrentLocation; type = AstType.Null; var is_reference = false; .)
=
 ['&']                              (. is_reference = true; .)
 ( "int"                			(. type = CreateType(t.val, start_loc, is_reference); .)
 | "uint"                           (. type = CreateType(t.val, start_loc, is_reference); .)
 | "bool"               			(. type = CreateType(t.val, start_loc, is_reference); .)
 | "float"							(. type = CreateType(t.val, start_loc, is_reference); .)
 | "double"                         (. type = CreateType(t.val, start_loc, is_reference); .)
 | "bigint"							(. type = CreateType(t.val, start_loc, is_reference); .)
 | "string"							(. type = CreateType(t.val, start_loc, is_reference); .)
 | "byte"						    (. type = CreateType(t.val, start_loc, is_reference); .)
 | "char"                           (. type = CreateType(t.val, start_loc, is_reference); .)
 | TupleTypeSignature<out type>
 | "vector"							(. type = CreateType(t.val, start_loc, is_reference); .)
 | "dictionary"						(. type = CreateType(t.val, start_loc, is_reference); .)
 | "function"						(. type = CreateType(t.val, start_loc, is_reference); .)
 | "intseq"							(. type = CreateType(t.val, start_loc, is_reference); .)
 | "void"							(. type = CreateType(t.val, start_loc, is_reference); .)
 | ident							(. type = CreateType(t.val, start_loc, is_reference); .)
 )                                  (. start_loc = CurrentLocation; .)
 /* Split brackets into 2 tokens that represents the array type
    because otherwise it conflicts with the array literal.
 */
 { '[' ']'                          (. if(type.IsNull)
                                           SemErr("Array of unknown type is specified. Unknown type is just unknown!");
                
                                       type = new SimpleType("array", new []{type}, start_loc, CurrentLocation);
                                    .)
 }                                  (. if(is_reference)
                                           type = new ReferenceType(type, TextLocation.Empty);
                                    .).
/*------------------------------------------------------------------------*/
TupleTypeSignature<out AstType type> (. var inners = new List<AstType>(); var start_loc = CurrentLocation; .)
=
  '('
  { Type<out type>                  (. inners.Add(type); .)
  }
  ')'                               (. type = new SimpleType("tuple", inners, start_loc, CurrentLocation); .).
/*------------------------------------------------------------------------*/
Stmt<out Statement stmt>			(. stmt = null; .)
=
  SimpleStmt<out stmt>
  | CompoundStmt<out stmt> .
/*------------------------------------------------------------------------*/
SimpleStmt<out Statement stmt>		(. stmt = null; BlockStatement block = null; .)
=	IF(la.kind == _lcurly)	/* For DictMaker and Block conflict. Since DictMaker should not be a statement, we always choose the first(Block).*/
    Block<out block>                (. stmt = block; .)
  | ExprStmt<out stmt>
  | VarDeclStmt<out stmt>
  | ReturnStmt<out stmt>
  | BreakStmt<out stmt>
  | ContinueStmt<out stmt>
  | YieldStmt<out stmt>
  | EmptyStmt<out stmt>.
/*------------------------------------------------------------------------*/
ReturnStmt<out Statement stmt>		(. SequenceExpression items = null; .)
=
  "return"
  [RValueList<out items>]
  SYNC ';'							(. stmt = Statement.MakeReturnStmt(items); .).
/*------------------------------------------------------------------------*/
BreakStmt<out Statement stmt>		(. int count = 1; var start_loc = CurrentLocation; .)
=
  "break"
  [ "upto"
    integer							(. count = Convert.ToInt32(t.val); .)
  ]
  SYNC ';' 							(. stmt = Statement.MakeBreakStmt(
                                            Expression.MakeConstant("int", count, start_loc), start_loc, CurrentLocation
                                       );
                                    .).
/*------------------------------------------------------------------------*/
ContinueStmt<out Statement stmt>	(. int count = 1; var start_loc = CurrentLocation; .)
= 
  "continue"
  [ "upto"
    integer							(. count = Convert.ToInt32(t.val); .)
  ]
  SYNC ';' 							(. stmt = Statement.MakeContinueStmt(
                                            Expression.MakeConstant("int", count, start_loc), start_loc, CurrentLocation
                                       );
                                    .).
/*------------------------------------------------------------------------*/
YieldStmt<out Statement stmt>		(. Expression expr; var start_loc = CurrentLocation; .)
=
  "yield"
  CondExpr<out expr>
  SYNC ';'							(. stmt = Statement.MakeYieldStmt(expr, start_loc, CurrentLocation); .).
/*------------------------------------------------------------------------*/
EmptyStmt<out Statement stmt>       (. var start_loc = CurrentLocation; .)
=
  SYNC ';'							(. stmt = Statement.MakeEmptyStmt(start_loc); .).
/*------------------------------------------------------------------------*/
AugAssignOpe<ref OperatorType type>
=
  ( "+="							(. type = OperatorType.Plus; .)
  | "-="							(. type = OperatorType.Minus; .)
  | "*="							(. type = OperatorType.Times; .)
  | "/="							(. type = OperatorType.Divide; .)
  | "**="							(. type = OperatorType.Power; .)
  | "%="							(. type = OperatorType.Modulus; .)
  | "&="							(. type = OperatorType.BitwiseAnd; .)
  | "|="							(. type = OperatorType.BitwiseOr; .)
  | "<<="							(. type = OperatorType.BitwiseShiftLeft; .)
  | ">>="							(. type = OperatorType.BitwiseShiftRight; .)
  ).
/*------------------------------------------------------------------------*/
ExprStmt<out Statement stmt>			(.  SequenceExpression lhs = null, seq = null;
											var start_loc = CurrentLocation; stmt = null;
											OperatorType op_type = OperatorType.None;
										.)
=
  LValueList<out lhs>
  { ( AugAssignOpe<ref op_type>
    | '='
    )
    RValueList<out seq>
  }										(.
  											if(lhs.Count != seq.Count)      //See if both sides have the same number of items
                                                SemErr("An augumented assignment must have both sides balanced.");
  													
  											if(op_type != OperatorType.None)
  												stmt = Statement.MakeAugumentedAssignment(lhs, seq, op_type, start_loc, CurrentLocation);
  											else
  												stmt = Statement.MakeAssignment(lhs, seq, start_loc, CurrentLocation);
  										.)
  SYNC ';' 								(.  if(stmt == null)
  												stmt = Statement.MakeExprStmt(lhs, start_loc, CurrentLocation);
  										.).
/*------------------------------------------------------------------------*/
LValueList<out SequenceExpression lhs>   (. var lvalues = new List<Expression>(); Expression tmp; .)
=
  Primary<out tmp>                              (. lvalues.Add(tmp); .)
  { Primary<out tmp>                            (. lvalues.Add(tmp); .)
  }                                             (. lhs = Expression.MakeSequence(lvalues); .).
/*------------------------------------------------------------------------*/
Block<out BlockStatement block, int index = 0>
                (. List<Statement> stmts = new List<Statement>();
                   Statement stmt; var start_loc = CurrentLocation;
                   Symbols.AddScope();
                .)
=
  '{'                       (. GoDownScope(index); .)
  Stmt<out stmt>			(. stmts.Add(stmt); .)
  { Stmt<out stmt>			(. stmts.Add(stmt); .)
  }
  '}' 						(. block = Statement.MakeBlock(stmts, start_loc, CurrentLocation);
                               GoUpScope();
                            .).
/*------------------------------------------------------------------------*/
CompoundStmt<out Statement stmt>	(. stmt = null; .)
=
  SYNC
    IfStmt<out stmt>					
  | WhileStmt<out stmt>
  | ForStmt<out stmt>
  | MatchStmt<out stmt>
  /*| FuncDecl<out stmt>*/.
/*------------------------------------------------------------------------*/
IfStmt<out Statement stmt>			(. PatternConstruct pattern; BlockStatement true_block, false_block = null;
                                       var start_loc = CurrentLocation;
                                    .)
=
  "if"                              (. Symbols.AddScope(); GoDownScope(); .)
  LhsPattern<out pattern>
  Block<out true_block>
  [ "else"
    Block<out false_block, 1>
  ]                      			(. stmt = Statement.MakeIfStmt(pattern, true_block, false_block, start_loc);
                                       GoUpScope();
                                    .).
/*------------------------------------------------------------------------*/
WhileStmt<out Statement stmt>		(. Expression cond; BlockStatement body; var start_loc = CurrentLocation; .)
=
  "while"
  CondExpr<out cond>
  Block<out body>                   (. stmt = Statement.MakeWhileStmt(cond, body, start_loc); .).
/*------------------------------------------------------------------------*/
ForStmt<out Statement stmt>			(.  PatternConstruct left; Expression rvalue; BlockStatement body;
                                        var start_loc = CurrentLocation;
									.)
=
  "for"                             (. Symbols.AddScope(); GoDownScope(); .)
  LhsPattern<out left>
  "in"
  CondExpr<out rvalue>
  Block<out body>					(. stmt = Statement.MakeForStmt(left, rvalue, body, start_loc);
                                       GoUpScope();
                                    .).
/*------------------------------------------------------------------------*/
MatchStmt<out Statement stmt>		(. Expression target; List<MatchPatternClause> matches;
                                       var start_loc = CurrentLocation;
                                    .)
=
  "match"
  CondExpr<out target>
  '{'                               (. Symbols.AddScope(); GoDownScope(); .)
  MatchPatternList<out matches>
  '}'								(. stmt = Statement.MakeMatchStmt(target, matches, start_loc, CurrentLocation);
                                       GoUpScope();
                                    .).
/*------------------------------------------------------------------------*/
MatchPatternList<. out List<MatchPatternClause> clauses .>
                                    (. clauses = new List<MatchPatternClause>(); List<PatternConstruct> pattern_list;
                                       Statement inner; Expression guard;
                                    .)
=
  PatternList<out pattern_list, out guard>
  Stmt<out inner>					(. clauses.Add(Statement.MakeMatchClause(pattern_list, guard, inner)); .)
  { PatternList<out pattern_list, out guard>
    Stmt<out inner>					(. clauses.Add(Statement.MakeMatchClause(pattern_list, guard, inner)); .)
  }.
/*------------------------------------------------------------------------*/
PatternList<. out List<PatternConstruct> patterns, out Expression guard .>
                        (. patterns = new List<PatternConstruct>(); PatternConstruct tmp; guard = null; .)
=
  Pattern<out tmp>                  (. patterns.Add(tmp); .)
  { SYNC '|'
    Pattern<out tmp>				(. patterns.Add(tmp); .)
  }
  [ "if"
    CondExpr<out guard>
  ]
  "=>".
/*------------------------------------------------------------------------*/
VarDeclStmt<out Statement stmt>         (.  string name; AstType type; Expression rhs = null;
								        	Identifier ident;
								          	var idents = new List<Identifier>(); var exprs = new List<Expression>();
                                            bool is_const = false; var start_loc = CurrentLocation;
								        .)
= 
  ( "let"                               (. is_const = true; .)
  | "var"
  )
  VarDef<out name, out type, out rhs>	(.  ident = AstNode.MakeIdentifier(name, type);
                                            idents.Add(ident);
  						 			        exprs.Add(rhs);
  						 			        rhs = null;
                                            Symbols.AddSymbol(name, ident);
  						 		        .)
  { WEAK ','
    VarDef<out name, out type, out rhs>(. ident = AstNode.MakeIdentifier(name, type);
                                          idents.Add(ident);
  									      exprs.Add(rhs);
  									      rhs = null;
                                          Symbols.AddSymbol(name, ident);
  								       .)
  }
  SYNC ';'							   (. var modifiers = is_const ? ExpressoModifiers.Immutable : ExpressoModifiers.None;
                                          stmt = Statement.MakeVarDecl(idents, exprs, modifiers, start_loc, CurrentLocation);
                                       .).
/*------------------------------------------------------------------------*/
VarDef<out string name, out AstType type, out Expression option> (. type = null; option = null; .)
=
  ident                        (. name = t.val; .)
  [ "(-"
    Type<out type>
  ]                            (. if(type == null)
                                      type = new PlaceholderType(TextLocation.Empty);
                               .)
  [ '='
    CondExpr<out option>
  ]                            (. if(type == null && option == null)
                                      SemanticError("Give me some context or I can't infer the type of {0}", name);
                               .).
/*------------------------------------------------------------------------*/
FuncDecl<out EntityDeclaration func, Modifiers modifiers>
                                (.  string name; AstType type = null; BlockStatement block = null;
									var @params = new List<ParameterDeclaration>();
                                    var start_loc = CurrentLocation;
								.)
=
  SYNC
  "def"                         (. Symbols.AddScope(); .)
  ident							(. name = t.val; .)
  '('
  [ParamList<out @params>]
  ')'
  [ "->"
    Type<out type>
  ]                             (. if(type == null)
                                       type = new PlaceholderType(TextLocation.Empty);
                                   
                                   Symbols.AddSymbol(name, AstType.Null);
                                .)
  Block<out block> 				(. func = EntityDeclaration.MakeFunc(name, @params, block, type, modifiers, start_loc); .).
/*------------------------------------------------------------------------*/
ParamList<. out List<ParameterDeclaration> @params .>	(. @params = new List<ParameterDeclaration>(); ParameterDeclaration expr; .)
=
  Parameter<out expr>							        (. @params.Add(expr); .)
  { WEAK ','
    Parameter<out expr>							        (. @params.Add(expr); .)
  }.
/*------------------------------------------------------------------------*/
Parameter<out ParameterDeclaration param>   (. string name; Expression option = null; AstType type; .)
=
  ident							            (. name = t.val; .)
  "(-"
  Type<out type>                            (. Symbols.Children[0].AddSymbol(name, type); .)
  [ '='
    Literal<out option>
  ]								            (. param = EntityDeclaration.MakeParameter(name, type, option); .).
/*------------------------------------------------------------------------*/
RValueList<out SequenceExpression seq>		(. Expression tmp; var exprs = new List<Expression>(); .)
=
  CondExpr<out tmp>							(. exprs.Add(tmp); .)
  { WEAK ','
    CondExpr<out tmp>						(. exprs.Add(tmp);	.)
  }											(. seq = Expression.MakeSequence(exprs); .).
/*------------------------------------------------------------------------*/
Pattern<out PatternConstruct pattern>   (. pattern = null; bool is_binding = false, is_const = false; .)
=
  [ "let"                               (. is_binding = true; is_const = true; .)
  | "var"                               (. is_binding = true; .)
  ]
  LhsPattern<out pattern>
  | ExpressionPattern<out pattern>      (. if(is_binding)
                                               pattern = PatternConstruct.MakeValueBindingPattern(pattern, is_const);
                                        .).
/*------------------------------------------------------------------------*/
ExpressionPattern<out PatternConstruct pattern> (. Expression expr, upper = null, step = null;
                                                   TextLocation loc; bool upper_inclusive = false;
                                                .)
=
  Literal<out expr>                                
  [ RangeOperator<ref upper_inclusive>          (. loc = CurrentLocation; .)
    integer                                     (. upper = Expression.MakeConstant("int", t.val, loc); .)
    [ ':'                                       (. loc = CurrentLocation; .)
      integer                                   (. step = Expression.MakeConstant("int", t.val, loc); .)
    ]                                           (. expr = Expression.MakeIntSeq(expr, upper, step, upper_inclusive); .)
  ]                                             (. pattern = PatternConstruct.MakeExpressionPattern(expr); .).
/*------------------------------------------------------------------------*/
PatternItem<out PatternConstruct pattern>   (. pattern = PatternConstruct.Null; .)
=
  ExpressionPattern<out pattern>
  | IdentifierPattern<out pattern>.
/*------------------------------------------------------------------------*/
LhsPattern<out PatternConstruct pattern>    (. pattern = PatternConstruct.Null; .)
=
  WildcardPattern<out pattern>
  | IdentifierPattern<out pattern>
  | TuplePattern<out pattern>
  | DestructuringPattern<out pattern>.
/*------------------------------------------------------------------------*/
WildcardPattern<out PatternConstruct pattern>
=
  '_'                               (. pattern = PatternConstruct.MakeWildcardPattern(); .).
/*------------------------------------------------------------------------*/
IdentifierPattern<out PatternConstruct pattern> (. PatternConstruct inner = null; string name; .)
=
  ident                             (. name = t.val;
                                       Symbols.AddSymbol(name, new PlaceholderType(TextLocation.Empty));
                                    .)
  [ '@'
    LhsPattern<out inner>
  ]                                 (. pattern = PatternConstruct.MakeIdentifierPattern(name, inner); .).
/*------------------------------------------------------------------------*/
TuplePattern<out PatternConstruct pattern>  (. var inners = new List<PatternConstruct>(); .)
=
  '('
  { ( LhsPattern<out pattern>
    | ExpressionPattern<out pattern>
    )                                       (. inners.Add(pattern); .)
    ','
  }
  ')'                                       (. pattern = PatternConstruct.MakeTuplePattern(inners); .).
/*------------------------------------------------------------------------*/
DestructuringPattern<out PatternConstruct pattern>  
                (. pattern = PatternConstruct.Null; PathExpression path;
                   var patterns = new List<PatternConstruct>(); bool is_vector = false;
                .)
=
  ( PathExpression<out path>
    '{'
    [ PatternItem<out pattern>              (. patterns.Add(pattern); .)
    ]
    { ','
      PatternItem<out pattern>              (. patterns.Add(pattern); .)
    }
    '}'                                     (. pattern = PatternConstruct.MakeDestructuringPattern(path, patterns); .)
  | '['
    [ PatternItem<out pattern>              (. patterns.Add(pattern); .)
    ]
    { IF(NotFinalComma()) WEAK ','
      PatternItem<out pattern>              (. patterns.Add(pattern); .)
    }
    [ ','
      "..."                                 (. is_vector = true; .)
    ]
    ']'                                     (. pattern = PatternConstruct.MakeCollectionPattern(patterns, is_vector); .)
  ).
/*------------------------------------------------------------------------*/
CondExpr<out Expression expr>		(. Expression true_expr, false_expr; .)
=
  OrTest<out expr>
  [ '?'
    OrTest<out true_expr>
    ':'
    CondExpr<out false_expr>		(. expr = Expression.MakeCondExpr(expr, true_expr, false_expr); .)
  ].
/*------------------------------------------------------------------------*/
OrTest<out Expression expr>			(. Expression rhs; .)
=
  AndTest<out expr>
  [ "||"
    OrTest<out rhs>                 (. expr = Expression.MakeBinaryExpr(OperatorType.ConditionalOr, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
AndTest<out Expression expr>		(. Expression rhs; .)
=
  Comparison<out expr>
  [ "&&"
    AndTest<out rhs>				(. expr = Expression.MakeBinaryExpr(OperatorType.ConditionalAnd, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
Comparison<out Expression expr>	    (. Expression rhs; OperatorType type; .)
=
  IntSeqExpr<out expr>				(. type = OperatorType.Equality; .)
  [ ComparisonOperator<out type>
    Comparison<out rhs>			    (. expr = Expression.MakeBinaryExpr(type, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
ComparisonOperator<out OperatorType opType> (. opType = OperatorType.None; .)
=
  ( "=="                    (. opType = OperatorType.Equality; .)
  | "!="                    (. opType = OperatorType.InEquality; .)
  | '<'                     (. opType = OperatorType.LessThan; .)
  | '>'                     (. opType = OperatorType.GreaterThan; .)
  | "<="                    (. opType = OperatorType.LessThanOrEqual; .)
  | ">="                    (. opType = OperatorType.GreaterThanOrEqual; .)
  ).
/*------------------------------------------------------------------------*/
IntSeqExpr<out Expression expr>     (. Expression start = null, end = null, step = null;
                                       bool upper_inclusive = true;
                                    .)
=
  BitOr<out start>                  (. expr = start; .)
  [ RangeOperator<ref upper_inclusive>
    BitOr<out end>
    [ ':'
      BitOr<out step>
    ]                               (. if(step == null) step = Expression.MakeConstant("int", 1, TextLocation.Empty);
                                       expr = Expression.MakeIntSeq(start, end, step, upper_inclusive);
                                    .)
  ].
/*------------------------------------------------------------------------*/
RangeOperator<ref bool upper_inclusive>
=
  ( ".."                                (. upper_inclusive = false; .)
  | "..."                               (. upper_inclusive = true; .)
  ).
/*------------------------------------------------------------------------*/
BitOr<out Expression expr>			(. Expression rhs; .)
=
  BitXor<out expr>
  [ '|'
    BitOr<out rhs>					(. expr = Expression.MakeBinaryExpr(OperatorType.BitwiseOr, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
BitXor<out Expression expr>			(. Expression rhs; .)
=
  BitAnd<out expr>
  [ '^'
    BitXor<out rhs>					(. expr = Expression.MakeBinaryExpr(OperatorType.ExclusiveOr, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
BitAnd<out Expression expr>			(. Expression rhs; .)
=
  ShiftOp<out expr>
  [ '&'
    BitAnd<out rhs> 			    (. expr = Expression.MakeBinaryExpr(OperatorType.BitwiseAnd, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
ShiftOp<out Expression expr>		(. Expression rhs; OperatorType type; .)
=
  AddOp<out expr>
  [ ShiftOperator<out type>
    ShiftOp<out rhs>				 (. expr = Expression.MakeBinaryExpr(type, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
ShiftOperator<out OperatorType opType>  (. opType = OperatorType.None; .)
=
  ( "<<"                            (. opType = OperatorType.BitwiseShiftLeft; .)
  | ">>"                            (. opType = OperatorType.BitwiseShiftRight; .)
  ).
/*------------------------------------------------------------------------*/
AddOp<out Expression expr>    		(. Expression rhs; OperatorType type; .)
= 
  Term<out expr>
  [ AdditiveOperator<out type>
    AddOp<out rhs>					(. expr = Expression.MakeBinaryExpr(type, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
AdditiveOperator<out OperatorType opType>   (. opType = OperatorType.None; .)
=
  ( '+'                             (. opType = OperatorType.Plus; .)
  | '-'                             (. opType = OperatorType.Minus; .)
  ).
/*------------------------------------------------------------------------*/
Term<out Expression expr>       (. Expression rhs; OperatorType type; .)
= 
  PowerOp<out expr>
  [ MultiplicativeOperator<out type>
    Term<out rhs>		        (. expr = Expression.MakeBinaryExpr(type, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
MultiplicativeOperator<out OperatorType opType>
                            (. opType = OperatorType.None; .)
=
  ( '*'                     (. opType = OperatorType.Times; .)
  | '/'                     (. opType = OperatorType.Divide; .)
  | '%'                     (. opType = OperatorType.Modulus; .)
  ).
/*------------------------------------------------------------------------*/
PowerOp<out Expression expr>   (. Expression rhs; .)
= 
  Factor<out expr>
  [ "**"
    Factor<out rhs>            (. expr = Expression.MakeBinaryExpr(OperatorType.Power, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
Factor<out Expression expr> (. OperatorType type; Expression factor; expr = null; .)
=
  Primary<out expr>
  |
  UnaryOperator<out type>
  Factor<out factor>        (. expr = Expression.MakeUnaryExpr(type, factor); .).
/*------------------------------------------------------------------------*/
UnaryOperator<out OperatorType opType>  (. opType = OperatorType.None; .)
=
  ( AdditiveOperator<out opType>
  | '!'                             (. opType = OperatorType.Not; .)
  | '&'                             (. opType = OperatorType.Reference; .)
  | '*'                             (. opType = OperatorType.Dereference; .)
  ).
/*------------------------------------------------------------------------*/
Primary<out Expression expr>		(. expr = null; PathExpression path; .)
=
  ( PathExpression<out path>        (. expr = path; .) /* It's possible that a PathExpression turns out to be just an Identifier */
    [ObjectCreation<path, out expr>]
  | Atom<out expr>
  | NewExpression<out expr>
  )
  { Trailer<ref expr>
  }.
/*------------------------------------------------------------------------*/
NewExpression<out Expression expr>      (. PathExpression path; .)
=
  "new"
  PathExpression<out path>
  ObjectCreation<path, out expr>        (. expr = Expression.MakeNewExpr((ObjectCreationExpression)expr); .).
/*------------------------------------------------------------------------*/
ObjectCreation<PathExpression path, out Expression expr>
                                        (. var fields = new List<Identifier>(); var values = new List<Expression>();
                                        .)
=
  '{'
  ident                                 (. fields.Add(AstNode.MakeIdentifier(t.val)); .)
  ':'
  CondExpr<out expr>                    (. values.Add(expr); .)
  { WEAK ','
    ident                               (. fields.Add(AstNode.MakeIdentifier(t.val)); .)
    ':'
    CondExpr<out expr>                  (. values.Add(expr); .)
  }
  '}'                                   (. expr = Expression.MakeObjectCreation(path, fields, values); .).
/*------------------------------------------------------------------------*/
Trailer<ref Expression expr>	(. var args = new List<Expression>(); .)
=
  '('
  [ArgList<out args>]
  ')'							(. expr = Expression.MakeCallExpr(expr, args); .)
  | '['
    ArgList<out args>
    ']'							(. expr = Expression.MakeIndexer(expr, args); .)
  | '.'
    ident						(. expr = Expression.MakeMemRef(expr, AstNode.MakeIdentifier(t.val)); .).
/*------------------------------------------------------------------------*/
ArgList<. out List<Expression> args .>		(. args = new List<Expression>(); Expression expr; .)
=
  CondExpr<out expr>						(. args.Add(expr); .)
  { WEAK ','
    CondExpr<out expr>						(. args.Add(expr); .)
  }.
/*------------------------------------------------------------------------*/
Atom<out Expression expr>			(. var exprs = new List<Expression>(); expr = null; .)
=
  Literal<out expr>
  | '('
    CondExpr<out expr>              (. exprs.Add(expr); .)
    { IF(NotFinalComma()) WEAK ','
      CondExpr<out expr>            (. exprs.Add(expr); .)
    }
    [',']
    ')'                             (. if(exprs.Count == 1)
                                           expr = Expression.MakeParen(exprs[0]);
                                       else
                                           expr = Expression.MakeParen(Expression.MakeSequence(exprs));
                                    .)
  | '['
    [SequenceMaker<out expr>]
    SYNC ']'						(.  if(expr == null){
                                            var type = CreateTypeWithArgs("array", new PlaceholderType(TextLocation.Empty));
    										expr = Expression.MakeSeqInitializer(type, Enumerable.Empty<Expression>());
                                        }
    								.)
  | '{'
    [DictMaker<out expr>]
    SYNC '}'                        (. if(expr == null){
                                           var type = CreateTypeWithArgs("dictionary", new PlaceholderType(TextLocation.Empty), new PlaceholderType(TextLocation.Empty));
                                           expr = Expression.MakeSeqInitializer(type, Enumerable.Empty<Expression>());
                                       }
                                    .).
/*------------------------------------------------------------------------*/
PathExpression<out PathExpression path> (. var paths = new List<Identifier>(); .)
=
  ident                                 (. paths.Add(AstNode.MakeIdentifier(t.val)); .)
  { "::"
    ident                               (. paths.Add(AstNode.MakeIdentifier(t.val)); .)
  }                                     (. path = Expression.MakePath(paths); .).
/*------------------------------------------------------------------------*/
SequenceMaker<out Expression expr>	(.  var exprs = new List<Expression>();
										expr = null; ComprehensionIter comp = null;
                                        string seq_type_name = "array";
									.)
=
  "..."                                 (. expr = Expression.MakeSeqInitializer(CreateTypeWithArgs("vector", new PlaceholderType(TextLocation.Empty)), Enumerable.Empty<Expression>()); .)
  | CondExpr<out expr>                  (. exprs.Add(expr); .)
  ( { IF(NotFinalComma()) WEAK ','
      CondExpr<out expr>                (. exprs.Add(expr); .)
    }
    [ ','
      "..."                             (. seq_type_name = "vector"; .)
    ]                                   (. var type = CreateTypeWithArgs(seq_type_name, new PlaceholderType(TextLocation.Empty));
                                           expr = Expression.MakeSeqInitializer(type, exprs); .)
  | CompFor<out comp>                   (. var type = CreateTypeWithArgs("vector", new PlaceholderType(TextLocation.Empty));
                                           expr = Expression.MakeComp(expr, (ComprehensionForClause)comp, type);
                                        .)
  ).
/*------------------------------------------------------------------------*/
DictMaker<out Expression expr>			(. Expression key, val; var list = new List<KeyValueLikeExpression>();
                                           KeyValueLikeExpression pair; ComprehensionIter comp; expr = null;
                                           var type = CreateTypeWithArgs("dictionary", new PlaceholderType(TextLocation.Empty), new PlaceholderType(TextLocation.Empty));
                                        .)
=
  BitOr<out key>
  ':'
  CondExpr<out val>                     (. pair = Expression.MakeKeyValuePair(key, val);
                                           list.Add(pair);
                                        .)
  ( { WEAK ','
      BitOr<out key>
      ':'
      CondExpr<out val>                 (. pair = Expression.MakeKeyValuePair(key, val);
                                           list.Add(pair);
                                        .)
    }                                   (. expr = Expression.MakeSeqInitializer(type, list); .)
  | CompFor<out comp>                   (. expr = Expression.MakeComp(pair, (ComprehensionForClause)comp, type); .)
  ).
/*------------------------------------------------------------------------*/
CompIter<out ComprehensionIter expr>    (. expr = null; .)
=
  CompFor<out expr>
  | CompIf<out expr> .
/*------------------------------------------------------------------------*/
CompFor<out ComprehensionIter expr>		(. Expression rvalue = null; ComprehensionIter body = null; PatternConstruct target; .)
=
  "for"
  LhsPattern<out target>
  "in"
  CondExpr<out rvalue>
  [CompIter<out body>]					(. expr = Expression.MakeCompFor(target, rvalue, body); .).
/*------------------------------------------------------------------------*/
CompIf<out ComprehensionIter expr>		(. Expression tmp; ComprehensionIter body = null; .)
=
  "if"
  OrTest<out tmp>
  [CompIter<out body>]					(. expr = Expression.MakeCompIf(tmp, body); .).
/*------------------------------------------------------------------------*/
Literal<out Expression expr>	(. expr = null; string tmp;
                                   var start_loc = CurrentLocation;
                                .)
= 
  integer						(. expr = CreateLiteral(t.val, start_loc); .)
  | hex_digit					(. expr = Expression.MakeConstant("int", Convert.ToInt32(t.val, 16), start_loc); .)
  | float						(. expr = CreateLiteral(t.val, start_loc); .)
  | character_literal           (. tmp = t.val;
                                   tmp = tmp.Substring(1, tmp.Length - 2);
                                   expr = Expression.MakeConstant("char", tmp, start_loc);
                                .)
  | string_literal				(. tmp = t.val;
  								   tmp = tmp.Substring(1, tmp.Length - 2);
  								   expr = Expression.MakeConstant("string", tmp, start_loc);
  								.)
  | "true"                      (. expr = Expression.MakeConstant("bool", true, start_loc); .)		
  | "false"                     (. expr = Expression.MakeConstant("bool", false, start_loc); .)
  | "self"                      (. expr = Expression.MakeSelfRef(start_loc); .)
  | "super"                     (. expr = Expression.MakeSuperRef(start_loc); .).
/*------------------------------------------------------------------------*/
END Expresso.
