using System.Collections.Generic;
using Expresso.Ast;
using Expresso.BuiltIns;
using Expresso.Interpreter;



COMPILER Expresso

	internal Scope cur_scope = new Scope();		//the current scope of variables
	private Scope funcs = new Scope();			//the namespace for funcTable
	public Block root = new Block();
	
	Constant CreateConstant(TYPES type)
	{
		Constant result = null;
		
		switch(type){
		case TYPES.INTEGER:
			result = new Constant{ValType = type, Value = new ExpressoPrimitive{Value = 0}};
			break;
			
		case TYPES.BOOL:
			result = new Constant{ValType = type, Value = new ExpressoPrimitive{Value = false}};
			break;
			
		case TYPES.FLOAT:
			result = new Constant{ValType = type, Value = new ExpressoPrimitive{Value = 0.0}};
			break;
			
		case TYPES.STRING:
			result = new Constant{ValType = type, Value = new ExpressoPrimitive{Value = ""}};
			break;
			
		default:
			SemErr("Unknown object type");
			break;
		}
		
		return result;
	}
	
	bool NotFollowedByDoubleDots()
	{
		Token x = la;
		while(x.kind == _integer) x = scanner.Peek();
		return x.kind != _double_dots;
	}
	
	bool NotLookAtCurly()
	{
		return t.kind != _lcurly;
	}
	
	Parameter DeclareVariable(ref Expression rhs, string name, TYPES type)
	{
		var variable = new Parameter{
  			Name = name,
  			ParamType = type
  		};
  		if(rhs == null){
  			if(type == TYPES.VAR) SemErr("Can not declare a variable of \"var\" without initialization!");
  			rhs = CreateConstant(type);
  		}
  							
 		cur_scope.AddLocal(variable);
 		return variable;
	}
	
	static ExprStatement MakeExprStatement(List<Expression> exprs)
	{
		return new ExprStatement{Expressions = exprs};
	}
	
	static IfStatement MakeIfStatement(Expression condition, Statement trueBlock, Statement falseBlock)
	{
		return new IfStatement{Condition = condition, TrueBlock = trueBlock, FalseBlock = falseBlock};
	}
	
	static WhileStatement MakeWhileStatement(Expression condition, Statement body)
	{
		return new WhileStatement{Condition = condition, Body = body};
	}
	
	static ForStatement MakeForStatement(List<Expression> lValues, Expression rValue, Statement body)
	{
		return new ForStatement{LValues = lValues, Target = rValue, Body = body};
	}
	
	static SwitchStatement MakeSwitchStatement(Expression target, List<CaseClause> cases)
	{
		return new SwitchStatement{Target = target, Cases = cases};
	}
	
	static CaseClause MakeCaseClause(List<Expression> labels, Statement body)
	{
		return new CaseClause{Labels = labels, Body = body};
	}
	
	static Function MakeFunc(string name, List<Argument> parameters, Block body, TYPES returnType)
	{
		return new Function{Name = name, Parameters = parameters, Body = body, ReturnType = returnType};
	}
	
	static UnaryExpression MakeUnaryExpr(OperatorType op, Expression operand)
	{
		return new UnaryExpression{Operator = op, Operand = operand};
	}
	
	static BinaryExpression MakeBinaryExpr(OperatorType op, Expression lhs, Expression rhs)
	{
		return new BinaryExpression{Operator = op, Left = lhs, Right = rhs};
	}
	
	static ObjectInitializer MakeObjInitializer(TYPES type, List<Expression> initializeList)
	{
		return new ObjectInitializer{InitializeList = initializeList, ObjType = type};
	}
	
	static Assignment MakeAssignment(List<Expression> targets, List<Expression> expressions)
	{
		return new Assignment{Targets = targets, Expressions = expressions};
	}
	
	static Iteration MakeIteration(List<Expression> targets, List<Expression> exprs)
	{
		return new Iteration{Targets = targets, Expressions = exprs};
	}
	
	static Comprehension MakeComp(Expression body, Expression child)
	{
		return new Comprehension{Body = body, Child = child};
	}
	
	static ComprehensionFor MakeCompFor(Expression iteration, Expression body)
	{
		return new ComprehensionFor{Iteration = iteration, Body = body};
	}
	
	static ComprehensionIf MakeCompIf(Expression condition, Expression body)
	{
		return new ComprehensionIf{Condition = condition, Body = body};
	}
	
	static Constant MakeConstant(TYPES type, object val)
	{
		return new Constant{ValType = type, Value = val};
	}
	
	static IntSeqExpression MakeIntSeq(int start, int end, int step)
	{
		return new IntSeqExpression{Start = start, End = end, Step = step};
	}
	
/*--------------------------------------------------------------------------*/
CHARACTERS
  letter = 'A'..'Z' + 'a'..'z'.
  digit = '0'..'9'.
  cr  = '\r'.
  lf  = '\n'.
  tab = '\t'.
  quotedLetter = ANY - '"' - '\''.

TOKENS
  ident  = (letter | '_') {'_' | letter | digit}.
  integer = digit {digit}.
  float = digit {digit} "." ["e"] ["+" | "-"] digit {digit}.
  string_literal = '"' {quotedLetter} '"'.
  double_dots = "..".
  colon = ':'.
  semicolon = ';'.
  lcurly = '{'.

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO lf

IGNORE cr + lf + tab



PRODUCTIONS
/*------------------------------------------------------------------------*/
Expresso                    (. Statement stmt; .)
= 
  //ProgramDefinition
  FuncDecl<out stmt>		(. root.Statements.Add(stmt); .)
    
  {  ExprStmt<out stmt>		(. root.Statements.Add(stmt); .)
  |  FuncDecl<out stmt>		(. root.Statements.Add(stmt); .)
  }.
/*------------------------------------------------------------------------*/
/*ProgramDefinition<out Statement require>
=
  RequireStmt<out require>.*/
/*------------------------------------------------------------------------*/
Type<out TYPES type>
=                        (. type = TYPES.UNDEF; .)
 ( "int"                 (. type = TYPES.INTEGER; .)
 | "bool"                (. type = TYPES.BOOL; .)
 | "float"				 (. type = TYPES.FLOAT; .)
 | "rational"			 (. type = TYPES.RATIONAL; .)
 | "big_int"			 (. type = TYPES.BIGINT; .)
 | "string"				 (. type = TYPES.STRING; .)
 | "char_seq"			 (. type = TYPES.CHARSEQ; .)
 | "var"				 (. type = TYPES.VAR; .)
 | "tuple"				 (. type = TYPES.TUPLE; .)
 | "list"				 (. type = TYPES.LIST; .)
 | "dictionary"			 (. type = TYPES.DICT; .)
 | "expression"			 (. type = TYPES.EXPRESSION; .)
 | "function"			 (. type = TYPES.FUNCTION; .)
 | "int_seq"			 (. type = TYPES.SEQ; .)
 ).
/*------------------------------------------------------------------------*/
Stmt<out Statement stmt>			(. stmt = null; .)
=
  SimpleStmt<out stmt>
  | CompoundStmt<out stmt> .
/*------------------------------------------------------------------------*/
SimpleStmt<out Statement stmt>		(. stmt = null; .)
=		/* For DictMaker and Block conflict. Since DictMaker should not be a lvalue, we always choose the first(Block).*/
    Block<out stmt>
  | ExprStmt<out stmt>
  | PrintStmt<out stmt>
  | ReturnStmt<out stmt>
  | BreakStmt<out stmt>
  | ContinueStmt<out stmt>.
/*------------------------------------------------------------------------*/
PrintStmt<out Statement stmt>		(. List<Expression> exprs; .)
=
  "print"
  RValueList<out exprs>
  SYNC ';'							(. stmt = new PrintStatement{Expressions = exprs}; .).
/*------------------------------------------------------------------------*/
ReturnStmt<out Statement stmt>		(. List<Expression> target_list = new List<Expression>(); .)
=
  "return"
  [RValueList<out target_list>]
  SYNC ';'							(. stmt = new Return{Expressions = target_list}; .).
/*------------------------------------------------------------------------*/
BreakStmt<out Statement stmt>		(. int count = 1; .)
=
  "break"
  [  "upto"
     integer						(. count = Convert.ToInt32(t.val); .)
  ]
  SYNC ';' 							(. stmt = new BreakStatement{Count = count}; .).
/*------------------------------------------------------------------------*/
ContinueStmt<out Statement stmt>	(. int count = 1; .)
= 
  "continue"
  [  "upto"
     integer						(. count = Convert.ToInt32(t.val); .)
  ]
  SYNC ';' 							(. stmt = new ContinueStatement{Count = count}; .).
/*------------------------------------------------------------------------*/
/*RequireStmt<out Statement stmt>
=
  "require"
  Module<out module>
  [  "as"
     Name<out name>
  ]
  {  ','
     Module<out module>
     [  "as"
        Name<out name>
     ]
  }
  SYNC ';' .*/
/*------------------------------------------------------------------------*/
/*AugAssignOpe<TYPES type>
=
  (  "+="					(. .)
  |  "-="
  |  "*="
  |  "/="
  |  "**="
  |  "%="
  ).*/
/*------------------------------------------------------------------------*/
ExprStmt<out Statement stmt>				(. List<Expression> targets = null; List<Expression> expr_list; stmt = null; .)
=
  (  VarDecl<out targets>
  |  RValueList<out targets>
    {  //AugAssignOpe
       //ExprList<out expr_list>
    /*|*/  '='
	   RValueList<out expr_list>			(. stmt = MakeAssignment(targets, expr_list); .)
  }
  )SYNC ';' 								(. if(stmt == null) stmt = MakeExprStatement(targets); .).
/*------------------------------------------------------------------------*/
Block<out Statement block, bool needsScope = true>	(. Block tmp; if(needsScope) cur_scope = new Scope{Parent = cur_scope}; Statement stmt; .)
=
  '{'								(. tmp = new Block(); .)
  Stmt<out stmt>					(. tmp.Statements.Add(stmt); .)
  { Stmt<out stmt>					(. tmp.Statements.Add(stmt); .)
  }
  SYNC '}' 							(. cur_scope = cur_scope.Parent; block = tmp; .).
/*------------------------------------------------------------------------*/
CompoundStmt<out Statement stmt>	(. stmt = null; .)
=
    IfStmt<out stmt>					
  | WhileStmt<out stmt>
  | ForStmt<out stmt>
  | SwitchStmt<out stmt>
  | FuncDecl<out stmt>.
/*------------------------------------------------------------------------*/
IfStmt<out Statement stmt>			(. Expression tmp; Statement true_block, false_block = null; .)
=
  "if" 
  '(' CondExpr<out tmp> ')'
  Stmt<out true_block>
  [ "else"
     Stmt<out false_block>
  ]                      			(. stmt = MakeIfStatement(tmp, true_block, false_block); .).
/*------------------------------------------------------------------------*/
WhileStmt<out Statement stmt>		(. Expression cond; Statement body = null; .)
=
  "while"
  '(' CondExpr<out cond> ')'
  Stmt<out body>                   	(. stmt = MakeWhileStatement(cond, body); .).
/*------------------------------------------------------------------------*/
ForStmt<out Statement stmt>			(. List<Expression> target_list; Expression rvalue; Statement body; .)
=
  "for"
  '('
  LValueList<out target_list>
  "in"
  CondExpr<out rvalue>
  ')'
  Stmt<out body>					(. stmt = MakeForStatement(target_list, rvalue, body); .).
/*------------------------------------------------------------------------*/
SwitchStmt<out Statement stmt>		(. Expression target; List<CaseClause> cases; .)
=
  "switch"
  '('
  CondExpr<out target>
  ')'
  '{'
  CaseClauseList<out cases>
  SYNC '}'							(. stmt = MakeSwitchStatement(target, cases); .).
/*------------------------------------------------------------------------*/
CaseClauseList<. out List<CaseClause> clauses .>	(. clauses = new List<CaseClause>(); List<Expression> label_list; Statement inner; .)
=
  CaseLabelList<out label_list>
  Stmt<out inner>									(. clauses.Add(MakeCaseClause(label_list, inner)); .)
  {  CaseLabelList<out label_list>
     Stmt<out inner>								(. clauses.Add(MakeCaseClause(label_list, inner)); .)
  }.
/*------------------------------------------------------------------------*/
CaseLabelList<. out List<Expression> label_list .>	(. label_list = new List<Expression>(); Expression tmp; .)
=
  CaseLabel<out tmp>								(. label_list.Add(tmp); .)
  {  CaseLabel<out tmp>								(. label_list.Add(tmp); .)
  }.
/*------------------------------------------------------------------------*/
CaseLabel<out Expression expr>						(. expr = null; .)
=
  "case"
  (
    Literal<out expr>
  | ( '('
      IntSeqExpr<out expr>
      ')'
    )
  | "default"										(. expr = MakeConstant(TYPES._CASE_DEFAULT, "default"); .)
  )
  SYNC ':' .
/*------------------------------------------------------------------------*/
LValueList<. out List<Expression> targets .>		(. Expression tmp; .)
=													(. targets = new List<Expression>(); .)
  AddOpe<out tmp>									(. targets.Add(tmp); .)
  { WEAK ','
    AddOpe<out tmp>									(. targets.Add(tmp); .)
  }
  /*[',']*/ .
/*------------------------------------------------------------------------*/
VarDecl<. out List<Expression> outs .> 	(. string name; TYPES type; Expression rhs = null; Parameter variable; outs = new List<Expression>();
								   			var vars = new List<Parameter>(); var exprs = new List<Expression>();
										.)
= 
  "let"							(. type = TYPES.VAR; .)
  Variable<out name>
  [ "(-"
    Type<out type>
  ]
  [ '='
    CondExpr<out rhs>
  ]
  { ','					 (. variable = DeclareVariable(ref rhs, name, type);
 						 	vars.Add(variable);
  						 	exprs.Add(rhs);
  						 .)
    Variable<out name>
  	[ "(-"
   	  Type<out type>
  	]
  	[ '='
  	  CondExpr<out rhs>
  	]
  }						(. variable = DeclareVariable(ref rhs, name, type);
  					   	   vars.Add(variable);
  					   	   exprs.Add(rhs);
  					   
  					   	   outs.Add(new VarDeclaration{
  					   			Variables = vars,
  					   			Expressions = exprs
  					   	   });
  						.).
/*------------------------------------------------------------------------*/
FuncDecl<out Statement func>    (. string name; TYPES type; Statement block; List<Argument>@params = new List<Argument>(); .)
=
  "def"							(. type = TYPES.VAR; block = null; cur_scope = new Scope{Parent = cur_scope}; .)
  ident							(. name = t.val; .)
  '('
  [ParamList<ref @params>]
  ')'
  [  "(-"
     Type<out type>
  ]
  Block<out block, false> 		(. func = MakeFunc(name, @params, (Block)block, type);
  								   funcs.AddFunction(func as Function);
  								.).
/*------------------------------------------------------------------------*/
ParamList<. ref List<Argument> @params .>		(. Argument expr; .)
=
  Argument<out expr>							(. @params.Add(expr); .)
  {  ','
     Argument<out expr>							(. @params.Add(expr); .)
  }.
/*------------------------------------------------------------------------*/
Argument<out Argument arg>		(. string name; Expression default_val = null; TYPES type = TYPES.VAR; .)
=
  Variable<out name>
  [ "(-"
    Type<out type>
  ]
  [ '='
    Literal<out default_val>
  ]									(. Parameter param = new Parameter{Name = name, ParamType = type};
  									   cur_scope.AddLocal(param);
  									   arg = new Argument{
  											Name = name,
  											ParamType = type,
  											Option = default_val
  									   };
  									.).
/*------------------------------------------------------------------------*/
RValueList<. out List<Expression> exprs .>		(. Expression tmp; .)
=												(. exprs = new List<Expression>(); .)
  CondExpr<out tmp>								(. exprs.Add(tmp); .)
  { ','
    CondExpr<out tmp>							(. exprs.Add(tmp); .)
  }
  /*[',']*/ .
/*------------------------------------------------------------------------*/
CondExpr<out Expression expr>		(. Expression true_expr, false_expr; .)
=
  OrTest<out expr>
  [ '?'
    OrTest<out true_expr>
    ':'
    CondExpr<out false_expr>		(. expr = new ConditionalExpression{
    										Condition = expr,
    										TrueExpression = true_expr,
    										FalseExpression = false_expr
    								   };
    								.)
  ].
/*------------------------------------------------------------------------*/
OrTest<out Expression expr>			(. Expression rhs; .)
=
  AndTest<out expr>
  {
    "or"
    AndTest<out rhs>				(. expr = MakeBinaryExpr(OperatorType.OR, expr, rhs); .)
  }.
/*------------------------------------------------------------------------*/
AndTest<out Expression expr>		(. Expression rhs; .)
=
  NotTest<out expr>
  {
    "and"
    NotTest<out rhs>				(. expr = MakeBinaryExpr(OperatorType.AND, expr, rhs); .)
  }.
/*------------------------------------------------------------------------*/
NotTest<out Expression expr>		(. Expression term; expr = null; .)
=
  ( "not"
    NotTest<out term>				(. expr = MakeUnaryExpr(OperatorType.MINUS, term); .)
  | Comparison<out expr>
  ).
/*------------------------------------------------------------------------*/
Comparison<out Expression expr>		(. Expression rhs; OperatorType type; .)
=
  BitOr<out expr>			(. type = OperatorType.EQUAL; .)
  [
    ( "=="               	(. type = OperatorType.EQUAL; .)
    | "!="					(. type = OperatorType.NOTEQ; .)
    | '<'                	(. type = OperatorType.LESS; .)
    | '>'                	(. type = OperatorType.GREAT; .)
    | "<="				 	(. type = OperatorType.LESE; .)
    | ">="				 	(. type = OperatorType.GRTE; .)
    )
    BitOr<out rhs>			(. expr = MakeBinaryExpr(type, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
BitOr<out Expression expr>			(. Expression rhs; .)
=
  BitXor<out expr>
  {  '|'
     BitXor<out rhs>				(. expr = MakeBinaryExpr(OperatorType.BIT_OR, expr, rhs); .)
  }.
/*------------------------------------------------------------------------*/
BitXor<out Expression expr>			(. Expression rhs; .)
=
  BitAnd<out expr>
  {  '^'
     BitAnd<out rhs>				(. expr = MakeBinaryExpr(OperatorType.BIT_XOR, expr, rhs); .)
  }.
/*------------------------------------------------------------------------*/
BitAnd<out Expression expr>			(. Expression rhs; .)
=
  ShiftOpe<out expr>
  {  '&'
     ShiftOpe<out rhs>				(. expr = MakeBinaryExpr(OperatorType.BIT_AND, expr, rhs); .)
  }.
/*------------------------------------------------------------------------*/
ShiftOpe<out Expression expr>		(. Expression rhs; OperatorType type; .)
=
  AddOpe<out expr>
  {  ( "<<" 						(. type = OperatorType.BIT_LSHIFT; .)
     | ">>"							(. type = OperatorType.BIT_RSHIFT; .)
     )
     AddOpe<out rhs>				(. expr = MakeBinaryExpr(type, expr, rhs); .)
  }.
/*------------------------------------------------------------------------*/
AddOpe<out Expression expr>    (. Expression rhs; OperatorType type; .)
= 
  Term<out expr>
  { 
    ( '+'							(. type = OperatorType.PLUS; .)
    | '-'							(. type = OperatorType.MINUS; .)
    )
    Term<out rhs>					(. expr = MakeBinaryExpr(type, expr, rhs); .)
  }.
/*------------------------------------------------------------------------*/
Term<out Expression expr>   (. Expression rhs; OperatorType type; .)
= 
  Factor<out expr>
  {
    ( '*'					(. type = OperatorType.TIMES; .)
    | '/'					(. type = OperatorType.DIV; .)
    | '%'					(. type = OperatorType.MOD; .)
    )
    Factor<out rhs>			(. expr = MakeBinaryExpr(type, expr, rhs); .)
  }.
/*------------------------------------------------------------------------*/
Factor<out Expression expr> (. OperatorType type; Expression factor; expr = null; .)
=
  PowerOpe<out expr>
  | ( '-' 					(. type = OperatorType.MINUS; .)
    | '+'			 		(. type = OperatorType.PLUS; .)
    )
  Factor<out factor>	 	(. expr = MakeUnaryExpr(type, factor); .).
/*------------------------------------------------------------------------*/
PowerOpe<out Expression expr>    (. Expression rhs; .)
= 
  Primary<out expr>
  [ "**"
    Factor<out rhs>              (. expr = MakeBinaryExpr(OperatorType.POWER, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
Primary<out Expression expr>	(. string name = ""; expr = null; .)
=
  (  Atom<out expr>
  |  ident						(. name = t.val; .)
  )
  {  Trailer<ref expr, name>
  }.
/*------------------------------------------------------------------------*/
Trailer<ref Expression expr, string name>	(. Function func; List<Expression> args = new List<Expression>(); Expression subscript; .)
=
  '('
  [ArgList<ref args>]
  ')'							(. func = funcs.GetFunction(name);
  								   if(func == null){
  								   		SemErr("The function is not defined : " + name);
  								   }
  								   expr = new Call{
  								   		Function = func,
  										Arguments = args
  								   };
  						 		.)
  |  '['
     Subscript<out subscript>
     ']'						(. expr = new MemberReference{
     									Parent = expr,
     									Subscription = subscript
     							   };
     							.)
  |  '.'
     ident						(. subscript = new Parameter{
     									Name = t.val,
     									ParamType = TYPES.SUBSCRIPT
     							   };
     							   expr = new MemberReference{
     							   		Parent = expr,
     							   		Subscription = subscript
     							   };
     							.).
/*------------------------------------------------------------------------*/
Subscript<out Expression subscript>	(. subscript = null; .)
=
  CondExpr<out subscript>.
/*------------------------------------------------------------------------*/
ArgList<. ref List<Expression> args .>		(. Expression expr; .)
=
  Primary<out expr>							(. args.Add(expr); .)
  {  ','
     Primary<out expr>						(. args.Add(expr); .)
  }.
/*------------------------------------------------------------------------*/
Atom<out Expression expr>			(. string name; expr = null; .)
=
  Variable<out name>				(. expr = cur_scope.GetVariable(name);
  									   if(expr == null){
  									   		SemErr(string.Format("Attempt to refer to an undefined variable \"{0}\"", name));
  									   }
  									.)
  | (  IF(NotFollowedByDoubleDots())		/* For float and IntSeqExpr confilct.*/
       Literal<out expr>
    |  IntSeqExpr<out expr>
    )
  | '('
    [TupleMaker<out expr>]
    SYNC ')'
  | '['
    [ListMaker<out expr>]
    SYNC ']'
  | '{'
    [DictMaker<out expr>]
    SYNC '}' .
/*------------------------------------------------------------------------*/
IntSeqExpr<out Expression expr>		(. int start, end, step; .)
=
  integer							(. start = Convert.ToInt32(t.val); end = -1; step = 1; .)
  ".."
  [integer]							(. end = Convert.ToInt32(t.val); .)
  [ ':'
    integer							(. step = Convert.ToInt32(t.val); .)
  ]									(. expr = MakeIntSeq(start, end, step); .).
/*------------------------------------------------------------------------*/
TupleMaker<out Expression expr>			(. Expression tmp; List<Expression> list = new List<Expression>(); expr = null; .)
=
  CondExpr<out tmp>						(. list.Add(tmp); .)
  (  //CompFor<out comp_expr>
  /*|*/  {  ','
        CondExpr<out tmp>				(. list.Add(tmp); .)
     }
     /*[',']*/
  )										(. expr = MakeObjInitializer(TYPES.TUPLE, list); .).
/*------------------------------------------------------------------------*/
ListMaker<out Expression expr>			(. expr = null; Expression tmp; List<Expression> list = new List<Expression>(); .)
=
  CondExpr<out tmp>						(. list.Add(tmp); .)
  ( CompFor<out tmp>					(. expr = MakeComp(list[0], tmp); .)
  | {  ','
       CondExpr<out tmp>				(. list.Add(tmp); .)
    }
    /*[',']*/
  )										(. if(expr == null) expr = MakeObjInitializer(TYPES.LIST, list); .).
/*------------------------------------------------------------------------*/
DictMaker<out Expression expr>			(. Expression lhs, rhs; List<Expression> list = new List<Expression>(); .)
=
  CondExpr<out lhs>						(. list.Add(lhs); .)
  ':'
  CondExpr<out rhs>						(. list.Add(rhs); .)
  (
    {  ','
       CondExpr<out lhs>				(. list.Add(lhs); .)
       ':'
       CondExpr<out rhs>				(. list.Add(rhs); .)
    }
    /*[',']*/
  )										(. expr = MakeObjInitializer(TYPES.DICT, list); .).
/*------------------------------------------------------------------------*/
CompIter<out Expression expr>			(. expr = null; .)
=
  CompFor<out expr>
  |  CompIf<out expr> .
/*------------------------------------------------------------------------*/
CompFor<out Expression expr>			(. Expression iter, body = null; List<Expression> expr_list, test_list; .)
=
  "for"
  LValueList<out expr_list>
  "in"
  RValueList<out test_list>				(. iter = MakeIteration(expr_list, test_list); .)
  [CompIter<out body>]					(. expr = MakeCompFor(iter, body); .).
/*------------------------------------------------------------------------*/
CompIf<out Expression expr>				(. Expression tmp, body = null; .)
=
  "if"
  OrTest<out tmp>
  [CompIter<out body>]					(. expr = MakeCompIf(tmp, body); .).
/*------------------------------------------------------------------------*/
Variable<out string name>
= WEAK '$'
  ident				(. name = t.val; .).
/*------------------------------------------------------------------------*/
Literal<out Expression expr>	(. expr = null; .)
= 
  integer				(. expr = MakeConstant(TYPES.INTEGER, Convert.ToInt32(t.val)); .)
  |  float				(. expr = MakeConstant(TYPES.FLOAT, Convert.ToDouble(t.val)); .)
  |  string_literal		(. string tmp = t.val;
  						   tmp = tmp.Substring(1, tmp.Length - 2);
  						   expr = MakeConstant(TYPES.STRING, tmp);
  						.)
  |  (  "true"				
  	 |  "false"
  	 )					(. expr = MakeConstant(TYPES.BOOL, Convert.ToBoolean(t.val)); .)
  |  "null"				(. expr = MakeConstant(TYPES.NULL, null); .).
/*------------------------------------------------------------------------*/
END Expresso.
