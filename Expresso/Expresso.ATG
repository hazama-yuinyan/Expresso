using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using System.Numerics;
using System.Text.RegularExpressions;

using Expresso.Ast;
using Expresso.Ast.Analysis;
using Expresso.TypeSystem;

using ICSharpCode.NRefactory;


using ExpressoModifiers = Expresso.Ast.Modifiers;


COMPILER Expresso

$namespace=Expresso
    static uint ScopeId = 1;
    static Regex UnicodeEscapeFinder = new Regex(@"\\[uU]([\dA-Fa-f]{4}|[\dA-Fa-f]{6})", RegexOptions.Compiled);
    internal SymbolTable Symbols{get; set;}
    /// <summary>
    /// This flag determines whether we are doing post-parse processing including name binding,
    /// type validity check, type inference and flow analisys.
    /// </summary>
    public bool DoPostParseProcessing{get; set;}
	public ExpressoAst TopmostAst{get; private set;}	//the top-level AST the parser is parsing
    public TextLocation CurrentLocation{
        get{
            return new TextLocation(t.line, t.col);
        }
    }

    public TextLocation NextLocation{
        get{
            return new TextLocation(la.line, la.col);
        }
    }

	///<summary>
	/// Parser Implementation details:
	/// 	During parsing we'll construct the symbol table.
	/// 	And in post-parse process, do type validity check and flow analysis, including local name bindings
    ///     and type inference.
	///		Note that the identifiers are just placeholders until after doing name binding. 
	/// 	(Thus referencing them causes runtime exceptions)
	///</summary>
    ///<remarks>
    /// The Parser class itself is responsible for constructing the AST AND the symbol table.
    ///</remarks>
	Parser()
	{
        DoPostParseProcessing = false;
        Symbols = new SymbolTable();
	}
	
	LiteralExpression CreateDefaultValue(KnownTypeCode type)
	{
		LiteralExpression result = null;
		var loc = CurrentLocation;
        var type_name = type.ToString().ToLower();

		switch(type){
		case KnownTypeCode.Int:
        case KnownTypeCode.UInt:
        case KnownTypeCode.Byte:
			result = Expression.MakeConstant(type_name, 0, loc);
			break;
			
		case KnownTypeCode.Bool:
			result = Expression.MakeConstant(type_name, false, loc);
			break;
			
		case KnownTypeCode.Float:
			result = Expression.MakeConstant(type_name, 0.0, loc);
			break;
			
		case KnownTypeCode.String:
			result = Expression.MakeConstant(type_name, "", loc);
			break;

        case KnownTypeCode.Char:
            result = Expression.MakeConstant(type_name, '\0', loc);
			break;

		default:
			SemErr("Unknown object type");
			break;
		}
		
		return result;
	}

    AstType CreateType(string keyword, TextLocation loc, bool isReference)
    {
        AstType type = new PrimitiveType(keyword, loc);
        if(isReference)
            type = new ReferenceType(type, loc);

        return type;
    }

    LiteralExpression CreateLiteral(string value, TextLocation loc)
    {
        string type_name = "int";
        object obj = null;
        string suffix = value.Substring(value.Length - 1);
        string numerics = value.Replace("_", "");
        switch(suffix){
        case "u":
        case "U":
        {
            type_name = "uint";
            uint u;
            if(uint.TryParse(numerics.Substring(0, numerics.Length - 1), out u))
                obj = u;
            else
                SemErr("Invalid uint representation!");
            break;
        }

        case "l":
        case "L":
            type_name = "bigint";
            obj = BigInteger.Parse(numerics.Substring(0, numerics.Length - 1));
            break;

        case "f":
        case "F":
        {
            type_name = "float";
            float f;
            if(float.TryParse(numerics.Substring(0, numerics.Length - 1), out f))
                obj = f;
            else
                SemErr("Invalid float representation!");
            break; 
        }

        default:
        {
            double d;
            int i;
            if(int.TryParse(numerics, out i)){
                obj = i;
                type_name = "int";
            }else if(double.TryParse(numerics, out d)){
                obj = d;
                type_name = "double";
            }else{
                SemErr("Unknown sequence for numeric literals! Make sure that you write a number!");
            }
            break;
        }
        }

        return Expression.MakeConstant(type_name, obj, loc);
    }

    LiteralExpression HandleEscapes(string typeName, string literal, TextLocation loc)
    {
        string tmp = literal.Replace("\\n", "\n").Replace("\\r", "\r").Replace("\\t", "\t")
                            .Replace("\\v", "\v").Replace("\\f", "\f").Replace("\\0", "\0")
                            .Replace("\\b", "\b");
        tmp = UnicodeEscapeFinder.Replace(tmp, m => {
            return ((char)int.Parse(m.Value.Substring(2), NumberStyles.HexNumber)).ToString();
        });

        if(typeName == "char")
            return Expression.MakeConstant(typeName, Convert.ToChar(tmp), loc);
        else if(typeName == "string")
            return Expression.MakeConstant(typeName, tmp, loc);
        else
            throw new InvalidOperationException();
    }

    AstType ConvertPathToType(PathExpression path)
    {
        AstType type = null;
        foreach(var item in path.Items){
            item.Remove();
            if(type == null)
                type = AstType.MakeSimpleType(item, TextLocation.Empty);
            else
                type = AstType.MakeMemberType(type, AstType.MakeSimpleType(item, TextLocation.Empty), TextLocation.Empty);
        }

        return type;
    }

    SimpleType CreateTypeWithArgs(string typeName, params AstType[] typeArgs)
    {
        return new SimpleType(typeName, typeArgs, TextLocation.Empty, TextLocation.Empty);
    }

    bool IsPrimitiveGenericType(string name)
    {
        return name != null && (name == "dictionary" || name == "vector");
    }

    /// <summary>
    /// Creates a new <see ref="ICSharpCode.NRefactory.TextLocation">
    /// that points to the location n characters before the current.
    /// </summary>
    /// <remarks>
    /// It doesn't take line breaks into account.
    /// </remarks>
    TextLocation CreateLocationBefore(int n)
    {
        return new TextLocation(t.line, t.col - n);
    }

    void GoDownScope()
    {
        Symbols = Symbols.Children[Symbols.Children.Count - 1];
    }

    void GoUpScope()
    {
        Symbols = Symbols.Parent;
    }
	
	bool IsDefiningLValue()
	{
        return la.kind == _keyword_let || la.kind == _keyword_var;
	}
	
	bool IsSequenceInitializer()
	{
		Token x = la;
		if(x.kind != _comma)
            return true;
		
		while(x.kind != 0 && x.kind != _comma && x.kind != _keyword_for)
            x = scanner.Peek();
		
        scanner.ResetPeek();
        return x.kind != _keyword_for;
	}

    bool IsIdentifierPattern()
    {
        Token x = scanner.Peek();
        scanner.ResetPeek();
        return x.kind != _double_colon && x.kind != _lcurly;
    }

    bool NotFinalComma()
    {
        var t = la;
        var tt = scanner.Peek();
        scanner.ResetPeek();
        return t.kind == _comma && tt.kind != _rparen && tt.kind != _rbracket && tt.kind != _triple_dots;
    }
	
	public void SemanticError(string format, params object[] args)
	{
		//Convenient method for printing a semantic error with a format string
		SemErr(string.Format(format, args));
	}

    /// <summary>
    /// Reports a warning message.
    /// It is intended to be used from outside the Parser class.
    /// </summary>
    public void ReportWarning(string format, AstNode node, params object[] objects)
    {
        errors.Warning(string.Format("{0}: {1}", node.StartLocation, string.Format(format, objects)));
    }

    /// <summary>
    /// Reports a semantical error message.
    /// It is intended to be used from outside the Parser class.
    /// </summary>
    public void ReportSemanticError(string format, AstNode node, params object[] objects)
    {
        errors.SemErr(string.Format("{0}: {1}", node.StartLocation, string.Format(format, objects)));
    }

    /// <summary>
    /// Reports a semantical error message 
    /// </summary>
    public void ReportSemanticErrorRegional(string format, AstNode start, AstNode end, params object[] objects)
    {
        var real_message = string.Format("{0} ~ {1}: {2}", start.StartLocation, end.EndLocation, string.Format(format, objects));
        errors.SemErr(real_message);
    }
	
/*--------------------------------------------------------------------------*/
CHARACTERS
  letter = 'A'..'Z' + 'a'..'z'.
  digit = '0'..'9'.
  hex_letter = digit + 'a'..'f' + 'A'..'F'.
  cr  = '\r'.
  lf  = '\n'.
  tab = '\t'.
  backslash = '\\'.
  raw_prefix = 'r'.
  rawQuotedStringLetter = ANY - '"'.
  quotedStringLetter = ANY - '"' - '\\'.
  quotedLetter = ANY - '\'' - '\\'.
  dot = '.'.

TOKENS
  double_dots = "..".
  triple_dots = "...".
  rbracket = ']'.
  colon = ':'.
  double_colon = "::".
  semicolon = ';'.
  lcurly = '{'.
  lparen = '('.
  lbracket = '['.
  rparen = ')'.
  rcurly = '}'.
  comma = ','.
  dot = '.'.
  ident  = (letter | '_') {'_' | letter | digit}.
  integer = ( digit {digit | '_'} ['u' | 'U' | 'l' | 'L']
            | digit {digit | '_'} CONTEXT("..")   /*This context includes triple dots case*/
            ).
  float = ( digit {digit | '_'} dot [('e' | 'E') ['+' | '-'] digit {digit | '_'}]
  		  | [digit {digit | '_'}] dot digit {digit | '_'} [('e' | 'E') ['+' | '-'] digit {digit | '_'}]
          ) ['f' | 'F'].
  hex_digit = '0' ('x' | 'X') hex_letter {hex_letter}.
  unicode_escape = backslash ('u' | 'U') hex_letter hex_letter hex_letter hex_letter [hex_letter hex_letter].
  character_literal = '\''
                      [ quotedLetter
                      | backslash ( 'n' | 't' | 'r' | 'b' | 'f' | 'a' | backslash |
                        ('u' | 'U') hex_letter hex_letter hex_letter hex_letter [hex_letter hex_letter]
                        )
                      ]
                      '\''.
  string_literal = '"'
                   { quotedStringLetter
                   | backslash ( 'n' | 't' | 'r' | 'b' | 'f' | 'a' | backslash |
                     ('u' | 'U') hex_letter hex_letter hex_letter hex_letter [hex_letter hex_letter]
                     )
                   }
                   '"'.
  raw_string_literal = ( raw_prefix '"' {rawQuotedStringLetter} '"'
                       | raw_prefix '#' {'#'} '"' {rawQuotedStringLetter | '"'} '"' '#' {'#'}
                       ).
  keyword_for = "for".
  keyword_let = "let".
  keyword_var = "var".

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO lf

IGNORE cr + lf + tab



PRODUCTIONS
/*------------------------------------------------------------------------*/
Expresso                    		(. ExpressoAst module_decl = null; .)
= 
  ModuleBody<out module_decl>		(.
                                        Debug.Assert(Symbols.Parent == null);
                                        if(DoPostParseProcessing){
                                            ExpressoNameBinder.BindAst(module_decl, this); //Here's the start of post-parse processing
                                        }
  										this.TopmostAst = module_decl;	//Currently there is not so much code out there, though...
  									.).
/*------------------------------------------------------------------------*/
ModuleBody<out ExpressoAst ast>	    (.  var decls = new List<EntityDeclaration>();
                                        string module_name; Modifiers modifiers = ExpressoModifiers.None;
										List<ImportDeclaration> prog_defs = null; EntityDeclaration decl = null;
									.)
=
  ModuleNameDefinition<out module_name>
  [ ProgramDefinition<out prog_defs>
  ]
  								
  [ "export"						(. modifiers = ExpressoModifiers.Export; .)
  ]
  ( FuncDecl<out decl, modifiers>
  | ClassDecl<out decl, modifiers>
  )									(.  decls.Add(decl);
										modifiers = ExpressoModifiers.None;
									.)
  {
    [ "export"						(. modifiers = ExpressoModifiers.Export; .)
    ]
    ( FuncDecl<out decl, modifiers>
    | ClassDecl<out decl, modifiers>
    )								(.  decls.Add(decl);
    									modifiers = ExpressoModifiers.None;
    								.)
  }									(.  ast = AstNode.MakeModuleDef(module_name, decls, prog_defs); .) .
/*------------------------------------------------------------------------*/
ModuleNameDefinition<out string moduleName>
=                               (. .)
  "module"
  ident                         (. moduleName = t.val; .)
  { '.'
    ident
  }
  SYNC ';'.
/*------------------------------------------------------------------------*/
ProgramDefinition<. out List<ImportDeclaration> imports .>	(. imports = new List<ImportDeclaration>();
                                                               ImportDeclaration tmp;
                                                            .)
=
  ImportDecl<out tmp>			(. imports.Add(tmp); .)
  { ImportDecl<out tmp>		    (. imports.Add(tmp); .)
  }.
/*------------------------------------------------------------------------*/
ImportDecl<out ImportDeclaration decl>
            (.  decl = null; var has_in = false; PathExpression path;
				Identifier alias = null; var entities = new List<PathExpression>();
			.)
=
  /*****************************
   * Do not add symbol names in external modules right here
   * because we can't figure out all names in those modules' scopes.
   *****************************/
  SYNC
  "import"
  PathExpression<out path>      (. entities.Add(path); .)
  ( "as"
    ident						(. alias = AstNode.MakeIdentifier(t.val, CurrentLocation); .)
  | { WEAK ','
      PathExpression<out path>  (. entities.Add(path); .)
    }
    "in"                        (. has_in = true; .)
    PathExpression<out path>
  )
  SYNC ';'                      (. if(has_in)
                                       decl = AstNode.MakeImportDecl(path, entities);
                                   else
                                       decl = AstNode.MakeImportDecl(entities[0], alias);
                                .).
/*------------------------------------------------------------------------*/
ClassDecl<out EntityDeclaration decl, Modifiers modifiers>   
  (.  EntityDeclaration entity = null; var decls = new List<EntityDeclaration>(); AstType type_path;
      string name; var bases = new List<AstType>(); Modifiers cur_flag; var start_loc = NextLocation;
      Identifier ident = null;
  .)
=
  SYNC
  "class"                               (. Symbols.AddScope(); .)
  ident				    				(. name = t.val;
                                           ident = AstNode.MakeIdentifier(name, CurrentLocation);
                                           Symbols.AddTypeSymbol(name, ident);
                                        .)
  [ ':'
    Type<out type_path>	                (. bases.Add(type_path); .)
    { ','
      Type<out type_path>	            (. bases.Add(type_path); .)
    }
  ]
  '{'                                   (. GoDownScope();
                                           Symbols.Name = "class " + name + "`" + ScopeId++;
                                        .)
  {                                     (. cur_flag = ExpressoModifiers.Private; .)
    { Modifiers<ref cur_flag>
    }                                   (. //var tmp = cur_flag ^ ExpressoModifiers.Static;
                                           //tmp = tmp ^ ExpressoModifiers.VisibilityMask & ~ExpressoModifiers.Export;
                                           //if(tmp
                                        .)
    ( FuncDecl<out entity, cur_flag>    (. decls.Add(entity); .)
    | FieldDecl<out entity, cur_flag>	(. decls.Add(entity); .)
    | ClassDecl<out entity, cur_flag>   (. decls.Add(entity); .)
    )
  }
  SYNC '}'							    (. decl = EntityDeclaration.MakeClassDecl(ident, bases, decls, modifiers, start_loc, CurrentLocation);
                                           GoUpScope();
                                        .) .
/*------------------------------------------------------------------------*/
Modifiers<ref Modifiers modifiers>
=
  ( "public"                (. modifiers &= ~ExpressoModifiers.Private;
                               modifiers |= ExpressoModifiers.Public;
                            .)
  | "protected"             (. modifiers &= ~ExpressoModifiers.Private;
                               modifiers |= ExpressoModifiers.Protected;
                            .)
  | "private"               (. modifiers |= ExpressoModifiers.Private; .)
  | "static"                (. modifiers |= ExpressoModifiers.Static; .)
  ).
/*------------------------------------------------------------------------*/
FuncDecl<out EntityDeclaration decl, Modifiers modifiers>
                                (.  Identifier ident = null;
									string name; AstType type = null; BlockStatement block;
									var @params = new List<ParameterDeclaration>();
                                    var start_loc = NextLocation;
								.)
=
  SYNC
  "def"                         (. Symbols.AddScope(); .)
  ident							(. name = t.val;
                                   ident = AstNode.MakeIdentifier(name, new PlaceholderType(TextLocation.Empty), CurrentLocation); 
                                   Symbols.AddSymbol(name, ident);
                                .)
  '('                           (. GoDownScope();
                                   Symbols.Name = "func " + name + "`" + ScopeId++;
                                .)
  [ParamList<out @params>]
  ')'
  [ "->"
    Type<out type>
  ]                             (. if(type == null)
                                       type = new PlaceholderType(TextLocation.Empty);
                                .)
  Block<out block> 				(. decl = EntityDeclaration.MakeFunc(ident, @params, block, type, modifiers, start_loc);
                                   GoUpScope();
                                .).
/*------------------------------------------------------------------------*/
ParamList<. out List<ParameterDeclaration> @params .>
                                (. @params = new List<ParameterDeclaration>(); ParameterDeclaration param; bool seen_option = false; .)
=
  Parameter<out param>          (.
                                   if(param.Option != null)
                                       seen_option = true;

                                   @params.Add(param);
                                .)
  { WEAK ','
    Parameter<out param>        (.
                                   if(seen_option && param.Option == null)
                                       SemErr("You can't put optional parameters before non-optional parameters");
                                   else if(!seen_option && param.Option != null)
                                       seen_option = true;

                                   @params.Add(param);
                                .)
  }
  [ ident                       (. string name = t.val; AstType type = null; var loc = CurrentLocation; .)
    "..."
    [ "(-"
      Type<out type>
    ]                           (.
                                   if(type == null || !(type is SimpleType) || ((SimpleType)type).Name != "array")
                                       SemErr("The variadic parameter must be an array!");

                                   var identifier = AstNode.MakeIdentifier(name, type, loc);
                                   param = EntityDeclaration.MakeParameter(identifier, null);
                                   @params.Add(param);
                               .)
  ].
/*------------------------------------------------------------------------*/
Parameter<out ParameterDeclaration param>   (. Identifier identifier; Expression option = null; .)
=
  Identifier<out identifier>
  [ '='
    Literal<out option>
  ]                                         (. if(identifier.Type is PlaceholderType && option == null)
                                                   SemErr("You can't omit both the type annotation and the default value!");

                                               param = EntityDeclaration.MakeParameter(identifier, option);
                                            .).
/*------------------------------------------------------------------------*/
FieldDecl<out EntityDeclaration field, Modifiers modifiers>
  (. Expression rhs; Identifier ident; var start_loc = NextLocation;
     var idents = new List<Identifier>(); var exprs = new List<Expression>();
  .)
= 
  ( "let"                           (. modifiers |= ExpressoModifiers.Immutable; .)
  | "var"
  )
  VarDef<out ident, out rhs>        (.  
                                       idents.Add(ident);
                                       exprs.Add(rhs);
                                    .)  
  { ','
    VarDef<out ident, out rhs>      (.
                                       idents.Add(ident);
                                       exprs.Add(rhs);
                                    .)
  }
  SYNC ';'							(. field = EntityDeclaration.MakeField(idents, exprs, modifiers, start_loc, CurrentLocation); .).
/*------------------------------------------------------------------------*/
Type<out AstType type>
    (. var start_loc = NextLocation; type = new PlaceholderType(NextLocation);
       var is_reference = false; string name = null;
    .)
=
 [ '&'                              (. is_reference = true; .)
 ]
 ( "int"                			(. type = CreateType(t.val, start_loc, is_reference); .)
 | "uint"                           (. type = CreateType(t.val, start_loc, is_reference); .)
 | "bool"               			(. type = CreateType(t.val, start_loc, is_reference); .)
 | "float"							(. type = CreateType(t.val, start_loc, is_reference); .)
 | "double"                         (. type = CreateType(t.val, start_loc, is_reference); .)
 | "bigint"							(. type = CreateType(t.val, start_loc, is_reference); .)
 | "string"							(. type = CreateType(t.val, start_loc, is_reference); .)
 | "byte"						    (. type = CreateType(t.val, start_loc, is_reference); .)
 | "char"                           (. type = CreateType(t.val, start_loc, is_reference); .)
 | TupleTypeSignature<out type>
 | "vector"							(. name = t.val; .)
 | "dictionary"						(. name = t.val; .)
 | "function"						(. type = CreateType(t.val, start_loc, is_reference); .)
 | "intseq"							(. type = CreateType(t.val, start_loc, is_reference); .)
 | "void"							(. type = AstType.MakeSimpleType("tuple", Enumerable.Empty<AstType>(), start_loc, CurrentLocation); .)
 | TypePathExpression<out type>     (. if(is_reference) type = AstType.MakeReferenceType(type, TextLocation.Empty); .)
 )                                  (. start_loc = NextLocation; .)
 [ '<'                              (.
                                       if(!IsPrimitiveGenericType(name)){
                                           SemErr("`{0}` is not a generic type!");
                                           return;
                                       }
                                       var type_args = new List<AstType>(); AstType child_type;
                                    .)
   Type<out child_type>             (. type_args.Add(child_type); .)
   { ','
     Type<out child_type>           (. type_args.Add(child_type); .)
   }
   '>'                              (.
                                       type = AstType.MakeSimpleType(name, type_args, start_loc, CurrentLocation);
                                       if(is_reference)
                                           type = AstType.MakeReferenceType(type, CurrentLocation);
                                    .)
 ]
 /* Split brackets into 2 tokens that represents the array type
    because otherwise it conflicts with the array literal.
 */
 { '[' ']'                          (. if(type.IsNull)
                                           SemErr("Array of unknown type is specified. Unknown type is just unknown!");
                
                                       type = AstType.MakeSimpleType("array", new []{type}, start_loc, CurrentLocation);
                                    .)
 }.
/*------------------------------------------------------------------------*/
TupleTypeSignature<out AstType type> (. var inners = new List<AstType>(); var start_loc = NextLocation; .)
=
  '('
  { Type<out type>                  (. inners.Add(type); .)
  }
  ')'                               (. type = AstType.MakeSimpleType("tuple", inners, start_loc, CurrentLocation); .).
/*------------------------------------------------------------------------*/
Stmt<out Statement stmt>			(. stmt = null; .)
=
  SimpleStmt<out stmt>
  | CompoundStmt<out stmt> .
/*------------------------------------------------------------------------*/
SimpleStmt<out Statement stmt>		(. stmt = null; BlockStatement block = null; .)
=
  Block<out block>                  (. stmt = block; .)
  | ExprStmt<out stmt>
  | VarDeclStmt<out stmt>
  | ReturnStmt<out stmt>
  | BreakStmt<out stmt>
  | ContinueStmt<out stmt>
  | YieldStmt<out stmt>
  | EmptyStmt<out stmt>.
/*------------------------------------------------------------------------*/
ReturnStmt<out Statement stmt>		(. SequenceExpression items = null; .)
=
  "return"
  [RValueList<out items>]
  SYNC ';'							(. stmt = Statement.MakeReturnStmt(items); .).
/*------------------------------------------------------------------------*/
BreakStmt<out Statement stmt>		(. int count = 1; var start_loc = NextLocation; .)
=
  "break"
  [ "upto"
    integer							(. count = Convert.ToInt32(t.val); .)
  ]
  SYNC ';' 							(. stmt = Statement.MakeBreakStmt(
                                            Expression.MakeConstant("int", count, start_loc), start_loc, CurrentLocation
                                       );
                                    .).
/*------------------------------------------------------------------------*/
ContinueStmt<out Statement stmt>	(. int count = 1; var start_loc = NextLocation; .)
= 
  "continue"
  [ "upto"
    integer							(. count = Convert.ToInt32(t.val); .)
  ]
  SYNC ';' 							(. stmt = Statement.MakeContinueStmt(
                                            Expression.MakeConstant("int", count, start_loc), start_loc, CurrentLocation
                                       );
                                    .).
/*------------------------------------------------------------------------*/
YieldStmt<out Statement stmt>		(. Expression expr; var start_loc = NextLocation; .)
=
  "yield"
  CondExpr<out expr>
  SYNC ';'							(. stmt = Statement.MakeYieldStmt(expr, start_loc, CurrentLocation); .).
/*------------------------------------------------------------------------*/
EmptyStmt<out Statement stmt>       (. var start_loc = NextLocation; .)
=
  SYNC ';'							(. stmt = Statement.MakeEmptyStmt(start_loc); .).
/*------------------------------------------------------------------------*/
AugAssignOpe<ref OperatorType type>
=
  ( "+="							(. type = OperatorType.Plus; .)
  | "-="							(. type = OperatorType.Minus; .)
  | "*="							(. type = OperatorType.Times; .)
  | "/="							(. type = OperatorType.Divide; .)
  | "**="							(. type = OperatorType.Power; .)
  | "%="							(. type = OperatorType.Modulus; .)
  | "&="							(. type = OperatorType.BitwiseAnd; .)
  | "|="							(. type = OperatorType.BitwiseOr; .)
  | "<<="							(. type = OperatorType.BitwiseShiftLeft; .)
  | ">>="							(. type = OperatorType.BitwiseShiftRight; .)
  ).
/*------------------------------------------------------------------------*/
ExprStmt<out Statement stmt>			(.  SequenceExpression lhs = null, seq = null;
											var start_loc = NextLocation; stmt = null;
											OperatorType op_type = OperatorType.None;
                                            AssignmentExpression assign = null;
										.)
=
  LValueList<out lhs>
  ( AugAssignOpe<ref op_type>
    RValueList<out seq>                 (.  if(lhs.Count != seq.Count)  //See if both sides have the same number of items or not
                                                SemErr("An augumented assignment must have both sides balanced.");

                                            stmt = Statement.MakeAugumentedAssignment(lhs, seq, op_type, start_loc, CurrentLocation);
                                        .)
  | '='
    RValueList<out seq>                 (. assign = Expression.MakeAssignment(lhs, seq); .)
    { '='
      RValueList<out seq>               (. assign = Expression.MakeMultipleAssignment(assign, seq); .)
    }								    (. stmt = Statement.MakeExprStmt(assign, start_loc, CurrentLocation); .)
  )
  SYNC ';' 								(.  if(stmt == null)
  												stmt = Statement.MakeExprStmt(lhs, start_loc, CurrentLocation);
  										.).
/*------------------------------------------------------------------------*/
LValueList<out SequenceExpression lhs>   (. var lvalues = new List<Expression>(); Expression tmp; .)
=
  LhsPrimary<out tmp>                    (. lvalues.Add(tmp); .)
  { WEAK ','
    LhsPrimary<out tmp>                  (. lvalues.Add(tmp); .)
  }                                      (. lhs = Expression.MakeSequence(lvalues); .).
/*------------------------------------------------------------------------*/
Block<out BlockStatement block>
                (. List<Statement> stmts = new List<Statement>();
                   Statement stmt; var start_loc = NextLocation;
                   Symbols.AddScope();
                .)
=
  '{'                       (. GoDownScope();
                               Symbols.Name = "block`" + ScopeId++;
                            .)
  Stmt<out stmt>			(. stmts.Add(stmt); .)
  { Stmt<out stmt>			(. stmts.Add(stmt); .)
  }
  '}' 						(. block = Statement.MakeBlock(stmts, start_loc, CurrentLocation);
                               GoUpScope();
                            .).
/*------------------------------------------------------------------------*/
CompoundStmt<out Statement stmt>	(. stmt = null; .)
=
  SYNC
    IfStmt<out stmt>					
  | WhileStmt<out stmt>
  | ForStmt<out stmt>
  | MatchStmt<out stmt>
  /*| FuncDecl<out stmt>*/.
/*------------------------------------------------------------------------*/
IfStmt<out Statement stmt>			(. PatternConstruct pattern; BlockStatement true_block, false_block = null;
                                       var start_loc = NextLocation;
                                    .)
=
  "if"                              (. Symbols.AddScope();
                                       GoDownScope();
                                       Symbols.Name = "if`" + ScopeId++;
                                    .)
  LhsPattern<out pattern>
  Block<out true_block>
  [ "else"
    Block<out false_block>
  ]                      			(. stmt = Statement.MakeIfStmt(pattern, true_block, false_block, start_loc);
                                       GoUpScope();
                                    .).
/*------------------------------------------------------------------------*/
WhileStmt<out Statement stmt>		(. Expression cond; BlockStatement body; var start_loc = NextLocation; .)
=
  "while"                           (. Symbols.AddScope();
                                       GoDownScope();
                                       Symbols.Name = "while`" + ScopeId++;
                                    .)
  CondExpr<out cond>
  Block<out body>                   (. stmt = Statement.MakeWhileStmt(cond, body, start_loc);
                                       GoUpScope();
                                    .).
/*------------------------------------------------------------------------*/
ForStmt<out Statement stmt>			(.  PatternConstruct left; Expression rvalue; BlockStatement body;
                                        var start_loc = NextLocation;
									.)
=
  "for"                             (. Symbols.AddScope();
                                       GoDownScope();
                                       Symbols.Name = "for`" + ScopeId++;
                                    .)
  LhsPattern<out left>
  "in"
  CondExpr<out rvalue>
  Block<out body>					(. stmt = Statement.MakeForStmt(left, rvalue, body, start_loc);
                                       GoUpScope();
                                    .).
/*------------------------------------------------------------------------*/
MatchStmt<out Statement stmt>		(. Expression target; List<MatchPatternClause> matches;
                                       var start_loc = NextLocation;
                                    .)
=
  "match"
  CondExpr<out target>
  '{'                               (. Symbols.AddScope();
                                       GoDownScope();
                                       Symbols.Name = "match`" + ScopeId++;
                                    .)
  MatchPatternList<out matches>
  '}'								(. stmt = Statement.MakeMatchStmt(target, matches, start_loc, CurrentLocation);
                                       GoUpScope();
                                    .).
/*------------------------------------------------------------------------*/
MatchPatternList<. out List<MatchPatternClause> clauses .>
                                    (. clauses = new List<MatchPatternClause>(); List<PatternConstruct> pattern_list;
                                       Statement inner; Expression guard;
                                    .)
=
  PatternList<out pattern_list, out guard>
  Stmt<out inner>					(. clauses.Add(Statement.MakeMatchClause(pattern_list, guard, inner)); .)
  { PatternList<out pattern_list, out guard>
    Stmt<out inner>					(. clauses.Add(Statement.MakeMatchClause(pattern_list, guard, inner)); .)
  }.
/*------------------------------------------------------------------------*/
PatternList<. out List<PatternConstruct> patterns, out Expression guard .>
                        (. patterns = new List<PatternConstruct>(); PatternConstruct tmp; guard = null; .)
=
  Pattern<out tmp>                  (. patterns.Add(tmp); .)
  { SYNC '|'
    Pattern<out tmp>				(. patterns.Add(tmp); .)
  }
  [ "if"
    CondExpr<out guard>
  ]
  "=>".
/*------------------------------------------------------------------------*/
VarDeclStmt<out Statement stmt>         (.  Expression rhs = null;
								        	Identifier ident;
								          	var idents = new List<Identifier>(); var exprs = new List<Expression>();
                                            bool is_const = false; var start_loc = NextLocation;
								        .)
= 
  ( "let"                               (. is_const = true; .)
  | "var"
  )
  VarDef<out ident, out rhs>	        (.  idents.Add(ident);
  						 			        exprs.Add(rhs ?? Expression.Null);
  						 			        rhs = null;
  						 		        .)
  { WEAK ','
    VarDef<out ident, out rhs>         (. idents.Add(ident);
  									      exprs.Add(rhs ?? Expression.Null);
  									      rhs = null;
  								       .)
  }
  SYNC ';'							   (. var modifiers = is_const ? ExpressoModifiers.Immutable : ExpressoModifiers.None;
                                          stmt = Statement.MakeVarDecl(idents, exprs, modifiers, start_loc, CurrentLocation);
                                       .).
/*------------------------------------------------------------------------*/
VarDef<out Identifier ident, out Expression option> (. option = null; .)
=
  Identifier<out ident>
  [ '='
    CondExpr<out option>
  ]                            (. if(ident.Type is PlaceholderType && option == null)
                                      SemanticError("Give me some context or I can't infer the type of {0}", ident.Name);
                               .).
/*------------------------------------------------------------------------*/
RValueList<out SequenceExpression seq>		(. Expression tmp; var exprs = new List<Expression>(); .)
=
  CondExpr<out tmp>							(. exprs.Add(tmp); .)
  { WEAK ','
    CondExpr<out tmp>						(. exprs.Add(tmp);	.)
  }											(. seq = Expression.MakeSequence(exprs); .).
/*------------------------------------------------------------------------*/
Pattern<out PatternConstruct pattern>   (. pattern = null; bool is_binding = false; Modifiers modifier = ExpressoModifiers.None; .)
=
  [ "let"                               (. is_binding = true; modifier = ExpressoModifiers.Immutable; .)
  | "var"                               (. is_binding = true; .)
  ]
  LhsPattern<out pattern>
  | ExpressionPattern<out pattern>      (. if(is_binding)
                                               pattern = PatternConstruct.MakeValueBindingPattern(pattern, modifier);
                                        .).
/*------------------------------------------------------------------------*/
ExpressionPattern<out PatternConstruct pattern> (. Expression expr, upper = null, step = null;
                                                   bool upper_inclusive = false;
                                                .)
=
  Literal<out expr>                                
  [ RangeOperator<ref upper_inclusive>
    integer                                     (. upper = Expression.MakeConstant("int", t.val, CurrentLocation); .)
    [ ':'
      integer                                   (. step = Expression.MakeConstant("int", t.val, CurrentLocation); .)
    ]                                           (. expr = Expression.MakeIntSeq(expr, upper, step, upper_inclusive); .)
  ]                                             (. pattern = PatternConstruct.MakeExpressionPattern(expr); .).
/*------------------------------------------------------------------------*/
PatternItem<out PatternConstruct pattern>   (. pattern = PatternConstruct.Null; .)
=
  ExpressionPattern<out pattern>
  | IdentifierPattern<out pattern>.
/*------------------------------------------------------------------------*/
LhsPattern<out PatternConstruct pattern>    (. pattern = PatternConstruct.Null; .)
=
  WildcardPattern<out pattern>
  | IF(IsIdentifierPattern())
    IdentifierPattern<out pattern>
  | TuplePattern<out pattern>
  | DestructuringPattern<out pattern>.
/*------------------------------------------------------------------------*/
WildcardPattern<out PatternConstruct pattern>
=
  '_'                               (. pattern = PatternConstruct.MakeWildcardPattern(); .).
/*------------------------------------------------------------------------*/
IdentifierPattern<out PatternConstruct pattern> (. PatternConstruct inner = null; string name; AstType type = new PlaceholderType(TextLocation.Empty); .)
=
  ident                             (.
                                       name = t.val;
                                       var ident = AstNode.MakeIdentifier(name, type, CurrentLocation);
                                       Symbols.AddSymbol(name, ident);
                                    .)
  [ '@'
    LhsPattern<out inner>
  ]                                 (. pattern = PatternConstruct.MakeIdentifierPattern(ident, inner); .).
/*------------------------------------------------------------------------*/
TuplePattern<out PatternConstruct pattern>  (. var inners = new List<PatternConstruct>(); .)
=
  '('
  { ( LhsPattern<out pattern>
    | ExpressionPattern<out pattern>
    )                                       (. inners.Add(pattern); .)
    ','
  }
  ')'                                       (. pattern = PatternConstruct.MakeTuplePattern(inners); .).
/*------------------------------------------------------------------------*/
DestructuringPattern<out PatternConstruct pattern>  
                (. pattern = PatternConstruct.Null; AstType type_path;
                   var patterns = new List<PatternConstruct>(); bool is_vector = false;
                .)
=
  ( Type<out type_path>
    '{'
    [ PatternItem<out pattern>              (. patterns.Add(pattern); .)
    ]
    { ','
      PatternItem<out pattern>              (. patterns.Add(pattern); .)
    }
    '}'                                     (. pattern = PatternConstruct.MakeDestructuringPattern(type_path, patterns); .)
  | '['
    [ PatternItem<out pattern>              (. patterns.Add(pattern); .)
    ]
    { IF(NotFinalComma()) WEAK ','
      PatternItem<out pattern>              (. patterns.Add(pattern); .)
    }
    [ ','
      "..."                                 (. is_vector = true; .)
    ]
    ']'                                     (. pattern = PatternConstruct.MakeCollectionPattern(patterns, is_vector); .)
  ).
/*------------------------------------------------------------------------*/
CondExpr<out Expression expr>		(. Expression true_expr, false_expr; .)
=
  OrTest<out expr>
  [ '?'
    OrTest<out true_expr>
    ':'
    CondExpr<out false_expr>		(. expr = Expression.MakeCondExpr(expr, true_expr, false_expr); .)
  ].
/*------------------------------------------------------------------------*/
OrTest<out Expression expr>			(. Expression rhs; .)
=
  AndTest<out expr>
  [ "||"
    OrTest<out rhs>                 (. expr = Expression.MakeBinaryExpr(OperatorType.ConditionalOr, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
AndTest<out Expression expr>		(. Expression rhs; .)
=
  Comparison<out expr>
  [ "&&"
    AndTest<out rhs>				(. expr = Expression.MakeBinaryExpr(OperatorType.ConditionalAnd, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
Comparison<out Expression expr>	    (. Expression rhs; OperatorType type; .)
=
  IntSeqExpr<out expr>				(. type = OperatorType.Equality; .)
  [ ComparisonOperator<out type>
    Comparison<out rhs>			    (. expr = Expression.MakeBinaryExpr(type, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
ComparisonOperator<out OperatorType opType> (. opType = OperatorType.None; .)
=
  ( "=="                    (. opType = OperatorType.Equality; .)
  | "!="                    (. opType = OperatorType.InEquality; .)
  | '<'                     (. opType = OperatorType.LessThan; .)
  | '>'                     (. opType = OperatorType.GreaterThan; .)
  | "<="                    (. opType = OperatorType.LessThanOrEqual; .)
  | ">="                    (. opType = OperatorType.GreaterThanOrEqual; .)
  ).
/*------------------------------------------------------------------------*/
IntSeqExpr<out Expression expr>     (. Expression start = null, end = null, step = null;
                                       bool upper_inclusive = true;
                                    .)
=
  BitOr<out start>                  (. expr = start; .)
  [ RangeOperator<ref upper_inclusive>
    BitOr<out end>
    [ ':'
      BitOr<out step>
    ]                               (. if(step == null) step = Expression.MakeConstant("int", 1, TextLocation.Empty);
                                       expr = Expression.MakeIntSeq(start, end, step, upper_inclusive);
                                    .)
  ].
/*------------------------------------------------------------------------*/
RangeOperator<ref bool upper_inclusive>
=
  ( ".."                                (. upper_inclusive = false; .)
  | "..."                               (. upper_inclusive = true; .)
  ).
/*------------------------------------------------------------------------*/
BitOr<out Expression expr>			(. Expression rhs; .)
=
  BitXor<out expr>
  [ '|'
    BitOr<out rhs>					(. expr = Expression.MakeBinaryExpr(OperatorType.BitwiseOr, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
BitXor<out Expression expr>			(. Expression rhs; .)
=
  BitAnd<out expr>
  [ '^'
    BitXor<out rhs>					(. expr = Expression.MakeBinaryExpr(OperatorType.ExclusiveOr, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
BitAnd<out Expression expr>			(. Expression rhs; .)
=
  ShiftOp<out expr>
  [ '&'
    BitAnd<out rhs> 			    (. expr = Expression.MakeBinaryExpr(OperatorType.BitwiseAnd, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
ShiftOp<out Expression expr>		(. Expression rhs; OperatorType type; .)
=
  AddOp<out expr>
  [ ShiftOperator<out type>
    ShiftOp<out rhs>				 (. expr = Expression.MakeBinaryExpr(type, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
ShiftOperator<out OperatorType opType>  (. opType = OperatorType.None; .)
=
  ( "<<"                            (. opType = OperatorType.BitwiseShiftLeft; .)
  | ">>"                            (. opType = OperatorType.BitwiseShiftRight; .)
  ).
/*------------------------------------------------------------------------*/
AddOp<out Expression expr>    		(. Expression rhs; OperatorType type; .)
= 
  Term<out expr>
  [ AdditiveOperator<out type>
    AddOp<out rhs>					(. expr = Expression.MakeBinaryExpr(type, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
AdditiveOperator<out OperatorType opType>   (. opType = OperatorType.None; .)
=
  ( '+'                             (. opType = OperatorType.Plus; .)
  | '-'                             (. opType = OperatorType.Minus; .)
  ).
/*------------------------------------------------------------------------*/
Term<out Expression expr>       (. Expression rhs; OperatorType type; .)
= 
  PowerOp<out expr>
  [ MultiplicativeOperator<out type>
    Term<out rhs>		        (. expr = Expression.MakeBinaryExpr(type, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
MultiplicativeOperator<out OperatorType opType>
                            (. opType = OperatorType.None; .)
=
  ( '*'                     (. opType = OperatorType.Times; .)
  | '/'                     (. opType = OperatorType.Divide; .)
  | '%'                     (. opType = OperatorType.Modulus; .)
  ).
/*------------------------------------------------------------------------*/
PowerOp<out Expression expr>   (. Expression rhs; .)
= 
  Factor<out expr>
  [ "**"
    Factor<out rhs>            (. expr = Expression.MakeBinaryExpr(OperatorType.Power, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
Factor<out Expression expr> (. OperatorType type; Expression factor; expr = null; .)
=
  Primary<out expr>
  |
  UnaryOperator<out type>
  Factor<out factor>        (. expr = Expression.MakeUnaryExpr(type, factor); .).
/*------------------------------------------------------------------------*/
UnaryOperator<out OperatorType opType>  (. opType = OperatorType.None; .)
=
  ( AdditiveOperator<out opType>
  | '!'                             (. opType = OperatorType.Not; .)
  | '&'                             (. opType = OperatorType.Reference; .)
  | '*'                             (. opType = OperatorType.Dereference; .)
  ).
/*------------------------------------------------------------------------*/
Primary<out Expression expr>		    (. expr = null; PathExpression path; AstType type_path = null; .)
=
  ( PathExpression<out path>            (. expr = path; .) /* It's possible that a PathExpression turns out to be just an Identifier */
    [                                   (. type_path = ConvertPathToType(path); .)
      ObjectCreation<type_path, out expr>
    ]
  | Atom<out expr>
  | NewExpression<out expr>
  )
  { Trailer<ref expr>
  }.
/*------------------------------------------------------------------------*/
LhsPrimary<out Expression expr>     (. expr = null; PathExpression path; .)
=
  PathExpression<out path>          (. expr = path; .)
  { Trailer<ref expr>
  }.
/*------------------------------------------------------------------------*/
NewExpression<out Expression expr>      (. AstType type_path; .)
=
  "new"
  Type<out type_path>
  ObjectCreation<type_path, out expr>   (. expr = Expression.MakeNewExpr((ObjectCreationExpression)expr); .).
/*------------------------------------------------------------------------*/
ObjectCreation<AstType typePath, out Expression expr>
                                        (. var fields = new List<Identifier>(); var values = new List<Expression>(); .)
=
  '{'
  ident                                 (. fields.Add(AstNode.MakeIdentifier(t.val, CurrentLocation)); .)
  ':'
  CondExpr<out expr>                    (. values.Add(expr); .)
  { WEAK ','
    ident                               (. fields.Add(AstNode.MakeIdentifier(t.val, CurrentLocation)); .)
    ':'
    CondExpr<out expr>                  (. values.Add(expr); .)
  }
  '}'                                   (. expr = Expression.MakeObjectCreation(typePath, fields, values); .).
/*------------------------------------------------------------------------*/
Trailer<ref Expression expr>	(. var args = new List<Expression>(); .)
=
  '('
  [ArgList<out args>]
  ')'							(. expr = Expression.MakeCallExpr(expr, args); .)
  | '['
    ArgList<out args>
    ']'							(. expr = Expression.MakeIndexer(expr, args); .)
  | '.'
    ident						(. expr = Expression.MakeMemRef(expr, AstNode.MakeIdentifier(t.val, CurrentLocation)); .).
/*------------------------------------------------------------------------*/
ArgList<. out List<Expression> args .>		(. args = new List<Expression>(); Expression expr; .)
=
  CondExpr<out expr>						(. args.Add(expr); .)
  { WEAK ','
    CondExpr<out expr>						(. args.Add(expr); .)
  }.
/*------------------------------------------------------------------------*/
Atom<out Expression expr>			(. var exprs = new List<Expression>(); expr = null; bool seen_trailing_comma = false; .)
=
  Literal<out expr>
  | '('
    ( ')'                           (. expr = Expression.MakeParen(Expression.MakeSequence(null)); .)
    | CondExpr<out expr>            (. exprs.Add(expr); .)
      { IF(NotFinalComma()) WEAK ','
        CondExpr<out expr>          (. exprs.Add(expr); .)
      }
      [ ','                         (. seen_trailing_comma = true; .)
      ]
      ')'                           (. if(exprs.Count == 1)
                                           expr = Expression.MakeParen(seen_trailing_comma ? Expression.MakeSequence(exprs[0]) : exprs[0]);
                                       else
                                           expr = Expression.MakeParen(Expression.MakeSequence(exprs));
                                    .)
    )
  | '['
    [SequenceMaker<out expr>]
    SYNC ']'						(.  if(expr == null){
                                            var type = CreateTypeWithArgs("array", new PlaceholderType(TextLocation.Empty));
    										expr = Expression.MakeSeqInitializer(type, Enumerable.Empty<Expression>());
                                        }
    								.)
  | '{'
    [DictMaker<out expr>]
    SYNC '}'                        (. if(expr == null){
                                           var type = CreateTypeWithArgs("dictionary", new PlaceholderType(TextLocation.Empty), new PlaceholderType(TextLocation.Empty));
                                           expr = Expression.MakeSeqInitializer(type, Enumerable.Empty<Expression>());
                                       }
                                    .).
/*------------------------------------------------------------------------*/
TypePathExpression<out AstType type>
=
  ident        (. type = AstType.MakeSimpleType(t.val, CurrentLocation); .)
  { "::"
    ident      (.
                  type = AstType.MakeMemberType(type, AstType.MakeSimpleType(t.val, CurrentLocation), NextLocation);
               .)
  }.
/*------------------------------------------------------------------------*/
PathExpression<out PathExpression path> (. var paths = new List<Identifier>(); .)
=
  ident                                 (. paths.Add(AstNode.MakeIdentifier(t.val, CurrentLocation)); .)
  { "::"
    ident                               (. paths.Add(AstNode.MakeIdentifier(t.val, CurrentLocation)); .)
  }                                     (. 
                                           var last_ident = paths.Last();
                                           last_ident.Type = new PlaceholderType(TextLocation.Empty);
                                           path = Expression.MakePath(paths);
                                        .).
/*------------------------------------------------------------------------*/
SequenceMaker<out Expression expr>	(.  var exprs = new List<Expression>();
										expr = null; ComprehensionIter comp = null;
                                        string seq_type_name = "array";
									.)
=
  "..."                                 (. expr = Expression.MakeSeqInitializer(CreateTypeWithArgs("vector", new PlaceholderType(TextLocation.Empty)), Enumerable.Empty<Expression>()); .)
  | CondExpr<out expr>                  (. exprs.Add(expr); .)
  ( { IF(NotFinalComma()) WEAK ','
      CondExpr<out expr>                (. exprs.Add(expr); .)
    }
    [ ','
      "..."                             (. seq_type_name = "vector"; .)
    ]                                   (. var type = CreateTypeWithArgs(seq_type_name, new PlaceholderType(TextLocation.Empty));
                                           expr = Expression.MakeSeqInitializer(type, exprs);
                                        .)
  | CompFor<out comp>                   (. Symbols.AddScope();
                                           GoDownScope();

                                           var type = CreateTypeWithArgs("vector", new PlaceholderType(TextLocation.Empty));
                                           expr = Expression.MakeComp(expr, (ComprehensionForClause)comp, type);
                                           GoUpScope();
                                        .)
  ).
/*------------------------------------------------------------------------*/
DictMaker<out Expression expr>			(. Expression key, val; var list = new List<KeyValueLikeExpression>();
                                           KeyValueLikeExpression pair; ComprehensionIter comp; expr = null;
                                           var type = CreateTypeWithArgs("dictionary", new PlaceholderType(TextLocation.Empty), new PlaceholderType(TextLocation.Empty));
                                        .)
=
  BitOr<out key>
  ':'
  CondExpr<out val>                     (. pair = Expression.MakeKeyValuePair(key, val);
                                           list.Add(pair);
                                        .)
  ( { WEAK ','
      BitOr<out key>
      ':'
      CondExpr<out val>                 (. pair = Expression.MakeKeyValuePair(key, val);
                                           list.Add(pair);
                                        .)
    }                                   (. expr = Expression.MakeSeqInitializer(type, list); .)
  | CompFor<out comp>                   (. expr = Expression.MakeComp(pair, (ComprehensionForClause)comp, type); .)
  ).
/*------------------------------------------------------------------------*/
CompIter<out ComprehensionIter expr>    (. expr = null; .)
=
  CompFor<out expr>
  | CompIf<out expr> .
/*------------------------------------------------------------------------*/
CompFor<out ComprehensionIter expr>		(. Expression rvalue = null; ComprehensionIter body = null; PatternConstruct target; .)
=
  "for"
  LhsPattern<out target>
  "in"
  CondExpr<out rvalue>
  [CompIter<out body>]					(. expr = Expression.MakeCompFor(target, rvalue, body); .).
/*------------------------------------------------------------------------*/
CompIf<out ComprehensionIter expr>		(. Expression tmp; ComprehensionIter body = null; .)
=
  "if"
  OrTest<out tmp>
  [CompIter<out body>]					(. expr = Expression.MakeCompIf(tmp, body); .).
/*------------------------------------------------------------------------*/
Identifier<out Identifier ident>    (. string name; AstType type = new PlaceholderType(TextLocation.Empty); .)
=
  ident                             (. name = t.val; var loc = CurrentLocation; .)
  [ "(-"
    Type<out type>
  ]                                 (.
                                       ident = AstNode.MakeIdentifier(name, type, loc);
                                       Symbols.AddSymbol(name, ident);
                                    .).
/*------------------------------------------------------------------------*/
Literal<out Expression expr>	(. expr = null; string tmp;
                                   var start_loc = NextLocation;
                                .)
= 
  integer						(. expr = CreateLiteral(t.val, start_loc); .)
  | hex_digit					(. expr = Expression.MakeConstant("int", Convert.ToInt32(t.val, 16), start_loc); .)
  | float						(. expr = CreateLiteral(t.val, start_loc); .)
  | character_literal           (.
                                   tmp = t.val;
                                   tmp = tmp.Substring(1, tmp.Length - 2);
                                   expr = HandleEscapes("char", tmp, start_loc);
                                .)
  | string_literal				(.
                                   tmp = t.val;
  								   tmp = tmp.Substring(1, tmp.Length - 2);
  								   expr = HandleEscapes("string", tmp, start_loc);
  								.)
  | raw_string_literal          (.
                                   tmp = t.val.Substring(1);
                                   if(tmp.StartsWith("#")){
                                       int index_double_quote = tmp.IndexOf('"');
                                       int start_end_hashes = tmp.Length - index_double_quote - 1;
                                       int index_end_double_quote = tmp.LastIndexOf('"');
                                       if(start_end_hashes != index_end_double_quote + 1)
                                           SemErr("The number of opening and closing hash symbols in a raw string must match!");

                                       tmp = tmp.Substring(index_double_quote, tmp.Length - index_end_double_quote - index_double_quote);
                                   }
                                   tmp = tmp.Substring(1, tmp.Length - 2);
                                   expr = Expression.MakeConstant("string", tmp, start_loc);
                                .)
  | "true"                      (. expr = Expression.MakeConstant("bool", true, start_loc); .)		
  | "false"                     (. expr = Expression.MakeConstant("bool", false, start_loc); .)
  | "self"                      (. expr = Expression.MakeSelfRef(start_loc); .)
  | "super"                     (. expr = Expression.MakeSuperRef(start_loc); .).
/*------------------------------------------------------------------------*/
END Expresso.
