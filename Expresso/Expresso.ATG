using System.Collections.Generic;
using System.Linq;
using System.Numerics;
using System.Text;

using Expresso.Ast;
using Expresso.Compiler.Meta;
using Expresso.Parsing;
using Expresso.Runtime;
using Expresso.Utils;

using ICSharpCode.NRefactory;



COMPILER Expresso
	internal ScopeStatement cur_scope = null;		//the current scope of variables
	static List<BreakableStatement> breakables = new List<BreakableStatement>();	//the current parent breakables hierarchy
	public string ParsingFileName{get; set;}
	public ExpressoAst TopmostAst{get; private set;}	//the top-level AST the parser is parsing
    public TextLocation CurrentTokenLocation{
        get{
            return new TextLocation(t.line, t.col);
        }
    }

	///<summary>
	/// Parser Implementation details:
	/// 	During parsing we'll resolve break and continue statements.(Find which a break or continue statement would have its effect
	/// 	on which a loop statement) And in post-parse process, do flow analysis and type validity check, including local name bindings.
	///		Note that the identifiers are just placeholders until after doing name binding. 
	/// 	(Thus referencing them causes runtime exceptions)
	///</summary>
	Parser()
	{
		//Add built-in functions
		/*FunctionDefinition[] native_funcs = {
			new NativeLambdaUnary("abs", ImplementationHelpers.MakeArg(new Identifier("val", new TypeAnnotation(ObjectTypes.Var), null, 0)), ExpressoFunctions.Abs),
			new NativeLambdaUnary("sqrt", ImplementationHelpers.MakeArg(new Identifier("val", new TypeAnnotation(ObjectTypes.Var), null, 0)), ExpressoFunctions.Sqrt),
			new NativeLambdaUnary("toInt", ImplementationHelpers.MakeArg(new Identifier("val", new TypeAnnotation(ObjectTypes.Var), null, 0)), ExpressoFunctions.ToInt)
		};
		foreach(var tmp in native_funcs)
			cur_scope.AddFunction(tmp);*/
	}
	
	LiteralExpression CreateConstant(KnownTypeCode type)
	{
		LiteralExpression result = null;
		var loc = CurrentTokenLocation;
        var primitive_type = new PrimitiveType(type, loc);

		switch(type){
		case ObjectTypes.Integer:
			result = Expression.MakeConstant(primitive_type, 0);
			break;
			
		case ObjectTypes.Bool:
			result = Expression.MakeConstant(primitive_type, false);
			break;
			
		case ObjectTypes.Float:
			result = Expression.MakeConstant(primitive_type, 0.0);
			break;
			
		case ObjectTypes.String:
			result = Expression.MakeConstant(primitive_type, "");
			break;
			
		default:
			SemErr("Unknown object type");
			break;
		}
		
		return result;
	}
	
	/*bool NotFollowedByDoubleDots()
	{
		Token x = la;
		scanner.ResetPeek();
		if(x.kind != _lbracket)
            return true;
		
        while(x.kind != 0 && x.kind != _double_dots && x.kind != _rbracket && x.kind != _semicolon && x.kind != _rparen && x.kind != _keyword_in)
			x = scanner.Peek();
		
		return x.kind != _double_dots;
	}*/
	
	bool IsSequenceInitializer()
	{
		Token x = la;
        scanner.ResetPeek();
		if(x.kind != _comma)
            return true;
		
		while(x.kind != 0 && x.kind != _comma && x.kind != _keyword_for)
            x = scanner.Peek();
		
        return x.kind != _keyword_for;
	}
	
	static BreakStatement MakeBreakStatement(int count)
	{
		var tmp = new List<BreakableStatement>();
		for(int len = Parser.breakables.Count, i = 0, j = count; j > 0; ++i){
			var enclosing = Parser.breakables[len - 1 - i];
			tmp.Add(enclosing);
			if(enclosing.Type == NodeType.WhileStatement || enclosing.Type == NodeType.ForStatement) --j;
		}
		return AstNode.MakeBreakStmt(count, tmp);
	}
	
	static ContinueStatement MakeContinueStatement(int count)
	{
		var tmp = new List<BreakableStatement>();
		for(int len = Parser.breakables.Count, i = 0, j = count; j > 0; ++i){
			var enclosing = Parser.breakables[len - 1 - i];
			if(enclosing.Type != NodeType.WhileStatement && enclosing.Type != NodeType.ForStatement
				|| j != 1)			//don't include the loop on which we'll continue
				tmp.Add(enclosing);
			
			if(enclosing.Type == NodeType.WhileStatement || enclosing.Type == NodeType.ForStatement)
				--j;
		}
		return AstNode.MakeContinueStmt(count, tmp);
	}
	
	public void SemanticError(string format, params object[] args)
	{
		//Convenient method for printing a semantic error with a format string
		SemErr(string.Format(format, args));
	}
	
/*--------------------------------------------------------------------------*/
CHARACTERS
  letter = 'A'..'Z' + 'a'..'z'.
  digit = '0'..'9'.
  hex_letter = digit + 'a'..'f' + 'A'..'F'.
  cr  = '\r'.
  lf  = '\n'.
  tab = '\t'.
  quotedLetter = ANY - '"' - '\''.
  dot = '.'.

TOKENS
  double_dots = "..".
  triple_dots = "...".
  rbracket = ']'.
  colon = ':'.
  semicolon = ';'.
  lcurly = '{'.
  lparen = '('.
  lbracket = '['.
  rparen = ')'.
  rcurly = '}'.
  comma = ','.
  dot = '.'.
  ident  = (letter | '_') {'_' | letter | digit}.
  integer = digit {digit}
  			| digit {digit} CONTEXT("..")
            | digit {digit} CONTEXT("...").
  float = digit {digit} dot {digit} [('e' | 'E') ['+' | '-'] digit {digit}]
  		  | [digit {digit}] dot digit {digit} [('e' | 'E') ['+' | '-'] digit {digit}].
  hex_digit = '0' ('x' | 'X') hex_letter {hex_letter}.
  string_literal = '"' {quotedLetter} '"'.
  keyword_in = "in".
  keyword_for = "for".

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO lf

IGNORE cr + lf + tab



PRODUCTIONS
/*------------------------------------------------------------------------*/
Expresso                    		(. ExpressoAst module_decl = null; .)
= 
  ModuleBody<out module_decl>		(.  try{
                                            ExpressoNameBinder.BindAst(module_decl, this); //Here's the start of post-parse processing
                                        }
                                        catch(ParserException pe){
                                            SemanticError(pe.Message, pe.Objects);
                                        }
  										this.TopmostAst = module_decl;	//Currently there is not so much code out there, though...
  									.).
/*------------------------------------------------------------------------*/
ModuleBody<out ExpressoAst decl>	(.  var decls = new List<Statement>();
                                        string module_name; Modifiers modifiers = Modifiers.None;
										List<ImportDeclaration> prog_defs = null; Statement stmt = null;
									.)
=
  ModuleNameDefinition<out module_name>
  [ ProgramDefinition<out prog_defs>
  ]
  								
  [ "export"						(. modifiers = Modifiers.Export; .)
  ]
  ( ExprStmt<out stmt>
  | FuncDecl<out stmt, modifiers>
  | ClassDecl<out stmt, modifiers>
  )									(.  decls.Add(stmt);
										modifiers = Modifiers.None;
									.)
  {
    [ "export"						(. modifiers = Modifiers.Export; .)
    ]
    ( ExprStmt<out stmt>
    | FuncDecl<out stmt, modifiers>
    | ClassDecl<out stmt, modifiers>
    )								(.  decls.Add(stmt);
    									modifiers = Modifiers.None;
    								.)
  }									(.  decl = AstNode.MakeModuleDef(module_name, decls, prog_defs);
  									.) .
/*------------------------------------------------------------------------*/
ModuleNameDefinition<out string moduleName>
=
  "module"
  ident                         (. moduleName = t.val; .)
  SYNC ';'.
/*------------------------------------------------------------------------*/
ProgramDefinition<. out List<ImportDeclaration> imports .>	(. imports = new List<ImportDeclatation>();
                                                               ImportDeclaration tmp;
                                                            .)
=
  ImportDecl<out tmp>			(. imports.Add(tmp); .)
  { ImportDecl<out tmp>		    (. imports.Add(tmp); .)
  }.
/*------------------------------------------------------------------------*/
ImportDecl<out ImportDeclaration decl>
            (.  string module_name, alias = null; var module_names = new List<string>();
				var aliases = new List<string>();
			.)
=
  SYNC
  "import"
  ModuleName<out module_name>
  [ "as"
    ident						(. alias = t.val; .)
  ]								(.  module_names.Add(module_name);
  									aliases.Add(alias);
  								.)
  { ','
    ModuleName<out module_name>
    [ "as"
      ident						(. alias = t.val; .)
    ]							(.  module_names.Add(module_name);
  									aliases.Add(alias);
  								.)
  }
  SYNC ';' 						(. stmt = AstNode.MakeImportDecl(module_names, aliases); .).
/*------------------------------------------------------------------------*/
ModuleName<out string name>		(. var sb = new StringBuilder(); .)
=
  ident							(. sb.Append(t.val); .)
  { '.'							(. sb.Append('.'); .)
    ident						(. sb.Append(t.val); .)
  }								(. name = sb.ToString(); .).
/*------------------------------------------------------------------------*/
ClassDecl<out EntityDeclaration decl, Modifiers modifiers>   
  (.  EntityDeclaration entity = null; var decls = new List<EntityDeclaration>();
      string name; var base_names = new List<Identifier>(); Modifiers cur_flag;
  .)
=
  SYNC
  "class"
  ident				    				(. name = t.val; .)
  [ ':'
    ident		    					(. base_names.Add(AstNode.MakeIdentifier(t.val)); .)
    { ','
      ident							    (. base_names.Add(AstNode.MakeIdentifier(t.val)); .)
    }
  ]
  '{'
  {
    Modifiers<out cur_flag>
    ( MethodDecl<out entity, name, cur_flag>(. decls.Add(entity); .)
    | FieldDecl<out entity, cur_flag>
      ';'								    (. decls.Add(entity); .)
    | ClassDecl<out entity>			    (. decls.Add(entity); .)
    )
  }
  SYNC '}'							    (. decl = AstNode.MakeClassDecl(name, base_names, decls, modifiers); .) .
/*------------------------------------------------------------------------*/
Modifiers<out Modifiers modifiers>  (. modifiers = Modifiers.None; .)
=
  { "public"                (. modifiers |= Modifiers.Public; .)
  | "protected"             (. modifiers |= Modifiers.Protected; .)
  | "private"               (. modifiers |= Modifiers.Private; .)
  | "static"                (. modifiers |= Modifiers.Static; .)
  }                         (. if(modifiers == Modifiers.None) modifiers.Private; .).
/*------------------------------------------------------------------------*/
MethodDecl<out EntityDeclaration decl, string className, Modifiers modifiers>
                                (.
									string name; var type = TypeAnnotation.InferenceType.Clone(); BlockStatement block;
									var @params = new List<Argument>();
								.)
=
  SYNC
  "def"
  ident							(. name = t.val; .)
  '('
  [ParamList<ref @params>]
  ')'
  [ "->"
    Type<out type>
  ]
  Block<out block> 				(.  decl = AstNode.MakeFunc(name, @params, block, type, modifiers); .).
/*------------------------------------------------------------------------*/
FieldDecl<. out List<EntityDeclaration> outs, Modifiers modifiers .>
  (. string name; var type = TypeAnnotation.InferenceType.Clone(); Expression rhs = null;
	 Identifier variable; outs = new List<Expression>();
	 var vars = new List<Identifier>(); var exprs = new List<Expression>();
  .)
= 
  ( "let"
  | "var"
  )
  VarDef<out name, out type, out rhs> (.  variable = AstNode.MakeField(name, type);
                                          vars.Add(variable);
                                          exprs.Add(rhs);
                                          rhs = null;
                                      .)  
  { ','					 		
    VarDef<out name, out type, out rhs> (. variable = AstNode.MakeField(name, type);
                                           vars.Add(variable);
                                           exprs.Add(rhs);
                                        .)
  }								       (. outs.Add(AstNode.MakeVarDecl(vars, exprs, flag)); .).
/*------------------------------------------------------------------------*/
Type<out TypeAnnotation type>		(. type = TypeAnnotation.InferenceType.Clone(); int dimension = 0; .)
=
 ( "int"                			(. type.ObjType = ObjectTypes.Integer; .)
 | "bool"               			(. type.ObjType = ObjectTypes.Bool; .)
 | "float"							(. type.ObjType = ObjectTypes.Float; .)
 | "double"                         (. type.ObjType = ObjectTypes.Double; .)
 | "rational"						(. type.ObjType = ObjectTypes.Rational; .)
 | "bigint"							(. type.ObjType = ObjectTypes.BigInt; .)
 | "string"							(. type.ObjType = ObjectTypes.String; .)
 | "byte"						    (. type.ObjType = ObjectTypes.Byte; .)
 | TupleTypeSignature<out type>
 | "vector"							(. type.ObjType = ObjectTypes.Vector; .)
 | "dictionary"						(. type.ObjType = ObjectTypes.Dict; .)
 | "expression"						(. type.ObjType = ObjectTypes.Expression; .)
 | "function"						(. type.ObjType = ObjectTypes.Function; .)
 | "intseq"							(. type.ObjType = ObjectTypes.Seq; .)
 | "void"							(. type.ObjType = ObjectTypes.Undef; .)
 | ident							(. type.ObjType = ObjectTypes.Instance; type.TypeName = t.val; .)
 )
 { "[]"                             (. if(!type.IsArray)
                                           type.IsArray = true;
                                       
                                       ++dimension;
                                    .)
 }                                  (. type.Dimension = dimension; .).
/*------------------------------------------------------------------------*/
TupleTypeSignature<out TypeAnnotation type> (. TypeAnnotation inner; .)
=
  '('
  { Type<out inner>
  }
  ')'.
/*------------------------------------------------------------------------*/
Stmt<out Statement stmt>			(. stmt = null; .)
=
  SimpleStmt<out stmt>
  | CompoundStmt<out stmt> .
/*------------------------------------------------------------------------*/
SimpleStmt<out Statement stmt>		(. stmt = null; .)
=	IF(la.kind == _lcurly)	/* For DictMaker and Block conflict. Since DictMaker should not be a statement, we always choose the first(Block).*/
    Block<out stmt>
  | ExprStmt<out stmt>
  | ReturnStmt<out stmt>
  | BreakStmt<out stmt>
  | ContinueStmt<out stmt>
  | ThrowStmt<out stmt>
  | YieldStmt<out stmt>
  | EmptyStmt<out stmt>.
/*------------------------------------------------------------------------*/
ReturnStmt<out Statement stmt>		(. SequenceExpression items = null; .)
=
  "return"
  [RValueList<out items>]
  SYNC ';'							(. stmt = AstNode.MakeReturnStmt(items); .).
/*------------------------------------------------------------------------*/
BreakStmt<out Statement stmt>		(. int count = 1; .)
=
  "break"
  [ "upto"
    integer							(. count = Convert.ToInt32(t.val); .)
  ]
  SYNC ';' 							(. stmt = MakeBreakStatement(count); .).
/*------------------------------------------------------------------------*/
ContinueStmt<out Statement stmt>	(. int count = 1; .)
= 
  "continue"
  [ "upto"
    integer							(. count = Convert.ToInt32(t.val); .)
  ]
  SYNC ';' 							(. stmt = MakeContinueStatement(count); .).
/*------------------------------------------------------------------------*/
ThrowStmt<out Statement stmt>		(. Expression expr; .)
=
  "throw"
  CondExpr<out expr>
  SYNC ';'							(. stmt = AstNode.MakeThrowStmt(expr); .).
/*------------------------------------------------------------------------*/
YieldStmt<out Statement stmt>		(. Expression expr; .)
=
  "yield"
  CondExpr<out expr>
  SYNC ';'							(. stmt = AstNode.MakeYieldStmt(expr); .).
/*------------------------------------------------------------------------*/
EmptyStmt<out Statement stmt>
=
  SYNC ';'							(. stmt = AstNode.MakeEmptyStmt(); .).
/*------------------------------------------------------------------------*/
AugAssignOpe<ref OperatorType type>
=
  ( "+="							(. type = OperatorType.Plus; .)
  | "-="							(. type = OperatorType.Minus; .)
  | "*="							(. type = OperatorType.Times; .)
  | "/="							(. type = OperatorType.Divide; .)
  | "**="							(. type = OperatorType.Power; .)
  | "%="							(. type = OperatorType.Modulus; .)
  | "&="							(. type = OperatorType.BitwiseAnd; .)
  | "|="							(. type = OperatorType.BitwiseOr; .)
  | "<<="							(. type = OperatorType.BitwiseShiftLeft; .)
  | ">>="							(. type = OperatorType.BitwiseShiftRight; .)
  ).
/*------------------------------------------------------------------------*/
ExprStmt<out Statement stmt>			(.  List<Expression> lvalues = null; SequenceExpression targets = null;
											SequenceExpression seq = null;
											stmt = null; OperatorType op_type = OperatorType.None;
										.)
=
  ( VarDecl<out lvalues>
  | LValueList<out targets>
  { ( AugAssignOpe<ref op_type>
    | '='
    )
    RValueList<out seq>
  }										(.
  											if(targets.Count != seq.Count)      //See if both sides have the same number of items
                                                SemErr("An augumented assignment must have both sides balanced.");
  													
  											if(op_type != OperatorType.None)
  												stmt = Expression.MakeAugumentedAssignment(targets, seq, op_type);
  											else
  												stmt = Expression.MakeAssignment(targets, seq);
  										.)
  )
  SYNC ';' 								(.  if(stmt == null)
  												stmt = Statement.MakeExprStmt(lvalues);
  										.).
/*------------------------------------------------------------------------*/
Block<out BlockStatement block>		(. List<Statement> stmts = new List<Statement>(); Statement stmt; .)
=
  '{'
  Stmt<out stmt>			(. stmts.Add(stmt); .)
  { Stmt<out stmt>			(. stmts.Add(stmt); .)
  }
  '}' 						(. block = Statement.MakeBlock(stmts); .).
/*------------------------------------------------------------------------*/
CompoundStmt<out Statement stmt>	(. stmt = null; .)
=
  SYNC
    IfStmt<out stmt>					
  | WhileStmt<out stmt>
  | ForStmt<out stmt>
  | MatchStmt<out stmt>
  | FuncDecl<out stmt>
  | TryStmt<out stmt>.
/*------------------------------------------------------------------------*/
IfStmt<out Statement stmt>			(. Expression tmp; BlockStatement true_block, false_block = null; .)
=
  "if" 
  CondExpr<out tmp>
  Block<out true_block>
  [ "else"
    Block<out false_block>
  ]                      			(. stmt = Statement.MakeIfStmt(tmp, true_block, false_block); .).
/*------------------------------------------------------------------------*/
WhileStmt<out Statement stmt>		(. Expression cond; BlockStatement body; .)
=
  "while"
  CondExpr<out cond>
  Block<out body>                   (. stmt = Statement.MakeWhileStmt(cond, body); .).
/*------------------------------------------------------------------------*/
ForStmt<out Statement stmt>				(.  PatternConstruct left; Expression rvalue; BlockStatement body;
										.)
=
  "for"
  LhsPattern<out left>
  "in"
  CondExpr<out rvalue>
  Block<out body>						(. stmt = Statement.MakeForStmt(left, rvalue, body); .).
/*------------------------------------------------------------------------*/
MatchStmt<out Statement stmt>		(. PatternConstruct target; List<MatchClause> matches; .)
=
  "match"
  LhsPattern<out target>
  '{'
  MatchPatternList<out matches>
  '}'								(. stmt = Statement.MakeMatchStmt(target, matches); .).
/*------------------------------------------------------------------------*/
MatchPatternList<. out List<MatchClause> clauses .>	(. clauses = new List<MatchClause>(); List<PatternConstruct> pattern_list; Statement inner; .)
=
  PatternList<out pattern_list>
  Stmt<out inner>									(. clauses.Add(AstNode.MakeMatchClause(pattern_list, inner)); .)
  { PatternList<out pattern_list>
    Stmt<out inner>									(. clauses.Add(AstNode.MakeMatchClause(pattern_list, inner)); .)
  }.
/*------------------------------------------------------------------------*/
PatternList<. out List<PatternConstruct> patterns .>    (. patterns = new List<PatternConstruct>(); PatternConstruct tmp; .)
=
  Pattern<out tmp>								        (. patterns.Add(tmp); .)
  { SYNC '|'
    Pattern<out tmp>								    (. patterns.Add(tmp); .)
  }
  "=>" .
/*------------------------------------------------------------------------*/
LValueList<out SequenceExpression target>	(. Expression tmp; var exprs = new List<Expression>(); .)
=
  Primary<out tmp>							(. exprs.Add(tmp); .)
  { SYNC ','
    Primary<out tmp>						(. exprs.Add(tmp); .)
  }											(. target = Expression.MakeSequence(exprs); .).
/*------------------------------------------------------------------------*/
VarDecl<. out List<Expression> outs .> 	(.  string name; var type = TypeAnnotation.InferenceType.Clone(); Expression rhs = null;
											Identifier variable; outs = new List<Expression>();
								   			var vars = new List<Identifier>(); var exprs = new List<Expression>();
                                            bool is_const = false;
										.)
= 
  ( "let"                               (. is_const = true; .)
  | "var"
  )
  VarDef<out name, out type, out rhs>	(.  variable = AstNode.MakeLocalVar(name, type);
                                            vars.Add(variable);
  						 			        exprs.Add(rhs);
  						 			        rhs = null;
  						 		        .)
  { WEAK ','
    VarDef<out name, out type, out rhs>(. variable = AstNode.MakeLocalVar(name, type);
                                          vars.Add(variable);
  									      exprs.Add(rhs);
  									      rhs = null;
  								       .)
  }								       (. outs.Add(Statement.MakeVarDecl(vars, exprs)); .).
/*------------------------------------------------------------------------*/
VarDef<out string name, out Type type, out Expression @default>  (. type = TypeAnnotation.InferenceType.Clone();
                                                                    @default = null;
                                                                 .)
=
  ident                        (. name = t.val; .)
  [ "(-"
    Type<out type>
  ]
  [ '='
    CondExpr<out @default>
  ].
/*------------------------------------------------------------------------*/
FuncDecl<out Statement func>    (.  string name; var type = TypeAnnotation.VariantType.Clone(); BlockStatement block = null;
									var @params = new List<ParameterDeclaration>();
								.)
=
  SYNC
  "def"
  ident							(. name = t.val; .)
  '('
  [ParamList<out @params>]
  ')'
  [ "->"
    Type<out type>
  ]
  Block<out block> 				(. func = AstNode.MakeFunc(name, @params, block, type); .).
/*------------------------------------------------------------------------*/
TryStmt<out Statement stmt>			(.  BlockStatement body, catch_body = null, finally_body = null; List<CatchClause> catches = null;
										TypeAnnotation excp_type = null; Identifier catch_ident = null; string name = null;
									.)
=
  "try"
  Block<out body>
  { "catch"							(. if(catches == null) catches = new List<CatchClause>(); .)
    ident							(. name = t.val; .)
    "(-"
    Type<out excp_type>             (. catch_ident = AstNode.MakeLocalVar(name, excp_type); .)
    Block<out catch_body>			(. catches.Add(AstNode.MakeCatchClause(catch_body, catch_ident)); .)
  }									
  [ "finally"
    Block<out finally_body>
  ]									(. stmt = Statement.MakeTryStmt(body, catches, finally_body); .).
/*------------------------------------------------------------------------*/
ParamList<. out List<ParameterDeclaration> @params .>	(. @params = new List<ParameterDeclaration>(); ParameterDeclaration expr; .)
=
  Parameter<out expr>							        (. @params.Add(expr); .)
  { WEAK ','
    Parameter<out expr>							        (. @params.Add(expr); .)
  }.
/*------------------------------------------------------------------------*/
Parameter<out ParameterDeclaration arg>	(. string name; Expression default_val = null; var type = TypeAnnotation.VariantType.Clone(); .)
=
  ident							        (. name = t.val; .)
  "(-"
  Type<out type>
  [ '='
    Literal<out default_val>
  ]								        (. arg = AstNode.MakeArg(name, type, default_val); .).
/*------------------------------------------------------------------------*/
RValueList<out SequenceExpression seq>		(. Expression tmp; var exprs = new List<Expression>(); .)
=
  CondExpr<out tmp>							(. exprs.Add(tmp); .)
  { WEAK ','
    CondExpr<out tmp>						(. exprs.Add(tmp);	.)
  }											(. seq = Expression.MakeSequence(exprs); .).
/*------------------------------------------------------------------------*/
Pattern<out PatternConstruct pattern>
=
  LhsPattern<out pattern>
  | ExpressionPattern<out pattern>.
/*------------------------------------------------------------------------*/
ExpressionPattern<out PatternConstruct expr_pattern>    (. Expression expr; .)
=
  CondExpr<out expr>                                    (. expr_pattern = PatternConstruct.MakeExpressionPattern(expr); .).
/*------------------------------------------------------------------------*/
LhsPattern<out PatternConstruct pattern>
=
  WildcardPattern<out pattern>
  | IdentifierPattern<out pattern>
  | ValueBindingPattern<out pattern>.
/*------------------------------------------------------------------------*/
WildcardPattern<out PatternConstruct pattern>
=
  '_'                                   (. pattern = PatternConstruct.MakeWildcardPattern(); .).
/*------------------------------------------------------------------------*/
IdentifierPattern<out PatternConstruct pattern> (. var type = TypeAnnotation.InferenceType.Clone(); .)
=
  ident
  [ "(-"
    Type<ref type>
  ]                                (. pattern = PatternConstruct.MakeIdentifierPattern(t.val, type); .).
/*------------------------------------------------------------------------*/
ValueBindingPattern<out PatternConstruct pattern>   (. PatternConstruct inner; .)
=
  ( "let"
  | "var"
  )
  Pattern<out inner>                    (. pattern = PatternConstruct.MakeValueBindingPattern(inner); .).
/*------------------------------------------------------------------------*/
CondExpr<out Expression expr>		(. Expression true_expr, false_expr; .)
=
  OrTest<out expr>
  [ '?'
    OrTest<out true_expr>
    ':'
    CondExpr<out false_expr>		(. expr = Expression.MakeCondExpr(expr, true_expr, false_expr); .)
  ].
/*------------------------------------------------------------------------*/
OrTest<out Expression expr>			(. Expression rhs; .)
=
  AndTest<out expr>
  [ "||"
    OrTest<out rhs>                 (. expr = Expression.MakeBinaryExpr(OperatorType.ConditionalOr, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
AndTest<out Expression expr>		(. Expression rhs; .)
=
  NotTest<out expr>
  [ "&&"
    AndTest<out rhs>				(. expr = Expression.MakeBinaryExpr(OperatorType.ConditionalAnd, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
NotTest<out Expression expr>		(. Expression term; expr = null; .)
=
  ( '!'
    NotTest<out term>				(. expr = Expression.MakeUnaryExpr(OperatorType.Not, term); .)
  )
  | Comparison<out expr>.
/*------------------------------------------------------------------------*/
Comparison<out Expression expr>	(. Expression rhs; OperatorType type; .)
=
  BitOr<out expr>				(. type = OperatorType.Equality; .)
  [
    ( "=="               		(. type = OperatorType.Equality; .)
    | "!="						(. type = OperatorType.InEquality; .)
    | '<'                		(. type = OperatorType.LessThan; .)
    | '>'                		(. type = OperatorType.GreaterThan; .)
    | "<="				 		(. type = OperatorType.LessThanOrEqual; .)
    | ">="				 		(. type = OperatorType.GreaterThanOrEqual; .)
    )
    Comparison<out rhs>			(. expr = Expression.MakeBinaryExpr(type, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
BitOr<out Expression expr>			(. Expression rhs; .)
=
  BitXor<out expr>
  [ '|'
    BitOr<out rhs>					(. expr = Expression.MakeBinaryExpr(OperatorType.BitwiseOr, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
BitXor<out Expression expr>			(. Expression rhs; .)
=
  BitAnd<out expr>
  [ '^'
    BitXor<out rhs>					(. expr = Expression.MakeBinaryExpr(OperatorType.ExclusiveOr, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
BitAnd<out Expression expr>			(. Expression rhs; .)
=
  ShiftOp<out expr>
  [ '&'
    BitAnd<out rhs>			    	(. expr = Expression.MakeBinaryExpr(OperatorType.BitwiseAnd, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
ShiftOp<out Expression expr>		(. Expression rhs; OperatorType type; .)
=
  AddOp<out expr>
  [
  	( "<<" 							(. type = OperatorType.BitwiseShiftLeft; .)
    | ">>"							(. type = OperatorType.BitwiseShiftRight; .)
    )
    ShiftOp<out rhs>				(. expr = Expression.MakeBinaryExpr(type, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
AddOp<out Expression expr>    		(. Expression rhs; OperatorType type; .)
= 
  Term<out expr>
  [ 
    ( '+'							(. type = OperatorType.Plus; .)
    | '-'							(. type = OperatorType.Minus; .)
    )
    AddOp<out rhs>					(. expr = Expression.MakeBinaryExpr(type, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
Term<out Expression expr>   (. Expression rhs; OperatorType type; .)
= 
  Factor<out expr>
  [
    ( '*'					(. type = OperatorType.Times; .)
    | '/'					(. type = OperatorType.Divide; .)
    | '%'					(. type = OperatorType.Modulus; .)
    )
    Term<out rhs>			(. expr = Expression.MakeBinaryExpr(type, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
Factor<out Expression expr> (. OperatorType type; Expression factor; expr = null; .)
=
  PowerOp<out expr>
  |
  ( ( '+'                   (. type = OperatorType.Plus; .)
    | '-'                   (. type = OperatorType.Minus; .)
    )
    Factor<out factor>
  )                         (. expr = Expression.MakeUnaryExpr(type, factor); .).
/*------------------------------------------------------------------------*/
PowerOp<out Expression expr>   (. Expression rhs; .)
= 
  Primary<out expr>
  [ "**"
    Factor<out rhs>            (. expr = Expression.MakeBinaryExpr(OperatorType.Power, expr, rhs); .)
  ].
/*------------------------------------------------------------------------*/
Primary<out Expression expr>		(. expr = null; .)
=
  ( Atom<out expr>
  | NewExpression<out expr>
  | ObjectCreation<out expr>
  ) 
  { Trailer<ref expr>
  }.
/*------------------------------------------------------------------------*/
NewExpression<out Expression expr>
=
  "new"
  ObjectCreation<out expr>				(. expr = Expression.MakeNewExpr(expr); .).
/*------------------------------------------------------------------------*/
ObjectCreation<out Expression expr>     (. var fields = new List<Identifier>(); var values = new List<Expression>(); .)
=
  ident                                 (. expr = AstNode.MakeIdentifier(t.val); .)
  { '.'
    ident                               (. expr = Expression.MakeMemRef(expr, AstNode.MakeIdentifier(t.val)); .)
  }
  '{'
  { ident                               (. fields.Add(AstNode.MakeIdentifier(t.val)); .)
    ':'
    OrTest<out expr>                    (. values.Add(expr); .)
  }
  '}'                                   (. Expression.MakeObjectCreation(fields, values); .).
/*------------------------------------------------------------------------*/
Trailer<ref Expression expr>	(. var args = new List<Expression>(); .)
=
  '('
  [ArgList<ref args>]
  ')'							(. expr = Expression.MakeCallExpr(expr, args); .)
  | '['
    ArgList<ref args>
    ']'							(. expr = Expression.MakeIndexer(expr, args); .)
  | '.'
    ident						(. expr = Expression.MakeMemRef(expr, AstNode.MakeIdent(t.val)); .).
/*------------------------------------------------------------------------*/
ArgList<. ref List<Expression> args .>		(. Expression expr; .)
=
  CondExpr<out expr>						(. args.Add(expr); .)
  { WEAK ','
    CondExpr<out expr>						(. args.Add(expr); .)
  }.
/*------------------------------------------------------------------------*/
Atom<out Expression expr>			(. string name; expr = null; .)
=
  ident								(.  name = t.val;
  										expr = AstNode.MakeIdentifier(name);
  									.)
  | Literal<out expr>
  | IntSeqExpr<out expr>
  | '('
    CondExpr<out expr>
    ')'                             (. expr = Expression.MakeParenExpr(expr); .)
  | '('
    [SequenceMaker<out expr, ObjectTypes.Tuple>]
    SYNC ')'						(.  if(expr == null)
    										expr = Expression.MakeSeqInitializer(ObjectTypes.Tuple, new List<Expression>());
    								.)
  | '['
    [SequenceMaker<out expr, ObjectTypes.List>]
    SYNC ']'						(.  if(expr == null)
    										expr = Expression.MakeSeqInitializer(ObjectTypes.List, new List<Expression>());
    								.)
  | '{'
    [DictMaker<out expr>]
    SYNC '}' 						(. if(expr == null) expr = Expression.MakeSeqInitializer(ObjectTypes.Dict, new List<Expression>()); .).
/*------------------------------------------------------------------------*/
IntSeqExpr<out Expression expr>     (. Expression start = null, end = null, step = null;
                                       bool upper_inclusive = true;
                                    .)
=
  [BitOr<out start>]
  ( ".."                            (. upper_inclusive = false; .)
  | "..."
  )
  BitOr<out end>
  [ ':'
    BitOr<out step>
  ]                                 (.  if(start == null) start = CreateConstant(ObjectTypes.Integer);
                                        if(step == null) step = Expression.MakeConstant(ObjectTypes.Integer, 1);
                                        expr = Expression.MakeIntSeq(start, end, step, upper_inclusive);
                                    .).
/*------------------------------------------------------------------------*/
SequenceMaker<out Expression expr, ObjectTypes ObjType>	(.  Expression tmp = null; List<Expression> list = new List<Expression>();
															expr = null; ComprehensionIter comprehen = null;
														.)
=
  CondExpr<out tmp>
  CompFor<out comprehen>              (. expr = Expression.MakeComp(tmp, (ComprehensionForClause)comprehen, ObjType); .).
/*------------------------------------------------------------------------*/
DictMaker<out Expression expr>			(. Expression key, val; List<Expression> list = new List<Expression>(); expr = null;
                                           ComprehensionIter comp_for, comp_val;
                                        .)
=
  CondExpr<out key>
  CompFor<out comp_key>               (. comp_key = Expression.MakeComp(key, (ComprehensionForClause)comp_key, Objtype); .)
  ':'
  CondExpr<out val>
  CompFor<out comp_val>               (. comp_val = Expression.MakeComp(val, (ComprehensionForClause)comp_val);
                                         expr = Expression.MakeSeqInitializer(ObjType, new []{comp_key, comp_val});
                                      .).
/*------------------------------------------------------------------------*/
CompIter<out ComprehensionIter expr>    (. expr = null; .)
=
  CompFor<out expr>
  | CompIf<out expr> .
/*------------------------------------------------------------------------*/
CompFor<out ComprehensionIter expr>		(. Expression rvalue = null; ComprehensionIter body = null; PatternConstruct target; .)
=
  "for"
  LhsPattern<out target>
  "in"
  CondExpr<out rvalue>
  [CompIter<out body>]					(. expr = Expression.MakeCompFor(target, rvalue, body); .).
/*------------------------------------------------------------------------*/
CompIf<out ComprehensionIter expr>		(. Expression tmp; ComprehensionIter body = null; .)
=
  "if"
  OrTest<out tmp>
  [CompIter<out body>]					(. expr = Expression.MakeCompIf(tmp, body); .).
/*------------------------------------------------------------------------*/
Literal<out Expression expr>	(. expr = null; string tmp; bool has_suffix = false; .)
= 
  integer						(. tmp = t.val; .)
  [ 'l'							(. has_suffix = true; .)
  | 'L'							(. has_suffix = true; .)
  ]								(.  if(has_suffix)
  										expr = AstNode.MakeConstant(ObjectTypes.BigInteger, BigInteger.Parse(tmp));
  									else
  										expr = AstNode.MakeConstant(ObjectTypes.Integer, Convert.ToInt32(tmp));
  								.)
  | hex_digit					(. expr = AstNode.MakeConstant(ObjectTypes.Integer, Convert.ToInt32(t.val, 16)); .)
  | float						(. expr = AstNode.MakeConstant(ObjectTypes.Float, Convert.ToDouble(t.val)); .)
  | string_literal				(. tmp = t.val;
  								   tmp = tmp.Substring(1, tmp.Length - 2);
  								   expr = AstNode.MakeConstant(ObjectTypes.String, tmp);
  								.)
  | 
    ( "true"				
  	| "false"
  	)							(. expr = AstNode.MakeConstant(ObjectTypes.Bool, Convert.ToBoolean(t.val)); .)
  | "self"                      (. expr = AstNode.MakeSelfRef(); .)
  | "super"                     (. expr = AstNode.MakeSuperRef(); .).
/*------------------------------------------------------------------------*/
END Expresso.
